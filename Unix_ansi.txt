

Андрей Робачевский
Операционная система
Рекомендовано Министерством общего и профессионального
образования Российской Федерации в качестве учебного
пособия для студентов высших учебных заведений
Дюссельдорф Киев
Москва Санкт%Петербург
www.books-shop.com
УДК
Книга семейству операционных систем и содержит информацию о прин!
ципах организации, идеологии и архитектуре, объединяющих различные версии этой опе!
рационной системы.
В книге рассматриваются: архитектура ядра UNIX (подсистемы ввода/вывода, управления
памятью и процессами, а также файловая подсистема), программный интерфейс UNIX
(системные вызовы и основные библиотечные функции), пользовательская (команд!
ный интерпретатор команды и утилиты) и сетевая поддержка в UNIX (про!
токолов семейства TCP/IP, архитектура сетевой подсистемы, программные интерфейсы
сокетов и TLI).
Для круга
Группа подготовки издания:
Главный Екатерина
Зав. редакцией Наталья
Редактор Татьяна
Корректор Зинаида Дмитриева
Компьютерная верстка Владислава Сорокина
Дизайн обложки
Зав. производством Николай Тверских
Рукопись книги подготовлена в Республиканском научном центре компьютерных теле%
коммуникационных сетей высшей школы.
Рецензенты:
Зав. кафедрой техника" Санкт!Петербургского государственного
электротехнического университета профессор Д. В. Пузанков
Зав. "Информационные и управляющие системы" Санкт!Петербургского
государственного Технического университета профессор И. Г.
Робачевский А. М.
Операционная система UNIX®. % СПб.: 2002. % 528 ил.
ISBN 5!8206!0030!4
UNIX является
знаком консорциума The Open Group
М. Робачевский, 1997
К. Щукин, 1997
© Оформление, издательство "БХВ%Петербург",
Лицензия ИД № 02429 от 24.07.00. Подписано в печать
Формат Печать офсетная. Усл. печ. л. 42,8.
Доп. тираж 5000 экз. Заказ 1383
"БХВ%Петербург", 198005, Санкт%Петербург, Измайловский пр., 29.
Гигиеническое заключение на продукцию, товар, №
от г. выдано Департаментом ГСЭН Минздрава России.
Отпечатано с готовых диапозитивов
в Академической типографии "Наука" РАН.
199034, Санкт%Петербург, 9 линия, 12.
www.books-shop.com
О КНИГЕ "ОПЕРАЦИОННАЯ СИСТЕМА UNIX" 1
НАЗНАЧЕНИЕ книги 1
НА КОГО РАССЧИТАНА ЭТА КНИГА? 2
ПРИНЯТЫЕ ОБОЗНАЧЕНИЯ 2
ВВЕДЕНИЕ 3
ИСТОРИЯ СОЗДАНИЯ .....3
Исследовательские версии UNIX 4
ГЕНЕАЛОГИЯ UNIX 6
System UNIX 6
System V Release 4 (SVR4) 7
UNIX компании Berkeley Software Distribution 7
8
Версии UNIX, использующие микроядро 8
Свободно распространяемая система UNIX 9
ОСНОВНЫЕ СТАНДАРТЫ 9
10
Х/Ореп 10
SVID 11
ANSI 11
НЕКОТОРЫЕ ИЗВЕСТНЫЕ ВЕРСИИ UNIX
AIX 13
HP%UX 13
IRIX 13
Digital UNIX 13
UNIX 13
Solaris
ПРИЧИНЫ ПОПУЛЯРНОСТИ UNIX 14
ОБЩИЙ взгляд НА АРХИТЕКТУРУ UNIX 15
Ядро системы
Файловая подсистема 17
Подсистема управления процессами
Подсистема
ГЛАВА 1. РАБОТА В ОПЕРАЦИОННОЙ СИСТЕМЕ UNIX 19
ФАЙЛЫ И ФАЙЛОВАЯ СИСТЕМА 20
Типы файлов 21
25
Структура файловой системы UNIX 26
Корневой каталог 26
www.books-shop.com
/bin 27
27
/etc 27
/lib 27
27
28
или /home 28
28
/var 28
28
Владельцы файлов 28
Права доступа к файлу 30
Дополнительные атрибуты файла 35
ПРОЦЕССЫ 38
Программы и процессы 38
Типы процессов 39
Системные процессы 39
Демоны 40
Прикладные процессы 40
Атрибуты процесса 41
Идентификатор процесса Process ID 41
Идентификатор родительского процесса Parent Process ID 41
Приоритет процесса (Nice Number) 41
Терминальная линия (TTY) 41
Реальный (RID) и эффективный (EUID) идентификаторы пользователя .41
Реальный (RGID) и эффективный идентификаторы группы 42
Жизненный путь процесса 42
Сигналы 44
УСТРОЙСТВА 47
Файлы блочных устройств 47
Файлы символьных устройств 47
Мнемоника названий файлов устройств
в файловой системе UNIX 49
ПОЛЬЗОВАТЕЛИ СИСТЕМЫ 50
Атрибуты пользователя 51
Пароли 54
Стандартные пользователи и группы 55
ПОЛЬЗОВАТЕЛЬСКАЯ СРЕДА UNIX 56
Командный интерпретатор shell 56
Синтаксис языка Bourne shell 59
Общий синтаксис скрипта 59
Переменные 60
Встроенные переменные 64
Перенаправление 66
Команды, функции и программы 68
Подстановки, выполняемые командным интерпретатором 71
www.books-shop.com
СОДЕРЖАНИЕ
Запуск команд 73
Условные выражения 74
Команда test 75
Циклы 77
Селекторы 78
Ввод 79
Система управления заданиями 80
Основные утилиты UNIX 82
Утилиты для работы с файлами 82
Утилиты для управления процессами 86
Об администрировании UNIX 88
Ситуация 1. Нехватка дискового пространства 89
Ситуация 2. Избыточная загрузка процессора 89
Ситуация 3. Регистрация новых пользователей 90
Ситуация 4. Авария загрузочного диска 90
Ситуация 5. Слабая производительность сети 91
Ситуация 6. "Глупые" вопросы пользователей 91
Ситуация 7. Установка новой версии операционной системы 91
Ситуация 8. Пользователям необходима электронная
телефонная книга 92
ЗАКЛЮЧЕНИЕ 92
ГЛАВА 2. СРЕДА ПРОГРАММИРОВАНИЯ UNIX 93
ПРОГРАММНЫЙ ИНТЕРФЕЙС UNIX 93
Системные вызовы и функции стандартных библиотек 93
Обработка ошибок 95
СОЗДАНИЕ ПРОГРАММЫ
Исходный текст
Заголовки
Компиляция 105
Форматы исполняемых файлов
Формат ELF
COFF
ВЫПОЛНЕНИЕ ПРОГРАММЫ В ОПЕРАЦИОННОЙ СИСТЕМЕ UNIX
Запуск
Завершение С%программы
РАБОТА с ФАЙЛАМИ
Основные системные функции для работы с файлами
Функция ореп(2) 122
Функция creat(2)
Функция close(2)
Функции dup2(2)
Функция lseek(2)
Функция read(2) и readv(2)
Функции write(2) и writev(2)
www.books-shop.com
Функция pipe(2)
Функция fcntl(2) 129
Стандартная библиотека 130
Связи 133
Файлы, отображаемые в памяти 137
Владение файлами 140
Права доступа
Перемещение по файловой системе 142
Метаданные файла
ПРОЦЕССЫ 146
Идентификаторы процесса
Выделение памяти 150
Создание и управление процессами 154
Сигналы
Надежные сигналы
Группы и сеансы 173
Текущие и фоновые группы процессов
Ограничения
ПРИМЕРЫ ПРОГРАММ
Демон
Командный интерпретатор 184
ЗАКЛЮЧЕНИЕ 186
ГЛАВА 3. ПОДСИСТЕМА УПРАВЛЕНИЯ ПРОЦЕССАМИ 187
ОСНОВЫ УПРАВЛЕНИЯ ПРОЦЕССОМ
Структуры данных процесса
Состояния процесса 191
ПРИНЦИПЫ УПРАВЛЕНИЯ ПАМЯТЬЮ 195
Виртуальная и физическая память 197
Сегменты 199
Страничный механизм 202
Адресное пространство процесса 204
УПРАВЛЕНИЕ ПАМЯТЬЮ ПРОЦЕССА
Области 207
Замещение страниц 210
ПЛАНИРОВАНИЕ ВЫПОЛНЕНИЯ ПРОЦЕССОВ 216
Обработка прерываний таймера
Отложенные вызовы
219
Контекст процесса 221
Принципы планирования процессов 222
СОЗДАНИЕ ПРОЦЕССА 226
ЗАПУСК новой ПРОГРАММЫ 230
ВЫПОЛНЕНИЕ в РЕЖИМЕ ЯДРА 233
СОН И ПРОБУЖДЕНИЕ 234
www.books-shop.com
ЗАВЕРШЕНИЕ ВЫПОЛНЕНИЯ ПРОЦЕССА 235
СИГНАЛЫ 236
Группы и сеансы 236
Управление сигналами 237
Отправление 237
Доставка и обработка сигнала 238
ВЗАИМОДЕЙСТВИЕ МЕЖДУ ПРОЦЕССАМИ 240
Каналы 242
FIFO 243
Идентификаторы и имена в IPC 245
Сообщения 248
Семафоры 253
Разделяемая память 258
Межпроцессное взаимодействие в BSD 264
Программный интерфейс сокетов 265
Пример использования сокетов 274
Сравнение различных систем межпроцессного взаимодействия 277
ЗАКЛЮЧЕНИЕ 278
ГЛАВА 4. ФАЙЛОВАЯ ПОДСИСТЕМА 279
БАЗОВАЯ ФАЙЛОВАЯ СИСТЕМА SYSTEM V 280
Суперблок 281
Индексные дескрипторы 282
Имена файлов 285
Недостатки и ограничения 287
ФАЙЛОВАЯ СИСТЕМА BSD UNIX 288
Каталоги 291
АРХИТЕКТУРА ВИРТУАЛЬНОЙ ФАЙЛОВОЙ СИСТЕМЫ 292
Виртуальные индексные дескрипторы 293
Монтирование файловой системы 296
Трансляция имен 303
ДОСТУП К ФАЙЛОВОЙ СИСТЕМЕ 304
Файловые дескрипторы 306
Файловая таблица 307
Блокирование доступа к файлу 309
БУФЕРНЫЙ кэш
Внутренняя структура буферного кэша 313
Операции 314
Кэширование в SVR4 317
ЦЕЛОСТНОСТЬ ФАЙЛОВОЙ СИСТЕМЫ 317
ЗАКЛЮЧЕНИЕ 321
ГЛАВА 5. ПОДСИСТЕМА 322
ДРАЙВЕРЫ УСТРОЙСТВ 323
www.books-shop.com
Типы драйверов 323
Базовая архитектура драйверов 325
Файловый 333
Клоны 335
Встраивание драйверов в ядро 338
БЛОЧНЫЕ УСТРОЙСТВА 340
СИМВОЛЬНЫЕ УСТРОЙСТВА 342
Интерфейс доступа низкого уровня 343
Буферизация 344
АРХИТЕКТУРА ТЕРМИНАЛЬНОГО ДОСТУПА 346
Псевдотерминалы 348
ПОДСИСТЕМА STREAMS 350
Архитектура STREAMS 352
Модули 356
Сообщения 357
Типы сообщений 361
Передача данных 362
Управление передачей данных 364
Драйвер 368
Головной модуль 369
Доступ к потоку 371
Создание потока 372
Управление потоком 375
Мультиплексирование 377
ЗАКЛЮЧЕНИЕ 380
ГЛАВА 6. ПОДДЕРЖКА СЕТИ В ОПЕРАЦИОННОЙ СИСТЕМЕ UNIX 382
СЕМЕЙСТВО ПРОТОКОЛОВ TCP/IP 383
Краткая история TCP/IP 384
Архитектура TCP/IP 386
Общая модель сетевого взаимодействия OSI 391
ПРОТОКОЛ IP 393
Адресация 398
ПРОТОКОЛЫ ТРАНСПОРТНОГО УРОВНЯ 400
User Datagram Protocol (UDP) 402
Transmisson Control Protocol (TCP) 404
Состояния TCP%сеанса 406
Передача данных
Стратегии реализации TCP 413
Синдром "глупого окна" 414
Медленный старт 416
Устранение затора 417
Повторная передача 419
ПРОГРАММНЫЕ ИНТЕРФЕЙСЫ 420
Программный интерфейс сокетов 420
www.books-shop.com
Программный интерфейс TLI 426
Программный интерфейс высокого уровня.
Удаленный вызов процедур 440
Передача параметров 442
Связывание (binding) 443
Обработка особых ситуаций (exception) 444
Семантика вызова 444
Представление данных 445
Сеть 445
Как это работает? 446
447
448
448
client.c 449
ПОДДЕРЖКА СЕТИ В BSD UNIX 452
Структуры данных 453
Маршрутизация 458
Реализация TCP/IP 464
Модуль IP 466
Модуль UDP 468
Модуль TCP 469
ПОДДЕРЖКА UNIX SYSTEM V 470
472
Взаимодействие с прикладными процессами 481
Интерфейс DLPI 487
Доступ к среде передачи 490
Протокол LLC 492
Инкапсуляция IP 493
Внутренняя архитектура 493
Примитивы DLPI 497
ЗАКЛЮЧЕНИЕ 501
ПРИЛОЖЕНИЕ А. ЭЛЕКТРОННЫЙ СПРАВОЧНИК 503
ПРИЛОЖЕНИЕ Б. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ
ОБ ОПЕРАЦИОННОЙ СИСТЕМЕ UNIX 504
КНИГИ 504
ИНФОРМАЦИЯ в INTERNET 505
ПРЕДМЕТНЫЙ УКАЗАТЕЛЬ 509
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Выражение признательности
Работая над я много раз продумывал содержание этого приятного раз!
дела, каждый раз добавляя в него новые и новые имена людей, без помощи
которых эта книга вряд ли увидела бы свет.
В первую очередь это заслуга директора издательства
Вадима Сергеева и моего коллеги, сотрудника Вузтелекомцентра и автора заме!
чательного справочника "Желтые страницы Internet. Русские ресурсы" Алексея
Именно они убедили меня в том, что такая книга окажется полез!
ной и вдохновили взяться за перо.
Я благодарен руководителям Вузтелекомцентра Владимиру Васильеву и Сер!
гею Хоружникову за помощь и внимание к работе над книгой. Их поддержка
и терпимое отношение к выполнению моих основных обязанностей директора
по развитию Вузтелекомцентра позволили выполнить эту работу.
Без помощи Кирилла Щукина книге грозила опасность увидеть свет без иллю!
страций, что вряд ли сделало бы ее более ясной. Его терпение и профессиона!
лизм позволили превратить туманные наброски в полноценные схемы, от
которых книга значительно выиграла.
Я неоднократно обращался за советом к экспертам по UNIX и прежде всего к
моему коллеге Константину Федорову. Его ценные замечания и рекомендации
помогли мне довести книгу до ее настоящего вида.
Я также хотел бы выразить признательность специалистам фирмы OLLY, и в
особенности ее техническому директору Виталию Кузьмичеву, чьи советы и
консультации благотворно повлияли на содержание этой книги.
Я хотел бы выразить глубокую признательность рецензентам этой кни!
ги — зав. кафедрой "Вычислительная техника" Санкт!Петербургского государ!
ственного электротехнического университета д. т. н. профессору Д. В. Пузан!
кову и зав. кафедрой "Информационные и управляющие системы" Санкт!
Петербургского государственного Технического университета д. т. н. профес!
сору И. Г. Черноруцкому за полезные замечания.
Я хотел бы также поблагодарить зав. редакции издательства
тербург" Елизавету Кароник, которая первой ознакомилась с рукописью и вы!
несла положительный вердикт, за кредит доверия и координацию работ по
созданию книги. Я хочу выразить благодарность Татьяне Темкиной за ее вели!
колепную работу по редактированию книги. Случалось, что отдельные стра!
ницы рукописи содержали меньше основного материала, чем редакторской
правки, с которой я, как правило, всегда соглашался.
Я не могу не выразить признательность моим коллегам по работе Владимиру
Парфенову, Юрию Гугелю, Юрию Кирчину, Нине дружеская под!
держка которых была так кстати.
И, конечно, я хотел бы поблагодарить моих жену и дочь за их терпение и веру в
успешное завершение этой работы. Я также должен извиниться перед ними за
то, что этот труд отнял у меня значительную часть времени, по праву принадле!
жащего им.
Автор
www.books-shop.com
Посвящается моим близким
О книге "Операционная система
Назначение книги
Данная книга не является заменой справочников и различных руководств по опера!
ционной системе UNIX. Более того, сведения, представленные в книге, подчас труд!
но найти в документации, поставляемой с операционной системой. Эти издания на!
сыщены практическими рекомендациями, скрупулезным описанием настроек тех
или иных подсистем, форматов вызова команд и т. п. При этом за кадром часто ос!
таются такие вопросы, как внутренняя архитектура отдельных компонентов системы,
их взаимодействие и принципы работы. Без знания этой "анатомии" работа в опера!
ционной системе превращается в использование заученных команд, а неизбежные
ошибки приводят к необъяснимым последствиям. С другой стороны, в данной книге
вопросам администрирования UNIX, настройке конкретных подсистем и используе!
мым командам уделено значительно меньше внимания. Цель данной книги заключа!
ется в изложении основ организации операционной системы UNIX. Следует иметь
в виду, что именем UNIX обозначается значительное семейство операционных сис!
тем, каждая из которых имеет свое название и присущие только ей особенности. В
этой книге сделана попытка выделить то общее, что составляет "генотип" UNIX, a
именно: базовый пользовательский и программный интерфейсы, назначение основ!
ных компонентов, их архитектуру и взаимодействие, и на основе этого представить
систему в целом. В то же время там, где это имеет значение, приводятся ссылки на
конкретную версию UNIX. Для иллюстрации отдельных положений использовались
следующие операционные системы: Solaris 2.5 фирмы Sun Microsystems, SCO ODT
5.0 фирмы Santa Cruz Operation, BSDi/386 фирмы Berkeley Software Design.
Рождению этой книги предшествовал более чем трехлетний опыт чтения лекций по
системе UNIX студентам третьего курса Санкт!Петербургского института точной
механики и оптики (технического университета), а также вводного курса для пользо!
вателей и администраторов UNIX в различных организациях. Большая часть мате!
риала этих курсов нашла свое отражение в книге.
Книга может оказаться полезной при подготовке ряда лекционных программ по опе!
рационной системе UNIX и основам организации операционных систем в целом.
Материал главы 1 является хорошей основой для вводного курса по UNIX. В нем
представлены основные понятия и организация операционной системы в целом. В
этой же главе приведены основные сведения о пользовательском интерфейсе и языке
программирования командного интерпретатора shell.
Материал главы 2 может быть использован в курсах по программированию. Подроб!
ное обсуждение основных системных вызовов и библиотечных функций дает доста!
точно полное представление о программном интерфейсе этой операционной систе!
мы. Приведенные примеры иллюстрируют обсуждаемые вопросы и могут найти свое
отражение в лабораторном практикуме.
Главы содержат более детальное обсуждение отдельных компонентов UNIX:
файловой подсистемы, подсистемы управления процессами и памятью, подсистемы
ввода/вывода. Эти сведения подойдут как для углубленного курса по UNIX, так и
для курса по принципам организации операционных систем. Отдельные части главы 6
могут быть также включены в курс по компьютерным сетям.
Книга может использоваться и в качестве учебного пособия для студентов старших
курсов по специальностям "Информатика и вычислительная техника", "Прикладная
www.books-shop.com
О книге "Операционная система
математика и информатика" (при подготовке бакалавров) и по специальности
"Вычислительные машины, комплексы системы и сети" (при подготовке инженеров)
она может быть полезной при подготовке магистров и аспирантов, а также всем сту!
дентам, специализирующимся в области компьютерных технологий.
Книга также является хорошим подспорьем для системных программистов и админи!
страторов UNIX. Надеюсь, что более пристальный взгляд на внутреннюю организацию
системы поможет им эффективнее решать поставленные задачи и откроет новые гори!
зонты для экспериментов.
Наконец, книга может оказаться интересной для широкого круга пользователей, же!
лающих побольше узнать об этой операционной системе.
На кого рассчитана эта книга?
Бессмысленно разбираться в операционной системе, не работая с ней. Прежде всего,
знание операционной системы, ее организации и структуры необходимо администра!
тору, т.е. человеку, отвечающему за ее сопровождение и настройку. Задачи администра!
тора многочисленны — от регистрации пользователей до конфигурации сети, от созда!
ния резервных копий системы до настройки производительности. Без понимания
принципиального устройства операционной системы решение всех этих задач превра!
щается в заучивание команд и пунктов меню, а нештатные ситуации вызывают панику.
Знание операционной системы нужно разработчику программного обеспечения. От
того, насколько эффективно используются ресурсы операционной системы, зависит
быстродействие вашей программы. Не понимая принципов работы, легко запутаться
в тонкостях системных вызовов и библиотечных функций. Если же вы работаете с
ядром системы — например, разрабатываете драйвер устройства, — без знания сис!
темы вы не продвинетесь ни на шаг.
Наконец, если вы просто пользователь, то знание операционной системы ограничи!
вается теми задачами, которые вам необходимо решать в процессе работы. Скорее
всего, это несколько команд, а если вы работаете с графической оболочкой, то и
этого вам не понадобится. Но так ли приятно работать с черным ящиком?
Принятые обозначения
Системные вызовы, библиотечные функции, команды shell выделены в тексте курси!
вом, например open(2), cat(l) или В скобках указывается раздел электронного
справочника (описание справочника приведено в приложении А).
Структуры данных, переменные и внутренние функции подсистем ядра, исходные
тексты программ и примеры работы в командной строке напечатаны шрифтом фик!
сированной ширины. Например, d_open sleep или пример программы:
int
{
exit ()
}
В примерах работы в командной строке ввод пользователя выделен полужирным
шрифтом фиксированной ширины, например:
$
Enter old password:
Имена файлов выделены полужирным начертанием, например /etc/passwd или
<sys/user.h>.
Клавиши клавиатуры показаны курсивом и заключены в угловые скобки, например
или <Ctrl>+<C> (в последнем случае показана комбинация клавиш).
www.books-shop.com
Скоро исполнится 30 лет с момента создания операционной системы
UNIX. Изначально созданная для компьютера PDP!7 с 4 килобайтами
оперативной памяти, сегодня UNIX на множестве аппаратных
платформ, начиная с обыкновенного PC и заканчивая мощными много!
процессорными системами и суперкомпьютерами.
Система UNIX была создана небольшой группой разработчиков, тысячи
людей вложили в нее свой талант, десятки тысяч обогатили приложения!
ми, и сегодня сотни тысяч людей используют эту операционную систему в
своей деятельности.
За время своего существования система UNIX претерпела значительные
изменения, стала мощней, сложней и удобней. Однако основные идеи со!
хранились, удивляя нас своим изяществом и простотой. Именно они оп!
ределяют "генотип" операционной системы, позволяя увидеть за красивы!
ми названиями различных версий лаконичное слово UNIX. Именно изя!
щество и простота этих идей являются основой жизненной силы UNIX, ее
способности всегда идти в ногу со временем.
История создания
В 1965 году Bell Telephone Laboratories (подразделение AT&T) совместно с
General Electric Company и институтом технологии (MIT)
начали разрабатывать новую операционную систему, названную MULTICS
(MULTiplexed Information and Computing Service). Перед участниками про!
екта стояла цель создания многозадачной операционной системы разделе!
ния времени, способной обеспечить одновременную работу нескольких
сотен пользователей. От Bell Labs в проекте приняли участие два сотруд!
ника — Кен Томпсон (Ken Tompson) и Дэннис Ритчи (Dennis Ritchie). Хо!
тя система MULTICS так и не была завершена (в 1969 году Bell Labs вы!
шла из проекта), она стала предтечей операционной системы, впоследст!
вии получившей название UNIX.
Однако Томпсон, Ритчи и ряд других сотрудников продолжили работу над
созданием удобной среды программирования. Используя идеи и разработ!
www.books-shop.com
4 Введение
ки, появившиеся в результате работы над MULTICS, они создали в 1969
небольшую операционную систему, включавшую файловую систему,
подсистему управления процессами и небольшой набор утилит. Система
была написана на ассемблере и применялась на компьютере PDP!7. Эта
операционная система получила название UNIX, созвучное MULTICS и
придуманное другим членом группы разработчиков, Брайаном Кернига!
ном (Brian Kernighan).
Хотя ранняя версия UNIX много обещала, она не смогла бы реализовать
весь свой потенциал без применения в каком!либо реальном проекте.
И такой проект нашелся. Когда в 1971 году патентному отделу Bell Labs
понадобилась система обработки текста, в качестве операционной системы
была выбрана UNIX. К тому времени система UNIX была перенесена на
более мощный PDP!11, да и сама немного подросла: 16К занимала собст!
венно система, 8К отводились прикладным программам, максимальный
размер файла был установлен равным 64К при дискового простран!
ства.
Вскоре после создания первых ассемблерных версий Томпсон начал рабо!
тать над компилятором для языка FORTRAN, а в результате разработал
язык В. Это был интерпретатор со всеми свойственными интерпретатору
ограничениями, и Ритчи переработал его в другой язык, названный С, по!
зволявший генерировать машинный код. В 1973 году ядро операционной
системы было переписано на языке высокого уровня С, — неслыханный
до этого шаг, оказавший громадное влияние на популярность UNIX. Это
означало, что теперь система UNIX может быть перенесена на другие ап!
паратные платформы за считанные месяцы, кроме того, значительная мо!
дернизация системы и внесение изменений не представляли особых труд!
ностей. Число работающих систем в Bell Labs превысило 25, и для сопро!
вождения UNIX была сформирована группа UNIX System Group (USG).
Исследовательские версии UNIX
В соответствии с федеральным законодательством AT&T не имела права
коммерческого распространения UNIX и использовала ее для собственных
нужд, но начиная с 1974 года операционная система стала передаваться
университетам для образовательных целей.
Операционная система модернизировалась, каждая новая версия снабжа!
лась соответствующей редакцией Руководства Программиста, откуда и са!
ми версии системы получили название редакций (Edition). Всего было вы!
пущено 10 версий!редакций, первая из которых вышла в 1971, а послед!
няя — в 1989 году. Первые семь редакций были разработаны в Bell Labs
Официальной датой рождения UNIX можно считать 1 января 1970 года. Именно с этого
момента любая система UNIX отсчитывает свое системное время.
www.books-shop.com
создания
Группой компьютерных исследований (Computer Research Group, CRG) и
предназначались для компьютеров PDP!11, позже — для VAX. Другая
группа, UNIX System Group, отвечала за сопровождение системы. Третья
группа (Programmer's PWB) занималась разработкой среды
программирования, ей мы обязаны появлением системы SCCS, именован!
ных каналов и других важных идей. Вскоре после выпуска Седьмой редак!
ции разработкой системы стала заниматься USG.
Наиболее важные версии:
Первая редакция 1971
Третья редакция 1973
Четвертая редакция 1973
Шестая редакция 1975
Первая версия UNIX, написанная на ассемблере
для PDP%11. Включала компилятор В и много
известных команд и утилит, в том числе cat(1),
mail(1),
mount(1M),
rmdir(1), wc(1), В основном использова%
лась как инструментальное средство обработки
текстов для патентного отдела.
В системе появилась команда сс(1), запускав%
шая компилятор С. Число установленных систем
достигло
Первая система, в которой ядро написано на
языке высокого уровня С.
Первая версия системы, доступная за предела%
ми Bell Labs. Система полностью переписана на
языке С. С этого времени начинается появление
новых версий, разработанных за пределами Bell
Labs, и рост популярности UNIX. В частности,
эта версия системы была установлена Томпсо%
ном в Калифорнийском университете в Беркли,
и на ее основе вскоре была выпущена первая
версия BSD (Berkeley Software Distribution) UNIX.
Эта версия включала командный интерпретатор
Bourne Shell и компилятор С от Кернигана и
Ритчи. Ядро было переписано для упрощения
переносимости системы на другие платформы.
Лицензия на эту версию была куплена фирмой
Microsoft, которая разработала на ее базе опе%
рационную систему XENIX.
Популярность UNIX росла, и к 1977 году число работающих систем уже
превысило 500. В 1977 году компания Interactive Systems Corporation стала
первым VAR (Value Added Reseller) системы UNIX, расширив ее для ис!
пользования в системах автоматизации. Этот же год стал годом первого
портирования UNIX с незначительными изменениями на компьютер, от!
личный от PDP.
Седьмая редакция 1979
www.books-shop.com
Введение
Генеалогия UNIX
Хотя книге речь пойдет о системах с общим названием UNIX, стоит ого!
вориться, что обсуждать мы будем различные операционные системы. Не
существует некоторой "стандартной" системы UNIX, вместо этого вы
столкнетесь с множеством операционных систем, имеющих собственные
названия и особенности. Но за этими особенностями и названиями все же
нетрудно заметить архитектуру, пользовательский интерфейс и среду про!
граммирования UNIX. Объясняется это достаточно просто — все эти опе!
рационные системы являются ближними или дальними родственниками.
Поэтому знакомство с ними мы начнем с рассказа о генеалогии UNIX.
System V UNIX
Начиная с 1975 года фирма AT&T начала предоставлять лицензии на ис!
пользование операционной системы как научно!образовательным учреж!
дениям, так и коммерческим организациям. Поскольку основная часть
системы поставлялась в исходных текстах, написанных на языке С, опыт!
ным программистам не требовалось детальной документации, чтобы разо!
браться в архитектуре UNIX. С ростом популярности микропроцессоров
другие компании переносили UNIX на различные платформы, но простота
и ясность операционной системы искушали многих на ее расширение и
модификацию, в результате чего появилось много различных вариантов
базовой системы.
Не желая терять инициативу, AT&T в 1982 объединила несколько сущест!
вующих версий UNIX и создала версию под названием System III. В отли!
чие от редакций, предназначавшихся, в первую очередь, для внутреннего
использования и не получивших дальнейшего развития, System III была
создана для распространения за пределами Bell Labs и AT&T и положила
начало мощной ветви UNIX, которая и сегодня жива и развивается.
В 1983 году Bell Labs выпустила новую версию системы — System V. В 1984
году группа USG была трансформирована в лабораторию (UNIX System
Development Laboratory, которая вскоре выпустила новую моди!
фикацию системы — System V Release 2 (SVR2). В этой версии были реа!
лизованы такие механизмы управления памятью, как замещение страниц и
копирование при записи (copy on write), и представлена система межпро!
цессного взаимодействия (InterProcess Communication, IPC) с разделяемой
памятью, очередью сообщений и семафорами.
В 1987 году появилась следующая версия — System V Release 3 (SVR3). За
ее разработку отвечало новое подразделение AT&T — Информационные
системы AT&T (AT&T Information Systems, Эта версия отличалась
большим набором дополнительных возможностей, включавших:
О Подсистему ввода/вывода, основанную на архитектуре STREAMS.
Переключатель файловой системы (File System Switch), обеспечи!
вавший одновременную поддержку различных файловых систем.
www.books-shop.com
Генеалогия UNIX
Разделяемые библиотеки.
Программный интерфейс сетевых приложений Transport Layer
Interface (ТЫ).
System V Release 4 (SVR4)
В 1989 году была выпущена новая основная версия — System V Release 4.
По существу она объединила возможности нескольких известных версий
UNIX: SunOS фирмы Sun Microsystems, BSD UNIX компании Berkeley
Software Distribution и предыдущих версий System V.
Новые черты системы включали:
Командные интерпретаторы и С (BSD)
П Символические ссылки
П Систему терминального ввода/вывода, основанную на STREAMS
(System V)
П Отображаемые в память файлы (SunOS)
П Сетевую файловую систему NFS и систему вызова удаленной про!
цедуры (SunOS)
О Быструю файловую систему FFS (BSD)
Сетевой программный интерфейс сокетов (BSD)
П Поддержку диспетчеризации реального времени
Многие компоненты системы были поддержаны стандартами ANSI,
POSIX, и SVID.
UNIX компании Berkeley Software Distribution
Четвертая редакция UNIX была установлена в Калифорнийском универси!
тете в Беркли в 1974 году. С этого момента начинает свою ветвь
UNIX, известная под названием BSD UNIX. Первая версия этой системы
основывалась на Шестой редакции и была выпущена в 1978 году. В 1979
году на базе Седьмой редакции была разработана новая версия UNIX —
3BSD. Она явилась первой версией BSD, перенесенной на ЭВМ VAX.
В этой системе, в частности, были реализованы виртуальная память (virtual
memory) и страничное замещение по требованию (demand paging).
Важным для развития системы явился 1980 год, когда фирма Bolt, Beranek
and Newman (BBN) подписала контракт с Отделом перспективных иссле!
довательских проектов (DARPA) Министерства обороны США на разра!
ботку поддержки семейства протоколов TCP/IP в BSD UNIX. Эта работа
была закончена в конце 1981 года, а ее результаты интегрированы
в 4.2BSD UNIX.
www.books-shop.com
8
Версия 4.2BSD была выпущена в середине 1983 года и включала поддерж!
ку работы в сетях, в частности, в сетях Ethernet. Это способствовало ши!
рокому распространению локальных сетей, основанных на этой техноло!
гии. Система также позволяла подключиться к сети ARPANET,
быстрый рост которой наблюдается с начала 80!х. Разумеется, такая опе!
рационная система не могла не пользоваться большой популярностью.
К тому же, в отличие от положения в AT&T, где сетевые разработки
обычно не выходили за пределы компании, результаты, полученные в
Беркли, были широко доступны. Поэтому стала наиболее попу!
лярной системой в исследовательских кругах.
Однако большое количество нововведений привело к тому, что система
получилась сырой, содержала ряд ошибок и имела определенные пробле!
мы с быстродействием. В 1986 году была выпущена следующая версия —
4.3BSD, более надежная и с лучшей производительностью. В период с 1986
по 1990 год в систему было внесено много дополнений, включая сетевую
файловую систему NFS, виртуальную файловую систему VFS, отладчик
ядра и мощную поддержку сети.
Последними версиями, выпущенными в Беркли, стали системы 4.4BSD и
BSD Lite, появившиеся в 1993 году.
OSF/1
В 1988 году AT&T и Sun Microsystems заключили соглашение о сотрудни!
честве в области разработки будущих версий System V. В ответ на это ряд
компаний, производящих компьютеры или имеющих отношение к вычис!
лительной технике, включая IBM, DEC, Hewlett!Packard, создали органи!
зацию под названием Open Software Foundation (OSF), целью которой яв!
лялась разработка независимой от AT&T версии операционной системы.
Результатом деятельности этой организации стала операционная система
OSF/1. Хотя ряд коммерческих операционных систем связывают себя с
этой ветвью, нельзя сказать, что OSF/1 явилась новым словом в мире
UNIX. Скорее, это был политический шаг, призванный снизить домини!
рующую роль ряда фирм, занимавшихся разработкой UNIX System V.
Версии UNIX, использующие микроядро
Идея микроядра заключается в сведении к минимуму функций, выпол!
няемых ядром операционной системы, и, соответственно, предоставляе!
мых базовых услуг. При этом основные компоненты операционной систе!
мы являются модулями, работающими на базе микроядра. С одной сторо!
ны, такой подход делает микроядро более универсальным, позволяя кон!
струировать специализированные операционные системы, а с другой, —
упрощает настройку и конфигурирование.
www.books-shop.com
Основные
Наиболее известны следующие версии микроядра:
Микроядро Mach, разработанное в университете Карнеги!Меллона.
Сегодня Mach используется в системе фирмы DEC для серве!
ров с процессорами Alpha, а также в операционной системе
Workplace фирмы IBM.
Микроядро Chorus. На базе этого микроядра созданы системы
Chorus/MiX V.3 и Chorus/MiX V.4, являющиеся
SVR3 и SVR4. При этом ядро UNIX разделено на множество серве!
ров, выполняющихся под управлением микроядра, причем эти сер!
веры могут находиться как на одном компьютере, так и быть распре!
делены в сети.
Свободно распространяемая система UNIX
Достаточно дешевый PC и свободно распространяемая система UNIX де!
лают эту систему сегодня доступной практически каждому.
Очень популярная версия UNIX для PC, называемая была разрабо!
тана Энди Тэненбаумом (Andy Tanenbaum) как приложение к его книге по
архитектуре UNIX. Книга Тэненбаума содержит полные листинги исход!
ных текстов системы. Дополнительный набор дискет позволяет установить
Minix даже на PC с процессором 8086 (если найдется такой компьютер).
В последнее время все большую популярность приобретает свободно рас!
пространяемая версия UNIX под названием Linux, разработанная исследо!
вателем университета Хельсинки Линусом (Linus
Разработанная "с нуля" для процессора Intel i386, сегодня она перенесена
на ряд других аппаратных платформ, включая серверы Alpha фирмы DEC.
Основные стандарты
UNIX явилась первой действительно переносимой системой, и в этом од!
на из причин ее успеха.
Как в ранние, бесплатно распространяемые, исследовательские версии,
так и в сегодняшние коммерческие и свободно распространяемые версии
UNIX постоянно вносятся изменения. С одной стороны, это расширяет
возможности системы, делает ее мощнее и надежнее, с другой — ведет
к значительным различиям между существующими версиями, отсутствию
канонического UNIX.
Чем больше появлялось версий UNIX (и особенно коммерческих), тем
очевиднее становилась необходимость стандартизации системы. Наличие
стандартов облегчает переносимость приложений и защищает как пользо!
вателей, так и производителей. В результате возникло несколько органи!
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
заций, связанных со стандартизацией, и был разработан ряд стандартов,
оказывающих влияние на развитие UNIX.
IEEE и POSIX
В 1980 году была создана инициативная группа под названием с
целью стандартизации программного интерфейса UNIX, т. е. формального
определения услуг, предоставляемых операционной системой приложени!
ям. Решение этой задачи упростило бы переносимость приложений между
различными версиями UNIX. Такой стандарт был создан в 1984 году и ис!
пользовался комитетом ANSI, отвечающим за стандартизацию языка С,
при описании библиотек. Однако с ростом числа версий операционной
системы эффективность стандарта уменьшилась, и через год, в 1985 году,
был создан Portable Operating System Interface for Computing Environment,
сокращенно POSIX (переносимый интерфейс операционной системы для
вычислительной среды).
В 1988 году группой был разработан стандарт POSIX 1003.1!1988, который
определил программный интерфейс приложений (Application Programming
Interface, API). Этот стандарт нашел широкое применение во многих опе!
рационных системах, в том числе и с отличной от UNIX.
Спустя два года стандарт был принят как стандарт ШЕЕ 1003.1!1990. Заме!
тим, что поскольку этот стандарт определяет интерфейс, а не конкретную
реализацию, он не делает различия между системными вызовами и биб!
лиотечными функциями, называя все элементы программного интерфейса
просто функциями.
Другими наиболее значительными стандартами POSIX, относящимися к
UNIX, являются:
POSIX 1003.2%1992 Включает определение командного интерпретатора UNIX и
набора утилит
POSIX Содержит дополнения, относящиеся к поддержке приложе%
ний реального времени
POSIX Включает определения "нитей" (threads) POSIX, известных
также как pthreads
В 1984 году ряд европейских компьютерных компаний сформировал не!
коммерческую организацию, получившую название Название
полностью отражает цель этой организации — разработку общего набора
интерфейсов операционной системы, согласованного между различными
производителями, и создание действительно открытых систем, для кото!
рых стоимость переносимости приложений как между различными вер!
www.books-shop.com
Основные 77
сиями одной операционной системы, так и между системами различных
производителей была бы минимальной.
Основной задачей организации Х/Open являлось согласование и утвер!
ждение стандартов для создания общего программного интерфейса и
программной среды для приложений. В 1992 году появился документ, из!
вестный под названием Portability Guide версии 3 или ко!
торый включал POSIX 1003.1!1988 и стандарт на графическую систему X
Window System, разработанную в институте технологии.
В дальнейшем интерфейсы XPG3 были расширены, включив базовые API
систем BSD и System V (SVID), в том числе и архитектуру STREAMS.
В результате была выпущена спецификация, ранее известная как Spec
а в 1994 году получившая название XPG4.2.
В 1996 году объединение усилий Х/Open и OSF привело к созданию кон!
сорциума The Open Group, продолжившего разработки в области открытых
систем. В качестве примера можно привести такие направления, как даль!
нейшая разработка пользовательского интерфейса, Common Desktop
Environment (CDE), и его сопряжение со спецификацией графической
оболочки Motif. Другим примером является разработка стандартных ин!
терфейсов для распределенной вычислительной среды Distributed
Computing Environment (DCE), работа над которой была начата OSF.
SVID
Вскоре после выхода в свет в 1984 году версии группа USG выпус!
тила документ под названием System V Interface Definition, SVID, в кото!
ром описывались внешние интерфейсы UNIX версий System V. По суще!
ству, этот труд (в двух томах) определял соответствие операционной сис!
темы версии System V.
В дополнение к SVID был выпущен т. н. System V Verification Suite, —
набор тестовых программ, позволяющих производителям получить ответ,
достойна ли их система права носить имя System V.
С появлением SVR4 было выпущено новое издание SVID (уже в четырех
томах) и, соответственно, новый SWS.
ANSI
В конце 1989 года Американским национальным институтом стандартов
(American National Standards Institute, ANSI) был утвержден стандарт
языка программирования С. Целью стандарта
являлось улучшение переносимости программ, написанных на языке С, в
различные операционные системы (не только UNIX). Стандарт определяет
не только синтаксис и семантику языка, но и содержимое стандартной
библиотеки.
www.books-shop.com
12
Некоторые известные версии UNIX
Сегодня существуют десятки различных операционных систем, которые
можно называть UNIX. В основном, это коммерческие версии, в которых
создатели пытались как можно эффективнее решить вопросы реализации
той или иной подсистемы. Во многих случаях, производитель операцион!
ной системы является и производителем аппаратной платформы, для ко!
торой эта система предназначена. В качестве примеров можно привести
операционные системы SunOS и Solaris фирмы Sun Microsystems, HP!UX
фирмы Hewlett!Packard, AIX фирмы IBM, IRIX фирмы Silicon Graphics.
Вполне естественно, что производитель хочет сделать операционную сис!
тему привлекательнее, чем у конкурентов, и не только за счет лучшей
производительности, но и за счет расширений и дополнительных возмож!
ностей, отсутствующих у других. С другой стороны, производитель желает,
чтобы его операционная система оставалась открытой: сегодня закрытые
корпоративные решения отпугивают потребителя. Понятно, что в такой
ситуации единства и борьбы противоположностей вряд ли найдется систе!
ма, которую можно назвать "чистой системой UNIX". Да и такое понятие
сегодня вряд ли существует. По мнению некоторых разработчиков послед!
ней "чистой системой UNIX" являлась Седьмая редакция, сегодня же
можно говорить только о наличии в операционной системе черт той или
иной ветви — System V, BSD или OSF/1. Можно, например, сказать, что с
точки зрения администрирования и набора утилит Digital UNIX представ!
ляет смесь System V и BSD UNIX, но с точки зрения интерфейсов и орга!
низации системы — это BSD.
Поэтому определение принадлежности конкретной операционной системы
к той или иной генеалогической ветви носит весьма условный характер. С
этой оговоркой в табл. 1 приведены несколько индикаторов (с точки зре!
ния пользователя и администратора) принадлежности UNIX одной из двух
основных ветвей.
Таблица К какой генеалогической ветви принадлежит ваша система?
Индикатор
Имя ядра
Терминальная ини%
циализация
Файлы инициализа%
ции системы
Конфигурация мон%
тируемых файловых
систем
Типично для SVRx
каталоги /etc/rc*.d
Типично для
/vmunix
файлы
xBSD
Обычный командный sh(1), csh(1)
интерпретатор
www.books-shop.com
Некоторые известные версии UNIX 13
Таблица 1 (продолжение)
Индикатор
"Родная" файловая
система
Система печати
Управление терми%
налами
Отображение ак%
тивности процессов
Типично для SVRx
S5 (размер блока: байт),
имена файлов символов
lp(1),
Типично для
UFS (размер блока:
имена файлов < 255 символов
lpq(1), daemon)
ps !aux
Ниже приведены краткие характеристики наиболее популярных версий
UNIX.
AIX
Версия UNIX фирмы IBM на базе SVR2 со многими чертами BSD и
OSF/1. Собственная система администрации (SMIT).
HPUX
Версия UNIX фирмы Hewlett!Packard. В 1996 году компания выпустила но!
вые версии — HP!UX 10.10 и HP!UX 10.20, включающие поддержку сим!
метричных многопроцессорных систем файловых систем большого
размера (до 128 Гбайт) и расширение виртуального адресного пространства
прикладных процессов до 3,75 Гбайт. В середине 1997 года планируется вы!
пустить полностью 64!разрядную версию операционной системы.
IRIX
Версия UNIX фирмы Silicon Graphics, предназначенная для аппаратной
платформы этого производителя (MIPS). Ранние версии системы включа!
ли много черт BSD UNIX, однако современную систему IRIX (6.x) скорее
можно отнести к ветви System V Release 4. Полностью 64!разрядная опе!
рационная система.
Digital UNIX
Версия системы OSF/1 фирмы Digital Equipment Corporation (DEC).
В прошлом система называлась DEC OSF/1 и по сути являлась BSD UNIX.
В то же время в ней есть много черт ветви System V. Полностью 64!раз!
рядная операционная система, разработанная в первую очередь для аппа!
ратной платформы Alpha, содержит все возможности, присущие современ!
ным UNIX, — DCE, CDE, современную файловую систему. Поддерживает
большинство сетевых интерфейсов, включая Fast Ethernet и ATM.
SCO UNIX
В 1988 году компании Santa Cruz Operation (SCO), Microsoft и Interactive
Systems завершили совместную разработку версии System V Release 3.2 для
www.books-shop.com
14
платформы Intel 386. В том же году SCO получила от AT&T лицензию на
торговую марку и операционная система стала называться SCO UNIX
System V/386. В 1995 году компания SCO выпустила версию системы под
названием SCO Release 5 (кодовое название Everest) — UNIX
версии со многими чертами SVR4. Новая версия системы поддер!
живает более 900 аппаратных платформ, включая мультипроцессорные вы!
числительные системы, и более 2000 периферийных устройств.
Solaris
Версия UNIX SVR4 фирмы Sun Microsystems. Версия 2.5.1 содержит ком!
поненты ядра, использующие 64!разрядную аппаратную архитектуру. Под!
держивает распространенные аппаратные платформы, в том числе
UltraSPARC, Intel 486, Pentium, Pentium Pro и PowerPC. В 1998 году пла!
нируется выпустить полностью 64!разрядную версию операционной сис!
темы.
Причины популярности UNIX
Почти три десятилетия существования UNIX — очень большой срок для
операционной системы. Смело можно сказать, что она полностью выдер!
жала проверку временем. На каждом этапе своего развития операционная
система UNIX решала определенные задачи, и сегодня, несмотря на появ!
ление более простых и удобных, с точки зрения администрирования, сис!
тем, UNIX прочно занимает место среди лидеров. Самое удивительное,
что во многих случаях речь при этом идет не о конкретной версии, на!
пример Solaris или SCO, а именно о системе UNIX как таковой.
Перечислим основные черты UNIX, позволяющие понять причины дол!
гожительства этой системы:
1. Код системы написан на языке высокого уровня С, что сделало ее
простой для понимания, изменений и переноса на другие платформы.
По оценкам одного из создателей UNIX, Дэнниса Ритчи, система на
языке С имела на больший размер, а производительность ее
была на 20% ниже аналогичной системы, написанной на ассемблере.
Однако ясность и переносимость, а в результате — и открытость сис!
темы сыграли решающую роль в ее популярности. Можно смело ска!
зать, что UNIX является одной из наиболее открытых систем. Несмот!
ря на то, что большинство UNIX поставляется сегодня не в исходных
текстах, а в виде бинарных файлов, система остается легко расширяе!
мой и настраиваемой.
2. UNIX — многозадачная многопользовательская система с широким
спектром услуг. Один мощный сервер может обслуживать запросы
большого количества пользователей. При этом необходимо админист!
рирование только одной системы. Ваша система может выполнять раз!
www.books-shop.com
Общий на архитектуру UNIX
личные функции — работать как вычислительный сервер, обслужи!
вающий сотни пользователей, как сервер базы данных, как сетевой
сервер, поддерживающий важнейшие сервисы сети (telnet, ftp, элек!
тронную почту, службу имен DNS и т. д.), или даже как сетевой мар!
шрутизатор.
3. Наличие стандартов. Несмотря на многообразие версий UNIX, осно!
вой всего семейства являются принципиально одинаковая архитектура
и ряд стандартных интерфейсов. Опытный администратор без боль!
шого труда сможет обслужить другую версию системы, для пользова!
телей переход на другую версию и вовсе может оказаться незаметным.
4. Простой, но мощный модульный пользовательский интерфейс. Имея в
своем распоряжении набор утилит, каждая из которых решает узкую
специализированную задачу, вы можете конструировать из них слож!
ные комплексы.
5. Использование единой, легко обслуживаемой иерархической файловой
системы. Файловая система — это не только доступ к данным, храня!
щимся на диске. Через унифицированный интерфейс файловой систе!
мы осуществляется доступ к терминалам, принтерам, магнитным лен!
там, сети и даже к памяти.
6. Очень большое количество приложений, в том числе свободно распро!
страняемых, начиная от простейших текстовых редакторов и заканчи!
вая мощными управления базами данных.
Общий взгляд на архитектуру UNIX
Самый общий взгляд позволяет увидеть двухуровневую модель системы
так, как она представлена на рис. 1.
Рис. 1. Модель системы
UNIX
www.books-shop.com
16
В центре находится ядро системы (kernel). Ядро непосредственно взаимо!
действует с аппаратной частью компьютера, изолируя прикладные про!
граммы от особенностей ее архитектуры. Ядро имеет набор услуг, предос!
тавляемых прикладным программам. К услугам ядра относятся операции
ввода/вывода (открытия, чтения, записи и управления файлами), создания
и управления процессами, их синхронизации и межпроцессного взаимо!
действия. Все приложения запрашивают услуги ядра посредством систем!
ных вызовов.
Второй уровень составляют приложения или задачи, как системные, опре!
деляющие функциональность системы, так и прикладные, обеспечиваю!
щие пользовательский интерфейс UNIX. Однако несмотря на внешнюю
разнородность приложений, схемы их взаимодействия с ядром одинаковы.
Рассмотрим более внимательно отдельные компоненты ядра системы.
Ядро системы
Ядро обеспечивает базовую функциональность операционной системы:
создает процессы и управляет ими, распределяет память и обеспечивает
доступ к файлам и периферийным устройствам.
Взаимодействие прикладных задач с ядром происходит посредством стан!
дартного интерфейса системных вызовов. Интерфейс системных вызовов
представляет собой набор услуг ядра и определяет формат запросов на ус!
луги. Процесс запрашивает услугу посредством системного вызова опреде!
ленной процедуры ядра, внешне похожего на обычный вызов библиотеч!
ной функции. Ядро от имени процесса выполняет запрос и возвращает
процессу необходимые данные.
В приведенном примере программа открывает файл, считывает из него
данные и закрывает этот файл. При этом операции открытия (open), чте!
ния (read) и закрытия (close) файла выполняются ядром по запросу задачи,
а функции read(2) и close(2) являются системными вызовами.
main
{
int fd;
char
/*Откроем файл — получим ссылку (файловый дескриптор)
fd = 0_RDONLY)
в буфер buf 80
read(fd, buf,
}
www.books-shop.com
Общий взгляд на архитектуру UNIX 17
Структура ядра представлена на рис 2.
Пользовательский
уровень
Системный уровень
Системный уровень
Аппаратный уровень Рис. 2. Внутренняя струк%
тура ядра UNIX
Ядро состоит из трех основных подсистем:
1. Файловая подсистема
2. Подсистема управления процессами и памятью
Подсистема ввода/вывода
Файловая подсистема
Файловая подсистема обеспечивает унифицированный интерфейс доступа
к данным, расположенным на дисковых накопителях, и к периферийным
устройствам. Одни и те же функции ореп(2), read(2), могут исполь!
зоваться как при чтении или записи данных на диск, так и при выводе
текста на принтер или терминал.
Файловая подсистема контролирует права доступа к файлу, выполняет
операции размещения и удаления файла, а также выполняет запись/чтение
данных файла. Поскольку большинство прикладных функций выполняется
через интерфейс файловой системы (в том числе и доступ к периферий!
ным устройствам), права доступа к файлам определяют привилегии поль!
зователя в системе.
Файловая подсистема обеспечивает перенаправление запросов, адресован!
ных периферийным устройствам, соответствующим модулям подсистемы
ввода/вывода.
www.books-shop.com
18
Подсистема управления процессами
Запущенная на выполнение программа порождает в системе один или более
процессов (или задач). Подсистема управления процессами контролирует:
О Создание и удаление процессов
Распределение системных ресурсов (памяти, вычислительных ресур!
сов) между процессами
Синхронизацию процессов
О Межпроцессное взаимодействие
Очевидно, что в общем случае число активных процессов превышает чис!
ло процессоров компьютера, но в каждый конкретный момент времени на
каждом процессоре может выполняться только один процесс. Операцион!
ная система управляет доступом процессов к вычислительным ресурсам,
создавая ощущение одновременного выполнения нескольких задач.
Специальная задача ядра, называемая распорядителем или планировщиком
процессов (scheduler), разрешает конфликты между процессами в конку!
ренции за системные ресурсы (процессор, память, устройства вво!
да/вывода). Планировщик запускает процесс на выполнение, следя за тем,
чтобы процесс монопольно не захватил разделяемые системные ресурсы.
Процесс освобождает процессор, ожидая длительной операции вво!
да/вывода, или по прошествии кванта времени. В этом случае планиров!
щик выбирает следующий процесс с наивысшим приоритетом и запускает
его на выполнение.
Модуль управления памятью обеспечивает размещение оперативной памяти
для прикладных задач. Оперативная память является дорогостоящим ре!
сурсом, и, как правило, ее редко бывает "слишком много". В случае, если
для всех процессов недостаточно памяти, ядро перемещает части процесса
или нескольких процессов во вторичную память (как правило, в специ!
альную область жесткого диска), освобождая ресурсы для выполняющегося
процесса. Все современные системы реализуют так называемую виртуаль!
ную память: процесс выполняется в собственном логическом адресном
пространстве, которое может значительно превышать доступную физиче!
скую память. Управление виртуальной памятью процесса также входит в
задачи модуля управления памятью.
Модуль межпроцессного взаимодействия отвечает за уведомление процессов
о событиях с помощью сигналов и обеспечивает возможность передачи
данных между различными процессами.
Подсистема ввода/вывода
Подсистема ввода/вывода выполняет запросы файловой подсистемы и
подсистемы управления процессами для доступа к периферийным устрой!
ствам (дискам, магнитным лентам, терминалам и т. д.). Она обеспечивает
необходимую буферизацию данных и взаимодействует с драйверами уст!
ройств — специальными модулями ядра, непосредственно обслуживаю!
щими внешние устройства.
www.books-shop.com
Работа в операционной
системе UNIX
Сегодня UNIX используется на самых разнообразных аппаратных платфор!
мах — от персональных рабочих станций до мощных серверов с тысячами
пользователей. И прежде всего потому, что UNIX — это многозадачная
многопользовательская система, обладающая широкими возможностями.
С точки зрения пользователя в операционной системе UNIX существуют два
типа объектов: файлы и процессы. Все данные хранятся в виде файлов, доступ
к периферийным устройствам осуществляется посредством чтения/записи в
специальные файлы. Когда вы запускаете программу, ядро загружает соот!
ветствующий исполняемый файл, создает образ процесса и передает ему
управление. Более того, во время выполнения процесс может считывать или
записывать данные в файл. С другой стороны, вся функциональность опе!
рационной системы определяется выполнением соответствующих процессов.
Работа системы печати или обеспечения удаленного доступа зависит от того,
выполняются ли те или иные процессы в
В этой главе мы познакомимся с пользовательской средой операционной
системы UNIX; попробуем взглянуть на UNIX глазами обычного пользо!
вателя и администратора системы; не вдаваясь во внутреннюю архитекту!
ру, обсудим, что такое файлы и файловая система, рассмотрим ее органи!
зацию и характеристики; с этих же позиций рассмотрим процесс в UNIX,
его роль, атрибуты и жизненный цикл.
Мы также постараемся ответить на вопрос, что представляет собой пользо!
ватель UNIX как с точки зрения самой системы, так и с точки зрения адми!
нистрирования; изучим сеанс работы в операционной системе и подробно
остановимся на командном интерпретаторе shell — базовой рабочей среде
пользователя; познакомимся с наиболее часто используемыми утилитами,
неразрывно связанными с UNIX. В заключение постараемся сформулиро!
вать основные задачи администрирования этой операционной системы.
Конечно, возможность печати документа или работы в Internet зависят также от наличия
принтера или сетевого правильности их настройки, работы соответствующих
пользовательских и системных приложений, умении пользоваться этими приложениями и
многого другого. В следующих главах мы затронем эти аспекты.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
20 Глава 1. Работа операционной системе UNIX
Файлы и файловая система
Файлы в UNIX играют ключевую роль, что не всегда справедливо для
других операционных систем. Трудно отрицать значение файлов для поль!
зователей, поскольку все их данные хранятся в виде файлов. Однако по!
мимо этого, файлы в UNIX определяют привилегии пользователей, по!
скольку права пользователя в большинстве случаев контролируются с по!
мощью прав доступа к файлам. Файлы обеспечивают доступ к периферий!
ным устройствам компьютера, включая диски, накопители на магнитной
ленте, CD!ROM, принтеры, терминалы, сетевые адаптеры и даже память.
Для приложений UNIX доступ в дисковому файлу "неотличим" от доступа,
скажем, к принтеру. Наконец, все программы, которые выполняются в
системе, включая прикладные задачи пользователей, системные процессы
и даже ядро UNIX, являются исполняемыми файлами.
Как и во многих современных операционных системах, в UNIX файлы
организованы в виде древовидной структуры (дерева), называемой файло!
вой системой system). Каждый файл имеет имя, определяющее его
расположение в дереве файловой системы. Корнем этого дерева является
корневой каталог (root directory), имеющий имя Имена всех остальных
файлов содержат путь — список каталогов (ветвей), которые необходимо
пройти, чтобы достичь файла. В UNIX все доступное пользователям фай!
ловое пространство объединено в единое дерево каталогов, корнем кото!
рого является каталог Таким образом, полное имя любого файла начи!
нается с и не содержит идентификатора устройства (дискового накопи!
теля, CD!ROM или удаленного компьютера в сети), на котором он факти!
чески хранится.
Однако это не означает, что в системе присутствует только одна файловая
система. В большинстве случаев единое дерево, такое каким его видит
пользователь системы, составлено из нескольких отдельных файловых сис!
тем, которые могут иметь различную внутреннюю структуру, а файлы,
принадлежащие этим файловым системам, могут быть расположены на
различных устройствах. Вопросы, связанные с объединением нескольких
файловых систем в единое дерево, будут обсуждаться при рассмотрении
внутреннего устройства файловой системы UNIX в главе 4.
Заметим, что имя файла является атрибутом файловой системы, а не набо!
ра некоторых данных на диске, который не имеет имени как такового.
Каждый файл имеет связанные с ним метаданные (хранящиеся в индексных
дескрипторах — inode), содержащие все характеристики файла и позво!
ляющие операционной системе выполнять операции, заказанные при!
кладной задачей: открыть файл, прочитать или записать данные, создать
или удалить файл. В частности, метаданные содержат указатели на диско!
вые блоки хранения данных файла. Имя файла в файловой системе явля!
ется указателем на его метаданные, в то время как метаданные не содер!
жат указателя на имя файла.
www.books-shop.com
Файлы и файловая система 21
Типы файлов
В UNIX существуют 6 типов файлов, различающихся по функциональному
назначению и действиям операционной системы при выполнении тех или
иных операций над файлами:
О Обычный файл (regular file)
Каталог (directory)
Специальный файл устройства (special device file)
FIFO или именованный канал (named pipe)
О Связь (link)
О Сокет
Обычный файл представляет собой наиболее общий тип файлов, содержа!
щий данные в некотором формате. Для операционной системы такие фай!
лы представляют собой просто последовательность байтов. Вся интерпре!
тация содержимого файла производится прикладной программой, обраба!
тывающей файл. К этим файлам относятся текстовые файлы, бинарные
данные, исполняемые программы и т. п.
Каталог. С помощью каталогов формируется логическое дерево файловой
системы. Каталог — это файл, содержащий имена находящихся в нем
файлов, а также указатели на дополнительную информацию — метадан!
ные, позволяющие операционной системе производить операции над эти!
ми файлами. Каталоги определяют положение файла в дереве файловой
системы, поскольку сам файл не содержит информации о своем местона!
хождении. Любая задача, имеющая право на чтение каталога, может про!
честь его содержимое, но только ядро имеет право на запись в каталог.
На рис. 1.1 в качестве примера приведена структура каталога. По существу
каталог представляет собой таблицу, каждая запись которой соответствует
некоторому файлу. Первое поле каждой записи содержит указатель на ме!
таданные (номер mode), а второе определяет имя файла.
Рис. 1.1. Структура каталога
www.books-shop.com
22 Глава 1. Работа в операционной системе UNIX
Специальный файл устройства обеспечивает доступ к физическому уст!
ройству. В UNIX различают символьные (character) и блочные (block) файлы
устройств. Доступ к устройствам осуществляется путем открытия, чтения и
записи в специальный файл устройства.
Символьные файлы устройств используются для небуферизированного об!
мена данными с устройством, в противоположность этому блочные файлы
позволяют производить обмен данными в виде пакетов фиксированной
длины — блоков. Доступ к некоторым устройствам может осуществляться
как через символьные, так и через блочные специальные файлы.
Как производится работа с периферийными устройствами, описано в главе 5.
FIFO или именованный канал — это файл, используемый для связи между
процессами. FIFO впервые появились в System V UNIX, но большинство
современных систем поддерживают этот механизм. Более подробно мы
рассмотрим этот тип файлов при обсуждении системы межпроцессного
взаимодействия в главе 3.
Связь. Как уже говорилось, каталог содержит имена файлов и указатели на
их метаданные. В то же время сами метаданные не содержат ни имени
файла, ни указателя на это имя. Такая архитектура позволяет одному фай!
лу иметь несколько имен в файловой системе. Имена жестко связаны с
метаданными и, соответственно, с данными файла, в то время как сам
файл существует независимо от того, как его называют в файловой систе!
Такая связь имени файла с его данными называется жесткой связью
(hard link). Например, с помощью команды мы можем создать еще
одно имя (second) файла, на который указывает имя first (рис. 1.2).
$ pwd
$ first
Жесткие связи абсолютно равноправны. В списках файлов каталогов, ко!
торые можно получить с помощью команды ls(l), файлы first и second бу!
дут отличаться только именем. Все остальные атрибуты файла будут абсо!
лютно одинаковыми. С точки зрения пользователя — это два разных фай!
ла. Изменения, внесенные в любой из этих файлов, затронут и другой, по!
скольку оба они ссылаются на одни и те же данные файла. Вы можете пе!
реместить один из файлов в другой каталог — все равно эти имена будут
связаны жесткой связью с данными файла. Легко проверить, что удаление
одного из файлов (first или second) не приведет к удалению самого файла,
т. е. его метаданных и данных (если это не специальный файл устройства).
Данное утверждение верно лишь отчасти. Действительно, файлу "безразлично", какие
имена он имеет в каталогах, но "небезразлично" число этих имен. Если ни одно из имен
файловой системы не ссылается на файл — он должен быть удален (т. е. физически уда!
лены его данные на диске).
www.books-shop.com
Файлы и файловая система 23
Рис. 1.2. Структура файловой системы после выполнения команды Жесткая
связь имен с данными файла
По определению жесткие связи указывают на один и тот же индексный
дескриптор Поэтому проверить, имеют ли два имени файла жесткую
связь, можно, вызвав команду ls(l) с ключом
www.books-shop.com
24 Глава J. Работа в операционной системе UNIX
$ i
12567 first
12567 second
Информацию о наличии у файла нескольких имен, связанных с ним жест!
кими связями, можно получить, просмотрев подробный листинг файлов с
помощью команды ! /:
$ — 1
2 andrei staff 7245 Jan 17 8:05 second
Во второй колонке листинга указано число жестких связей данного файла.
Сразу оговоримся, что жесткая связь является естественной формой связи
имени файла с его метаданными и не принадлежит к особому типу файла.
Особым типом файла является связь, позволяющая косвенно
адресовать файл. В отличие от жесткой связи, символическая связь адресу!
ет файл, который, в свою очередь, ссылается на другой файл. В результате,
последний файл адресуется символической связью косвенно (рис. 1.3).
Данные файла, являющегося символической связью, содержат только имя
целевого файла.
Проиллюстрируем эти рассуждения на примере. Команда с ключом !s
позволяет создать символическую связь:
$ pwd
$ з first
$ cd /home/sergey
$ 1
1 andrei staff 15 Jan 17 8:05
Как видно из вывода команды файл symfirst (символическая связь)
существенно отличается от файла second (жесткая связь). Во!первых, фак!
тическое содержимое файла symfirst отнюдь не то же, что и у файла first
или second, об этом говорит размер файла — 15 байт. На самом деле в
этом файле хранится не что иное как имя файла, на которую символиче!
ская связь ссылается — — ровно 15 байт. Во!вторых, файл
symfirst не содержит никаких ограничений на доступ символы в пер!
вой колонке).
Символическая связь является особым типом файла (об этом свидетельству!
ет символ в первой позиции вывода и операционная система рабо!
тает с таким файлом не так, как с обычным. Например, при выводе на эк!
ран содержимого файла symfirst появятся данные файла
www.books-shop.com
Файлы и система 25
Рис. 1.3. Символическая связь
предназначены для взаимодействия между процессами. Интерфейс
часто используется для доступа к сети TCP/IP. В системах, ветви
www.books-shop.com
26 Глава 1. Работа в операционной UNIX
BSD UNIX на базе реализована система межпроцессного взаимо!
действия, с помощью которой работают многие системные сервисы, на!
пример, система печати. Мы подробнее познакомимся с сокетами в разде!
ле "Межпроцессное взаимодействие в BSD UNIX" главы 3.
Структура файловой системы UNIX
Использование общепринятых имен основных файлов и структуры ката!
логов существенно облегчает работу в операционной системе, ее админи!
стрирование и переносимость. Эта структура используется в работе систе!
мы, например при ее инициализации и конфигурировании, при работе
почтовой системы и системы печати. Нарушение этой структуры может
привести к неработоспособности системы или отдельных ее компонентов.
Рис. 1.4. Типичная файловая система UNIX
Приведем краткое описание основных каталогов.
Корневой каталог
Корневой каталог является основой любой файловой системы UNIX.
Все остальные файлы и каталоги располагаются в рамках структуры, по!
www.books-shop.com
Файлы и файловая 27
рожденной корневым каталогом, независимо от их физического местона!
хождения.
В каталоге находятся наиболее часто употребляемые команды и ути!
литы системы, как правило, общего пользования.
Каталог /dev содержит специальные файлы устройств, являющиеся интер!
фейсом доступа к периферийным устройствам.
Каталог /dev может содержать несколько подкаталогов, группирующих
специальные файлы устройств одного типа. Например, каталог /dev/dsk
содержит специальные файлы устройств для доступа к гибким и жестким
дискам системы.
/etc
В этом каталоге находятся системные конфигурационные файлы и многие
утилиты администрирования. Среди наиболее важных файлов — скрипты
инициализации системы. Эти скрипты хранятся в каталогах
/etc/rc2.d и т. д, соответствующих уровням выполнения системы
(run level), и управляются скриптами /etc/rc2 и т. д. Во
многих версиях BSD UNIX указанные каталоги отсутствуют, и загрузка сис!
темы управляется скриптами /etc/re и В UNIX
ветви System V здесь находится подкаталог default, где хранятся параметры
по умолчанию многих команд (например, содержит парамет!
ры для команды В UNIX System V большинство исполняемых фай!
лов перемещены в каталог или
/lib
В каталоге находятся библиотечные файлы языка С и других языков
программирования. Стандартные названия библиотечных файлов имеют
вид libx.a (или libx.so), где х — это один или более символов, определяю!
щих содержимое библиотеки. Например, стандартная библиотека С назы!
вается библиотека системы X Window System имеет имя libXll.a.
Часть библиотечных файлов также находится в каталоге
Каталог "потерянных" файлов. Ошибки целостности файловой системы,
возникающие при неправильном останове UNIX или аппаратных сбоях,
могут привести к появлению т. н. "безымянных" файлов — структура и со!
держимое файла являются правильными, однако для него отсутствует имя
в каком!либо из каталогов. Программы проверки и восстановления фай!
ловой системы помещают такие файлы в каталог под систем!
www.books-shop.com
28 Глава 1. Работа в операционной системе UNIX
числовыми именами. Мы коснемся вопроса имен файлов далее в
этой главе и, более подробно, в главе 4.
/mnt
Стандартный каталог для временного связывания (монтирования) физиче!
ских файловых систем к корневой для получения единого дерева логиче!
ской файловой системы. Обычно содержимое каталога /mnt пусто, по!
скольку при монтировании он перекрывается связанной файловой систе!
мой. Более подробно процесс монтирования и относящиеся к нему струк!
туры данных ядра мы рассмотрим в главе 4.
/и или /home
Общеупотребительный каталог для размещения домашних каталогов пользо!
вателей. Например, имя домашнего каталога пользователя andrei будет, ско!
рее всего, называться или /u/andrei. В более ранних версиях
UNIX домашние каталоги пользователей размещались в каталоге /usr.
В этом каталоге находятся подкаталоги различных сервисных подсистем —
системы печати, электронной почты и т. д. исполняемые фай!
лы утилит UNIX дополнительные программы, используемые на
данном компьютере файлы заголовков элек!
тронные справочники т. д.
/var
В UNIX System V этот каталог является заменителем каталога /usr/spool,
используемого для хранения временных файлов различных сервисных под!
систем — системы печати, электронной почты и т. д.
/tmp
Каталог хранения временных файлов, необходимых для работы различных
подсистем UNIX. Обычно этот каталог открыт на запись для всех пользо!
вателей системы.
Владельцы файлов
Файлы в UNIX имеют двух владельцев: пользователя (user owner) и груп!
(group owner). Важной особенностью является то, что владелец!
пользователь может не являться членом группы, владеющей файлом. Это
Группой называется определенный список пользователей системы. Пользователь системы
может быть членом нескольких одна из которых является первичной (primary), ос!
тальные — дополнительными (supplementary).
www.books-shop.com
Файлы и файловая система
дает большую гибкость в организации доступа к файлам. Совместное
пользование файлами можно организовать практически для любого соста!
ва пользователей, создав соответствующую группу и установив для нее
права на требуемые файлы. При этом для того чтобы некий пользователь
получил доступ к этим файлам, достаточно включить его в группу!
владельца, и наоборот — исключение из группы автоматически изменяет
для пользователя права доступа к файлам.
Для определения владельцев файла достаточно посмотреть подробный
листинг команды Третья и четвертая колонки содержат имена вла!
дельца!пользователя и владельца!группы, соответственно:
1 2 3 4 5 6 7 8
1 group 235520 Dec 22
1 andy student 3450 Nov 12 quest
Владельцем!пользователем вновь созданного файла является пользователь,
который создал файл. Порядок назначения владельца!группы зависит от
конкретной версии UNIX. Например, в SCO UNIX владельцем!группой
является первичная группа пользователя, создавшего файл, а в Digital
UNIX владелец!группа наследуется от владельца группы — каталога, в ко!
тором создается
Для изменения владельца файла используется команда В качестве
параметров команда принимает имя владельца!пользователя и список фай!
лов, для которых требуется изменить данный атрибут. Например, следующая
команда установит пользователя sergey владельцем файлов и
$ sergey
Изменение владельца!группы производится командой Как и
в качестве параметров команда принимает имя владельца!группы
и список файлов, для которых требуется изменить данный атрибут. На!
пример, для установки группы staff в качестве владельца всех файлов те!
кущего каталога, необходимо задать следующую команду:
$ staff *
На самом деле файл создает не пользователь, а процесс, запущенный пользователем. Про!
цесс имеет атрибуты, связанные с пользователем и группой, которые и назначаются файлу
при его создании. Более точное описание передачи "владения" имеет вид:
1. Идентификатор владельца!пользователя файла устанавливается равным
процесса, создающего файл (т. е. вызвавшего функцию
1. Идентификатор владельца!группы файла (group ID) устанавливается равным
EGID процесса (для версии System V);
б) GID каталога, в котором файл создается (для версии BSD).
Большинство систем, использующих наследование System V, позволяют также устанавли!
вать наследование группового владельца в стиле BSD. Это достигается установкой флага
SGID на каталог. Более подробно об этом см. раздел "Дополнительные атрибуты" далее в
этой главе.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
30 Глава 1. в операционной системе UNIX
Владение файлом определяет тот набор операций, который пользователь
может совершить с файлом. Часть из них, такие как изменение прав дос!
тупа или владельца файла (табл. 1.1), может осуществлять только владелец
(или суперпользователь), другие операции, такие как чтение, запись и за!
пуск на выполнение (для исполняемых файлов) дополнительно контроли!
руются правами доступа.
Таблица 1.1. Операции изменения владельцев файла
Операция
Изменение владель%
ца%пользователя
Изменение владель%
ца%группы
Команда
chgrp(1)
Имеет право выполнять
в BSD 4.x
суперпользователь
суперпользователь
в системе SVR4
владелец файла
владелец файла только
для группы, к которой
сам принадлежит (в со%
ответствии с POSIX)
Права доступа к файлу
В операционной системе UNIX существуют три базовых класса доступа к
файлу, в каждом из которых установлены соответствующие права доступа:
User access (u) Для владельца%пользователя файла
Group access (g) Для членов группы, являющейся владельцем файла
Other access (о) Для остальных пользователей (кроме суперпользователя)
UNIX поддерживает три типа прав доступа для каждого класса: на чтение
(read, обозначается символом на запись (write, обозначается символом w)
и на выполнение (execute, обозначается символом х).
С помощью команды можно получить список прав доступа к файлу:
rwxrxr
1
2
1
1
andy
andy
andy
andy
group
group
group
group
36482
64
4889
7622
Dec
Aug
Dec
22
15
22
11
19:13
11:03
15: 13
09: 13
temp
a . out
Права доступа листинга отображаются в первой колонке (за исключением
первого символа, обозначающего тип файла). Наличие права доступа обо!
значается соответствующим символом, а отсутствие — символом '!'. Рас!
смотрим, например, права доступа к файлу
www.books-shop.com
Файлы и файловая система 31
Тип файла Права владельца[ Права владельца[ Права осталь[
пользователя группы пользова[
телей
Обычный файл Чтение, запись, Чтение и выполнение Только чтение
нение
Права доступа могут быть изменены только владельцем файла или супер!
пользователем (superuser) — администратором системы. Для этого исполь!
зуется команда Ниже приведен общий формат этой команды.
В качестве аргументов команда принимает указание классов доступа —
владелец!пользователь, 'g' — владелец!группа, — остальные пользовате!
ли, все классы пользователей), права доступа — чтение, V — за!
пись и Y — выполнение) и операцию, которую необходимо произвести
('+' — добавить, '!' — удалить и '=' — присвоить) для списка файлов
и т. д. Например, команда
$ chmod
лишит членов группы!владельца файла ownfile права на запись и выполне!
ние этого файла.
В одной команде можно задавать различные права для нескольких классов
доступа, разделив их запятыми.
Приведем еще несколько примеров:
$ chmod a+w text Предоставить право на запись для всех
пользователей
$ chmod go=r text Установить право на чтение для всех пользо%
вателей, за исключением владельца
$ chmod Добавить для группы право на выполнение
файла runme и снять право на запись
$ chmod text2 Добавить право записи для владельца, право
на чтение для группы и остальных пользова%
телей, отключить право на запись для всех
пользователей, исключая владельца
www.books-shop.com
32 Глава 1. Работа в системе UNIX
Последний пример демонстрирует достаточно сложную установку прав
доступа. Вы можете установить сразу все девять прав доступа, используя
числовую форму команды
$ 754 *
Число определяется следующим образом: нужно представить права доступа
в двоичном виде (0 — отсутствие соответствующего права, 1 — его нали!
чие) и каждую триаду, соответствующую классу доступа, в свою очередь
преобразовать в десятичное число.
Владелец
W X
7
Группа
— х
5
Остальные
— 
4
Таким образом, приведенный пример эквивалентен следующей символь!
ной форме
$ chmod o=r *
Значение прав доступа различно для разных типов файлов. Для файлов опе!
рации, которые можно производить, следуют из самих названий прав досту!
па. Например, чтобы просмотреть содержимое файла командой cat(l), поль!
зователь должен иметь право на чтение Редактирование файла, т. е. его
изменение, предусматривает наличие права на запись (w). Наконец, для того
чтобы запустить некоторую программу на выполнение, вы должны иметь
соответствующее право (х). Исполняемый файл может быть как скомпили!
рованной программой, так и скриптом командного интерпретатора shell.
В последнем случае вам также понадобится право на чтение, поскольку при
выполнении скрипта командный интерпретатор должен иметь возможность
считывать команды из файла. Все сказанное, за исключением, пожалуй,
права на выполнение, имеющего смысл лишь для обычных файлов и ката!
логов, справедливо и для других типов файлов: специальных файлов уст!
ройств, именованных каналов, и сокетов. Например, чтобы иметь возмож!
ность распечатать документ, вы должны иметь право на запись в специаль!
ный файл устройства, связанный с Для каталогов эти права
имеют другой смысл, а для символических связей они вообще не использу!
ются, поскольку контролируются целевым файлом.
Права доступа для каталогов не столь очевидны. Это в первую очередь
связано с тем, что система трактует операции чтения и записи для ката!
логов отлично от остальных файлов. Право чтения каталога позволяет вам
На самом деле специальный файл, связанный с устройством не имеет общедос!
тупных прав на запись. Доступ к принтеру контролируется системой печати, из которой и
происходит доступ к этому файлу.
www.books-shop.com
Файлы и файловая система
получить имена (и только имена) файлов, находящихся в данном каталоге.
Чтобы получить дополнительную информацию о файлах каталога
(например, подробный листинг команды системе придется "загля!
нуть" в метаданные файлов, что требует права на выполнения для катало!
га. Право на выполнения также потребуется для каталога, в который вы
захотите перейти (т. е. сделать его текущим) с помощью команды cd (]).
Это же право нужно иметь для доступа ко всем каталогам на пути к ука!
занному. Например, если вы установите право на выполнения для всех
пользователей в одном из своих подкаталогов, он все равно останется не!
доступным, пока ваш домашний каталог не будет иметь такого же права.
Права и х действуют независимо, право х для каталога не требует нали!
чия права и наоборот. Комбинацией этих двух прав можно добиться ин!
тересных эффектов, например, создания "темных" каталогов, файлы кото!
рых доступны только в случае, если пользователь заранее знает их имена,
поскольку получение списка файлов таких каталогов запрещено. Данный
прием, кстати, используется при создании общедоступных архивов в сети
когда некоторые разделы архива могут использоваться
только "посвященными", знающими о наличии того или иного файла в
каталоге. Приведем пример создания "темного" каталога.
$ Где мы находимся?
$ darkroom Создадим каталог
$ ! 1 Получим его атрибуты
2 group 65 Dec 22 19:13 darkroom
$ a!r+x darkroom Превратим его в "темный" каталог
$ — 1 Получим его атрибуты
2 andy group 65 Dec 22 19:13 darkroom
$ cp f darkroom Поместим в каталог darkroom некоторый файл
$ cd darkroom Перейдем в этот каталог
$ darkroom Попытаемся получить листинг каталога
denied Увы...
$ cat Тем не менее, заранее зная имя файла можно
ok работать с ним (например, прочитать, если есть соответ%
ствующее право доступа)
Особого внимания требует право на запись для каталога. Создание и удале!
ние файлов в каталоге требуют изменения его содержимого, и, следователь!
но, права на запись в этот каталог. Самое важное, что при этом не учиты!
ваются права доступа для самого файла. То есть для того, чтобы удалить не!
который файл из каталога, не обязательно иметь какие!либо права доступа к
этому файлу, важно лишь иметь право на запись для каталога, в котором
находится этот файл. Имейте в виду, что право на запись в каталог дает
www.books-shop.com
34 Глава Работа в операционной системе UNIX
большие полномочия, и предоставляйте это право с осторожностью. Правда,
существует способ несколько обезопасить себя в случае, когда необходимо
предоставить право на запись другим пользователям, — установка флага
Sticky bit на каталог. Но об этом мы поговорим чуть позже.
В табл. 1.2 приведены примеры некоторых действий над файлами и мини!
мальные права доступа, необходимые для выполнения этих операций.
Таблица Примеры прав
Команда
cd
%s
cat
cat
runme
Смысл действия
Перейти в каталог
/u/andrei
Вывести все файлы
с суффиксом это%
го каталога
Вывести дополни%
тельную информа%
цию об этих файлах
(размер)
Вывести на экран
содержимое файла
report.txt
Добавить данные в
файл report.txt
Выполнить про%
грамму runme
Выполнить скрипт
командного интер%
претатора
Удалить файл runme
в текущем каталоге
права
доступа
для обычно%
го файла
W
X
—
для каталога,
го файл
X
X
X
X
X
XW
Итак, для выполнения операции над файлом имеют значение класс досту!
па, к которому вы принадлежите, и права доступа, установленные для
этого класса. Поскольку для каждого класса устанавливаются отдельные
права доступа, всего определено 9 прав доступа, по 3 на каждый класс.
Операционная система производит проверку прав доступа при создании,
открытии (для чтения или записи), запуске на выполнение или удалении
файла. При этом выполняются следующие проверки:
1. Если операция запрашивается суперпользователем, доступ разрешает!
ся. Никакие дополнительные проверки не производятся. Это позволя!
www.books-shop.com
Файлы и файловая система
ет администратору иметь неограниченный доступ ко всей файловой
системе.
2. Если операция запрашивается владельцем файла, то:
а) если требуемое право доступа определено (например, при опера!
ции чтения файла установлено право на чтение для владельца!
пользователя данного файла), доступ разрешается,
б) в противном случае доступ запрещается.
Если операция запрашивается пользователем, являющимся членом
группы, которая является владельцем файла, то:
а) если требуемое право доступа определено, доступ разрешается,
б) в противном случае доступ запрещается.
4. Если требуемое право доступа для прочих пользователей (other) уста!
новлено, доступ разрешается, в противном случае доступ запрещается.
Система проводит проверки в указанной последовательности. Например,
если пользователь является владельцем файла, то доступ определяется ис!
ключительно из прав владельца!пользователя, права владельца!группы не
проверяются, даже если пользователь является членом владельца!группы.
Чтобы проиллюстрировать это, рассмотрим следующее:
2 group 65 Dec 22 19:13
Даже если пользователь andy является членом группы group, он не сможет
ни прочитать, ни изменить содержимое файла filel. В то же время все ос!
тальные члены этой группы имеют такую возможность. В данном случае,
владелец файла обладает наименьшими правами доступа к нему. Разумеет!
ся, рассмотренная ситуация носит гипотетический характер, поскольку
пользователь andy в любой момент может изменить права доступа к дан!
ному файлу как для себя (владельца), так и для группы, и всех остальных
пользователей в системе.
Дополнительные атрибуты файла
Мы рассмотрели основные атрибуты, управляющие доступом к файлу.
Существует еще несколько атрибутов, изменяющих выполне!
ние различных операций. Как и в случае прав доступа, эти атрибуты по!
разному интерпретируются для каталогов и других типов файлов.
Дополнительные атрибуты также устанавливаются утилитой chmod(l), но
вместо кодов или Y используются коды из табл. 1.3. Например, для
установки атрибута SGID для файла filel необходимо выполнить команду
$ chmod g+s filel.
В табл. 1.3 приведены дополнительные атрибуты для файлов, и показано,
как они интерпретируются операционной системой.
www.books-shop.com
36 Глава Работа в операционной системе UNIX
Таблица 1.3. Дополнительные атрибуты для обычных файлов
Код
t
S
S
1
Название
Sticky bit
Set
Блокирование
Значение
Сохранить образ выполняемого файла в памяти после
завершения выполнения
Установить UID процесса при выполнении
Установить процесса при выполнении
Установить обязательное блокирование файла
Установка атрибута Sticky bit название — save text mode)
редко используется в современных версиях UNIX для файлов. В ранних
версиях этот атрибут применялся с целью уменьшить время загрузки наи!
более часто запускаемых программ (например, редактора или командного
После завершения выполнения задачи ее образ (т. е. код
и данные) оставались в памяти, поэтому последующие запуски этой про!
граммы занимали значительно меньше времени.
Атрибуты (или флаги) SUID и SGID позволяют изменить права пользова!
теля при запуске на выполнение файла, имеющего эти атрибуты. При
этом привилегии будут изменены (обычно расширены) лишь на время вы!
полнения и только в отношении этой
Обычно запускаемая программа получает права доступа к системным ре!
сурсам на основе прав доступа пользователя, запустившего программу. Ус!
тановка флагов SUID и SGID изменяет это правило, назначая права дос!
тупа исходя из прав доступа владельца файла. Таким образом, запущенный
исполняемый файл, которым владеет суперпользователь, получает неогра!
ниченные права доступа к системным ресурсам, независимо от того, кто
его запустил. При этом установка SUID приведет к наследованию прав
файла, а установка SGID — владельца!группы.
В качестве примера использования этого свойства рассмотрим утилиту
позволяющую пользователю изменить свой пароль. Очевидно,
что изменение пароля должно привести к изменению содержимого опре!
деленных системных файлов (файла пароля /etc/passwd или /etc/shadow,
или базы данных пользователей, если используется дополнительная защи!
та системы). Понятно, что предоставление права на запись в эти файлы
всем пользователям системы является отнюдь не лучшим решением. Уста!
новка SUID для программы (точнее, на файл —
исполняемый файл утилиты позволяет изящно разрешить это
противоречие. Поскольку владельцем файла является су!
Следует оговориться, что если программа в процессе выполнения запускает другие задачи,
то они будут наследовать ее права доступа. Поэтому устанавливать флаги SUID и SGID
следует с большой осторожностью и только для программ, которые не имеют возможно!
сти запуска произвольных задач.
www.books-shop.com
Файлы и файловая система
перпользователь (его имя в системе — root), то кто бы ни запустил утилиту
на выполнение, во время работы данной программы он временно
получает права суперпользователя, т. е. может производить запись в сис!
темные файлы, защищенные от остальных пользователей.
$
!r!sr!sr!x 3 root sys 15688 Oct 25 1995 /usr/bin/passwd*
Понятно, что требования по безопасности для такой программы должны
быть повышены. Утилита должна производить изменение пароля
только пользователя, запустившего ее, и не позволять никакие другие опе!
рации (например, вызов других программ).
Блокирование файлов позволяет устранить возможность конфликта, когда
две или более задачи одновременно работают с одним и тем же файлом. К
этому вопросу мы вернемся в главе 4.
Однако вернемся к обсуждению дополнительных атрибутов для каталогов
(табл.
Таблица 1.4. Дополнительные атрибуты для каталогов
Код
t Sticky bit Позволяет пользователю удалять только файлы, кото%
рыми он владеет или имеет права на запись
s Set SGID Позволяет изменить правило установки владельца%
группы создаваемых файлов, аналогично реализован%
ному в BSD UNIX
При обсуждении прав доступа отмечалось, что предоставление права на
запись в каталог дает достаточно большие полномочия. Имея такое право,
пользователь может удалить из каталога любой файл, даже тот, владельцем
которого он не является и в отношении которого не имеет никаких прав.
Установка атрибута Sticky bit для каталога позволяет установить дополни!
тельную защиту файлов, находящихся в каталоге. Из такого каталога поль!
зователь может удалить только файлы, которыми он владеет, или на кото!
рые он имеет явное право доступа на запись, даже при наличии права на
запись в каталог. Примером может служить каталог /tmp, который являет!
ся открытым на запись для всех пользователей, но в котором может ока!
заться нежелательной возможность удаления пользователем чужих времен!
ных файлов.
Атрибут SGID также имеет иное значение для каталогов. При установке
этого атрибута для каталога вновь созданные файлы этого каталога будут
наследовать владельца!группу по каталога. Таким обра!
зом для UNIX версии System V удается имитировать поведение систем
версии BSD, для которых такое правило наследования действует по умол!
чанию.
www.books-shop.com
38 Глава 1. Работа в операционной системе UNIX
Посмотреть наличие дополнительных атрибутов можно с помощью под!
робного списка файлов:
$ !1
!r!sr!sr!x
Операция
5 sys sys 367 Dec 19 20:29
3 root sys 15688 Oct 25 1995
Таблица Операции изменения атрибутов файла
Команда/системный Кому разрешено
вызов
Изменение прав доступа chmod(1) владелец
Изменение дополнитель% chmod(1)
ного атрибута Sticky bit
ьзовател ь
Изменение дополнитель%
ного атрибута
владелец, причем его так%
же должен совпадать с иден%
тификатором группы файла
Процессы
Процессы в операционной системе UNIX играют ключевую роль. От оп!
тимальной настройки подсистемы управления процессами и числа одно!
временно выполняющихся процессов зависит загрузка ресурсов процессо!
ра, что в свою очередь имеет непосредственное влияние на производи!
тельность системы в целом. Ядро операционной системы предоставляет
задачам базовый набор услуг, определяемый интерфейсом системных вы!
зовов. К ним относятся основные операции по работе с файлами, управ!
ление процессами и памятью, поддержка межпроцессного взаимодействия.
Дополнительные функциональные возможности системы, т. е. услуги, ко!
торые она предоставляет пользователям, определяются активными процес!
сами. От того, какие процессы выполняются в вашей системе, зависит,
является ли она сервером базы данных или сервером сетевого доступа,
средством проектирования или вычислительным сервером. Даже так назы!
ваемые уровни выполнения системы (run levels), которые мы рассмотрим
позже, представляют собой удобный способ определения группы выпол!
няющихся процессов и, соответственно, функциональности системы.
Программы и процессы
Обычно программой называют совокупность файлов, будь то набор исход!
ных текстов, объектных файлов или собственно выполняемый файл. Для
того чтобы программа могла быть запущена на выполнение, операционная
www.books-shop.com
Процессы
система сначала должна создать окружение или среду выполнения задачи,
куда относятся ресурсы памяти, возможность доступа к устройствам вво!
да/вывода и различным системным ресурсам, включая услуги ядра.
Это окружение (среда выполнения задачи) получило название процесса.
Мы можем представить процесс как совокупность данных ядра системы,
необходимых для описания образа программы в памяти и управления ее
выполнением. Мы можем также представить процесс как программу в ста!
дии ее выполнения, поскольку все выполняющиеся программы представ!
лены в UNIX в виде процессов. Процесс состоит из инструкций, выпол!
няемых процессором, данных и информации о выполняемой задаче, такой
как размещенная память, открытые файлы и статус процесса.
В то же время не следует отождествлять процесс с программой хотя бы
потому, что программа может породить более одного процесса. Простей!
шие программы, например, команда или cat(l), при выполнении
представлены только одним процессом. Сложные задачи, например сис!
темные серверы (печати, FTP, Telnet), порождают в системе несколько
одновременно выполняющихся процессов.
Операционная система UNIX является многозадачной. Это значит, что
одновременно может выполняться несколько процессов, причем часть
процессов могут являться образцами одной программы.
Выполнение процесса заключается в точном следовании набору инструк!
ций, который никогда не передает управление набору инструкций другого
процесса. Процесс считывает и записывает информацию в раздел данных
и в стек, но ему недоступны данные и стеки других процессов.
В то же время процессы имеют возможность обмениваться друг с другом
данными с помощью предоставляемой UNIX системой межпроцессного
взаимодействия. В UNIX существует набор средств взаимодействия между
процессами, таких как сигналы (signals), каналы (pipes), разделяемая па!
мять (shared memory), семафоры (semaphores), сообщения (messages) и
файлы, но в остальном процессы изолированы друг от друга.
Типы процессов
Системные процессы
Системные процессы являются частью ядра и всегда расположены в опе!
ративной памяти. Системные процессы не имеют соответствующих им
программ в виде исполняемых файлов и запускаются особым образом при
инициализации ядра системы. Выполняемые инструкции и данные этих
процессов находятся в ядре системы, таким образом они могут вызывать
функции и обращаться к данным, недоступным для остальных процессов.
Системными процессами являются: shed (диспетчер свопинга), vhand (дис!
петчер страничного замещения), (диспетчер буферного кэша) и
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
40 Глава 1. Работа в операционной UNIX
kmadaemon (диспетчер памяти ядра). К системным процессам следует от!
нести ink, являющийся прародителем всех остальных процессов в UNIX.
Хотя init не является частью ядра, и его запуск происходит из исполняе!
мого файла (/etc/init), его работа жизненно важна для функционирования
всей системы в целом.
Демоны
Демоны — это неинтерактивные процессы, которые запускаются обычным
образом — путем загрузки в память соответствующих им программ
(исполняемых файлов), и выполняются в фоновом режиме. Обычно демо!
ны запускаются при инициализации системы (но после инициализации
ядра, подробнее см. главу 3) и обеспечивают работу различных подсистем
UNIX: системы терминального доступа, системы печати, системы сетевого
доступа и сетевых услуг и т. п. Демоны не связаны ни с одним пользова!
тельским сеансом работы и не могут непосредственно управляться пользо!
вателем. Большую часть времени демоны ожидают пока тот или иной
процесс запросит определенную услугу, например, доступ к файловому
архиву или печать документа.
Прикладные процессы
К прикладным процессам относятся все остальные процессы, выполняю!
щиеся в системе. Как правило, это процессы, порожденные в рамках поль!
зовательского сеанса работы. С такими процессами вы будете сталкиваться
чаще всего. Например, запуск команды ls(l) породит соответствующий про!
цесс этого типа. Важнейшим пользовательским процессом является основ!
ной командный интерпретатор (login shell), который обеспечивает вашу ра!
боту в UNIX. Он запускается сразу же после вашей регистрации в системе, а
завершение работы login shell приводит к отключению от системы.
Пользовательские процессы могут выполняться как в интерактивном, так
и в фоновом режиме, но в любом случае время их жизни (и выполнения)
ограничено сеансом работы пользователя. При выходе из системы все
пользовательские процессы будут уничтожены.
Интерактивные процессы монопольно владеют терминалом, и пока такой
процесс не завершит свое выполнение, пользователь не сможет работать с
другими
Вы сможете работать с другими приложениями, если в функции интерактивного процесса
входит запуск на выполнение других программ. Примером такой задачи является команд!
ный интерпретатор shell, который считывает пользовательский ввод и запускает соответст!
вующие задачи. Более типичным в данном контексте является процесс, порожденный ко!
мандой Пока ps(l) не завершит работу, вы не сможете вводить команды shell.
www.books-shop.com
Процессы
Атрибуты процесса
Процесс в UNIX имеет несколько атрибутов, позволяющих операционной
системе эффективно управлять его работой, важнейшие из которых рас!
смотрены ниже.
Идентификатор процесса Process ID
Каждый процесс имеет уникальный идентификатор PID, позволяющий
ядру системы различать процессы. Когда создается новый процесс, ядро
присваивает ему следующий свободный (т. е. не ассоциированный ни с
каким процессом) идентификатор. Присвоение идентификаторов происхо!
дит по возрастающий, т. е. идентификатор нового процесса больше, чем
идентификатор процесса, созданного перед ним. Если идентификатор дос!
тиг максимального значения, следующий процесс получит минимальный
свободный PID и цикл повторяется. Когда процесс завершает свою работу,
ядро освобождает занятый им идентификатор.
Идентификатор родительского процесса Parent Process ID
Идентификатор процесса, породившего данный процесс.
Приоритет процесса (Nice Number)
Относительный приоритет процесса, учитываемый планировщиком при
определении очередности запуска. Фактическое же распределение процес!
сорных ресурсов определяется приоритетом выполнения, зависящим от не!
скольких факторов, в частности от заданного относительного приоритета.
Относительный приоритет не изменяется системой на всем протяжении
жизни процесса (хотя может быть изменен пользователем или админист!
ратором) в отличие от приоритета выполнения, динамически обновляе!
мого ядром.
Терминальная линия (TTY)
Терминал или псевдотерминал, ассоциированный с процессом, если такой
существует. Процессы!демоны не имеют ассоциированного терминала.
Реальный (RID) и эффективный (EUID) идентификаторы пользователя
Реальным идентификатором пользователя данного процесса является
идентификатор пользователя, запустившего процесс. Эффективный иден!
тификатор служит для определения прав доступа процесса к системным
ресурсам (в первую очередь к ресурсам файловой системы). Обычно ре!
альный и эффективный идентификаторы эквивалентны, т. е. процесс име!
ет в системе те же права, что и пользователь, запустивший его. Однако
существует возможность задать процессу более широкие права, чем права
www.books-shop.com
42 Глава 1. в операционной UNIX
пользователя путем установки флага SUID, когда эффективному иденти!
фикатору присваивается значение идентификатора владельца исполняе!
мого файла (например, администратора).
Реальный (RGID) и эффективный (EGID) идентификаторы группы
Реальный идентификатор группы равен идентификатору первичной или
текущей группы пользователя, запустившего процесс. Эффективный иден!
тификатор служит для определения прав доступа к системным ресурсам по
классу доступа группы. Так же как и для эффективного идентификатора
пользователя, возможна его установка равным идентификатору группы
владельца исполняемого файла (флаг SGID).
Команда ps(l) (process status) позволяет вывести список процессов, выпол!
няющихся в системе, и их атрибуты:

pageout
bd
emiclock
Более подробное описание полей вывода команды приведено далее в
разделе "Основные утилиты UNIX".
$ PS
root
root
root
root
root
fed
fed
fed
ef |
0
1
2
3
627
314
3521
head 20
0
0
0
01
311
304
512
С
0
0
0
0
0
0
0
0
Dec
Dec
Dec
Dec
Dec
Dec
Dec
17
17
17
17
17
17
17
TTY
9
9
7
9
9
pts/3
pts/4
TIME
0:
0:
7;
0:
0:
0:
:00
:01
:01
:27
:01
Жизненный путь процесса
Процесс в UNIX создается системным вызовом Процесс, сделав!
ший вызов fork(2) называется родительским, а вновь созданный процесс —
дочерним. Новый процесс является точной копией породившего его про!
цесса. Как это ни удивительно, но новый процесс имеет те же инструкции
и данные, что и его родитель. Более того, выполнение родительского и
дочернего процесса начнется с одной и той же инструкции, следующей за
fork(2). Единственно, чем они различаются — это идентификато!
ром процесса PID. Каждый процесс имеет одного родителя, но может
иметь несколько дочерних процессов.
Для запуска задачи, т. е. для загрузки новой программы, процесс должен
выполнить системный вызов ехес(2). При этом новый процесс не порож!
дается, а исполняемый код процесса полностью замещается кодом запус!
каемой программы. Тем не менее окружение новой программы во многом
сохраняется, в частности сохраняются значения переменных окружения,
назначения стандартных потоков ввода/вывода, вывода сообщений об
ошибках, а также приоритет процесса.
www.books-shop.com
Процессы 43
В UNIX запуск на выполнение новой программы часто связан с порожде!
нием нового процесса, таким образом сначала процесс выполняет вызов
fork(2), порождая дочерний процесс, который затем выполняет
полностью замещаясь новой программой.
Рассмотрим эту схему на примере.
Допустим, пользователь, работая в командном режиме (в командном ин!
терпретаторе shell) запускает команду Текущий процесс (shell) делает
вызов fork(2), порождая вторую копию shell. В свою очередь, порожденный
shell вызывает ехес(2), указывая в качестве параметра имя исполняемого
файла, образ которого необходимо загрузить в память вместо кода shell.
Код ls(l) замещает код порожденного shell, и утилита ls(l) начинает вы!
полняться. По завершении работы ls(l) созданный процесс "умирает".
Пользователь вновь возвращается в командный режим. Описанный про!
цесс представлен на рис. 1.5. Мы также проиллюстрируем работу команд!
ного интерпретатора в примере, приведенном в главе 2.
Рис. 1.5. Создание
процесса и запуск про%
граммы
Если сделать "отпечаток" выполняемых процессов, например командой
ps(l), между указанными стадиями, результат был бы следующим:
Пользователь работает в командном режиме:
UID PID
745
PPID
1
С
10
STIME
10:11:34
TTY TIME
0:01
CMD
www.books-shop.com
44 Глава 1. Работа в операционной системе UNIX
Пользователь запустил команду ls(l), и shell произвел вызов
UID PID PPID С TTY TIME
745 1 10 10:11:34 0:01 sh
802 745 14 11:00:00 0:00 sh
Порожденный shell произвел вызов
UID PID PPID С STIME TTY TIME CMD
userl 745 1 10 10:11:34 0:01 sh
userl 802 745 12 11:00:00 0:00
Процесс ls(l) завершил работу:
UID PID PPID С STIME TTY TIME CMD
userl 745 1 10 10:11:34 0:01 sh
Описанная процедура запуска новой программы называется fork!and!exec.
Однако бывают ситуации, когда достаточно одного вызова fork(2) без по!
следующего ехес(2). В этом случае исполняемый код родительского про!
цесса должен содержать логическое ветвление для родительского и дочер!
него
Все процессы в UNIX создаются посредством вызова fork(2). Запуск на
выполнение новых задач осуществляется либо по схеме fork!and!exec, либо
с помощью ехес(2). "Прародителем" всех процессов является процесс
называемый также распределителем процессов. Если построить
граф "родственных отношений" между процессами, то получится дерево,
корнем которого является Показанные на рис. 1.6 процессы sched
и являются системными и формально не входят в иерархию (они
будут рассматриваться в следующих главах).
Сигналы
Сигналы являются способом передачи от одного процесса другому или от
ядра операционной системы какому!либо процессу уведомления о возник!
новении определенного события. Сигналы можно рассматривать как про!
стейшую форму межпроцессного взаимодействия. В то же время сигналы
больше напоминают программные прерывания, — средство, с помощью
которого нормальное выполнение процесса может быть прервано. Напри!
мер, если процесс производит деление на 0, ядро посылает ему сигнал
SIGFPE, а при нажатии клавиш прерывания, обычно <Del> или
<Ctrl>+<C>, текущему процессу посылается сигнал SIGINT.
Такое ветвление можно организовать на основании значения, возвращаемого системным
Для родительского процесса fork возвращает идентификатор созданного
дочернего процесса, а дочерний процесс получает значение, равное 0. Подробнее эти во!
просы будут рассмотрены в главе 2.
www.books-shop.com
Процессы 45
Рис. 1.6. Типичное "дерево" процессов в UNIX
Для отправления сигнала служит команда
kill
где — номер или символическое название сигнала, a pid — иден!
тификатор процесса, которому посылается сигнал. Администратор систе!
мы может посылать сигналы любым процессам, обычный же пользователь
может посылать сигналы только процессам, владельцем которых он явля!
ется (реальный и эффективный идентификаторы процесса должны совпа!
дать с идентификатором Например, чтобы послать процес!
су, который вы только что запустили в фоновом режиме, сигнал заверше!
ния выполнения можно воспользоваться командой:
$ &
$ kill $!
Запустим программу в фоновом режиме
По умолчанию команда kill(1) посылает сигнал SIGTERM;
переменная $! содержит PID последнего процесса, запу%
щенного в фоновом режиме
При получении сигнала процесс имеет три варианта действий для выбора:
1. Он может игнорировать сигнал. Не следует игнорировать сигналы, вы!
званные аппаратной частью, например, при делении на 0 или ссылке
на недопустимые области памяти, так как дальнейшие результаты в
отношении данного процесса непредсказуемы.
Точнее, с реальным и эффективным идентификаторами процесса, посылающего
Если вы посылаете сигнал командой kill(l), работая в shell, то речь идет о командном ин!
терпретаторе.
www.books-shop.com
46 Глава I. Работа в операционной системе UNIX
2. Процесс может потребовать действия по умолчанию. Как ни печально,
обычно это сводится к завершению выполнения процесса.
3. Наконец, процесс может перехватить сигнал и самостоятельно обрабо!
тать его. Например, перехват сигнала SIGINT позволит процессу уда!
лить созданные им временные файлы, короче, достойно подготовиться
к "смерти". Следует иметь в виду, что сигналы SIGKILL и SIGSTOP
нельзя ни перехватить, ни игнорировать.
По умолчанию команда посылает сигнал с номером 15 —
действие по умолчанию для которого — завершение выполнения процесса,
получившего сигнал.
Иногда процесс продолжает существовать и после отправления сигнала
SIGTERM. В этом случае можно применить более жесткое средство — по!
слать процессу сигнал SIGKILL с номером (9), — поскольку этот сигнал
нельзя ни перехватить, ни игнорировать:
$ kill 9 pid
Однако возможны ситуации, когда процесс не исчезает и в этом случае.
Это может произойти для следующих процессов:
Процессы!зомби. Фактически процесса как такового не существует,
осталась лишь запись в системной таблице процессов, поэтому уда!
лить его можно только перезапуском операционной системы. Зомби
в небольших количествах не представляют опасности, однако если
их много, это может привести к переполнению таблицы процессов.
Процессы, ожидающие недоступные ресурсы NFS (Network File
System), например, записывающие данные в файл файловой системы
удаленного компьютера, отключившегося от сети. Эту ситуацию
можно преодолеть, послав процессу сигнал SIGINT или
Процессы, ожидающие завершения операции с устройством, напри!
мер, перемотки магнитной ленты.
Сигналы могут не только использоваться для завершения выполнения
но и иметь специфическое для приложения (обычно для сис!
темных демонов) значение (естественно, это не относится к сигналам
SIGKILL и SIGSTOP). Например, отправление сигнала SIGHUP серверу
имен DNS вызовет считывание базы данных с диска. Для
других приложений могут быть определены другие сигналы и соответству!
ющие им значения.
Более подробно сигналы мы рассмотрим в главах 2 и 3.
между символьными именами и номерами сигналов может отличаться
различных версиях UNIX. Команда kill !I выводит номера сигналов и их имена.
www.books-shop.com
Устройства
Как уже отмечалось, UNIX "изолирует" приложения (а значит и пользова!
теля) от аппаратной части вычислительной системы. Например, в имени
файла отсутствует указатель диска, на котором этот файл расположен, а
большая часть взаимодействия с периферийными устройствами неотличи!
ма от операций с обычными файлами.
UNIX предоставляет единый интерфейс различных устройств системы в
виде специальных файлов устройств. Специальный файл устройства свя!
зывает прикладное приложение с драйвером устройства. Каждый специ!
альный файл соответствует какому!либо физическому устройству (напри!
мер, диску, накопителю на магнитной ленте, принтеру или терминалу)
или т. н. псевдоустройству (например, сетевому интерфейсу, пустому уст!
ройству, сокету или памяти). Вся работа приложения с устройством про!
исходит через специальный файл, а соответствующий ему драйвер обеспе!
чивает выполнение операций ввода/вывода в соответствии с конкретным
протоколом обмена данными с устройством.
Существует два типа специальных файлов устройств:
Файлы блочных устройств
Файлы символьных устройств
Файлы блочных устройств
Файлы блочных устройств служат интерфейсом к устройствам, обмен дан!
ными с которыми происходит большими фрагментами, называемыми бло!
ками. При этом ядро операционной системы обеспечивает необходимую
буферизацию. Примером физических устройств, соответствующих этому
типу файлов, являются жесткие диски. Приведем фрагмент подробного
списка файлов каталога /dev системы Digital UNIX, отражающий файлы
для доступа к первому и второму разделам первого диска SCSI:
1 root system 8, 1 Apr 18 11:03
1 root system 8, 1 Apr 18 13:15
Файлы символьных устройств
Файлы символьных устройств используются для доступа к устройствам,
драйверы которых обеспечивают собственную буферизацию и побайтную
передачу данных. В качестве примера устройств с символьным интерфей!
сом можно привести терминалы, принтеры и накопители на магнитной
ленте. Заметим, что одно и то же физическое устройство может иметь как
блочный, так и символьный интерфейсы. Для блочных устройств такой
интерфейс также называют интерфейсом доступа низкого уровня (raw
www.books-shop.com
48 Глава 1. Работа в операционной системе UNIX
interface). Так, для побайтного доступа к разделам диска, приведенным в
предыдущем примере, используются соответствующие файлы:
crw
crwr
1
1
crwrwrw 1
crwrwrw 1
root
root
root
root
root
bin
bin
system
system
system
system
system
terminal
terminal
8, 1
8, 1
13,1
7, 0
V, 1
3, 2
3, 3
Apr 18
Apr 18
Apr 18
Apr 18
Apr 18
Apr 18
Apr 18
11:04
13:15
18:08
15:20
15:20
16:10
16:10
/dev/rrzOb
/dev/tty02
/dev/tty03
Последние три строки списка представляют интерфейс доступа к вирту!
альной памяти ядра и двум псевдотерминалам.
В поле размера файла (пятая колонка вывода команды у специаль!
ных файлов устройств выводятся два числа. Это так называемые старшее
(major) и младшее (minor) числа. Часто драйвер обслуживает более одного
устройства. При этом старшее число указывает ядру на конкретный драй!
вер (например, драйвер а младшее передается драй!
веру и указывает на конкретное устройство (например, конкретный псев!
дотерминал).
Интерфейс файловой системы для взаимодействия с устройством схемати!
чески представлен на рис. 1.7.
Рис. 1.7. Взаимодействие с устройством
www.books-shop.com
Устройства
Мнемоника названий специальных файлов устройств
в файловой системе UNIX
Названия специальных файлов устройств в большой степени зависят от
конкретной версии UNIX. Тем не менее в этих названиях присутствует
общая логика, позволяющая даже в незнакомой системе определить, какие
файлы отвечают за конкретные устройства. Например, имена файлов дос!
тупа к дисковым устройствам обычно содержат указание на тип диска,
номер контроллера, логический номер устройства, раздел диска и т. д. По
названию также легко определить, какой вид доступа предоставляет дан!
ный интерфейс (блочный или символьный).
В качестве примера рассмотрим специальный файл устройства для доступа
к разделу диска в операционной системе Solaris:
/dev/dsk/cOt4dOs2
Данный файл предоставляет блочный интерфейс, а соответствующий ему
символьный (или необработанный) файл имеет имя:
/dev/rdsk/cOt4dOs2
Файлы доступа к дисковым устройствам располагаются в специальных
подкаталогах — /dev/dsk (для блочных устройств) и /dev/rdsk (для сим!
вольных устройств). Такая структура хранения специальных файлов харак!
терна для систем UNIX версии System V.
Имя файла, характерное для систем версии SVR4, можно представить в
общем виде:
s n
где k — номер контроллера, / — номер устройства (для устройств SCSI это
идентификатор устройства ID), m — номер раздела, — логический но!
мер устройства (LUN) SCSI.
Таким образом файл устройства /dev/rdsk/cOt4dOs2 обеспечивает доступ к
первому разделу (нумерация разделов начинается с 0) диска с
LUN=2 первого контроллера.
Такой формат имен файлов в версии SVR4 применяется для всех дисковых
устройств и накопителей на магнитной ленте. Иногда для этих стандарт!
ных имен в файловой системе имеются символические связи с более про!
стыми названиями. Например, в Solaris имя /dev/sdOa может использовать!
ся вместо /dev/dsk/cOt3dOs, также обеспечивая доступ к устройству:
root root 12 Oct 31 17:48 /dev/sdOa
В SCO UNIX имеются специальные файлы с более простыми именами
/dev/root, /dev/usr и т. п, которые предоставляют доступ к разделам диска
с такими же именами (root, usr).
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
50 Глава 1. в операционной системе UNIX
Более простая мнемоника обнаруживается в именах специальных файлов
других устройств. Так, например, параллельный порт в большинстве сис!
тем имеет имя где п — номер порта (О, 1 и т. д.). Терминальные
линии, подключенные к последовательным портам компьютера обознача!
ются как /dev/ttynn, где является идентификатором линии. В табл. 1.6
приведены примеры других специальных файлов устройств.
Таблица 1.6. Имена некоторых специальных файлов устройств
Общий вид имени Пример
/dev/rstn /dev/rst1
/dev/cdn /dev/cdO
Описание доступ к
которому обеспечивается через
файл
Накопитель на магнитной ленте
Накопитель на магнитной ленте в режиме
без перемотки назад по окончании работы
SCSI%накопитель на магнитной ленте
CD%ROM
/dev/ttypn
/dev/ptypn /dev/ptyp5
/dev/zero
Псевдотерминал (подчиненный)
Псевдотерминал (мастер)
Системная консоль
Синоним терминальной линии управляю%
щего терминала для данного процесса
Физическая оперативная память
Виртуальная память ядра
Нулевое устройство — весь вывод на него
уничтожается, а при попытке ввода с этого
устройства возвращается 0 байтов
Нулевое устройство — весь вывод на него
уничтожается, а ввод приводит к получе%
нию последовательности 0
Пользователи системы
Прежде чем вы сможете начать работу в UNIX, вы должны стать пользова!
телем системы, т. е. получить имя, пароль и ряд других атрибутов.
С точки зрения системы, пользователь — не обязательно человек. Пользо!
ватель является объектом, который обладает определенными правами, мо!
жет запускать на выполнение программы и владеть файлами. В качестве
пользователей могут, например, выступать удаленные компьютеры или
группы пользователей с одинаковыми правами и функциями. Такие поль!
www.books-shop.com
Пользователи системы
зователи называются псевдопользователями. Они обладают правами на оп!
ределенные файлы системы и от их имени запускаются задачи, обеспечи!
вающие ту или иную функциональность UNIX.
Как правило, большинство пользователей являются реальными людьми,
которые регистрируются в системе, запускают те или иные программы,
короче говоря, используют UNIX в своей работе.
В системе существует один пользователь, обладающий неограниченными
правами. Это суперпользователь или администратор системы.
Каждый пользователь системы имеет уникальное имя (или регистрационное
имя — login name). Однако система различает пользователей по ассоцииро!
ванному с именем идентификатору пользователя или (User Identifier).
Понятно, что идентификаторы пользователя также должны быть уникаль!
ными. Пользователь является членом одной или нескольких групп — спи!
сков пользователей, имеющих сходные задачи (например пользователей,
работающих над одним проектом). Принадлежность к группе определяет
дополнительные права, которыми обладают все пользователи группы. Ка!
ждая группа имеет уникальное имя (уникальное среди имен групп, имя
группы и пользователя могут совпадать), но как и для пользователя, внут!
ренним представлением группы является ее идентификатор (Group
Identifier). В конечном счете UID и GID определяют, какими правами об!
ладает пользователь в системе.
Вся информация о пользователях хранится в файле Это обыч!
ный текстовый файл, право на чтение которого имеют все пользователи
системы, а право на запись имеет только администратор (суперполь!
зователь). В этом файле хранятся пароли пользователей, правда в
рованном виде. Подобная открытость — недостаток с точки зрения без!
опасности, поэтому во многих системах зашифрованные пароли хранятся в
отдельном закрытом для чтения и записи файле /etc/shadow.
Аналогично, информация о группах хранится в файле /etc/group и содер!
жит списки пользователей, принадлежащих той или иной группе.
Атрибуты пользователя
Как правило, все атрибуты пользователя хранятся в файле /etc/passwd. В
конечном итоге, добавление пользователя в систему сводится к внесению
в файл /etc/passwd соответствующей записи. Однако во многих системах
информация о пользователе хранится и в других местах (например, в спе!
циальных базах данных), поэтому создание пользователя простым редак!
тированием файла /etc/passwd может привести к неправильной регистра!
ции пользователя, а иногда и к нарушениям работы системы. Вместо этого
при возможности следует пользоваться специальными утилитами, постав!
ляемыми с системой. Более подробно мы поговорим об этом при обсужде!
нии задач администрирования UNIX в конце этой главы.
www.books-shop.com
52 Глава 1. Работа в операционной UNIX
Сейчас же наша задача — разобраться, какую информацию хранит система
о пользователе. Для этого рассмотрим фрагмент файла
no
Каждая строка файла является записью конкретного пользователя и имеет
следующий формат:
— всего семь полей (атрибутов), разделенных двоеточиями.
Рассмотрим подробнее каждый из атрибутов:
name Регистрационное имя пользователя. Это имя пользова!
тель вводит в ответ на приглашение системы login. Для
небольших систем имя пользователя достаточно произ!
вольно. В больших системах, в которых зарегистриро!
ваны сотни пользователей, требования уникальности
заставляют применять определенные правила выбора
имен.
Пароль пользователя в закодированном виде. Алгорит!
мы кодирования известны, но они не позволяют деко!
дировать пароль. При входе в систему пароль, который
вы набираете, кодируется, и результат сравнивается с
полем passwd!encod. В случае совпадения пользовате!
лю разрешается войти в систему.
Даже в закодированном виде доступность пароля пред!
ставляет некоторую угрозу для безопасности системы.
Поэтому часто пароль хранят в отдельном файле, а в
поле passwd!encod ставится символ 'х' (в некоторых
системах '!').
Пользователь, в данном поле которого стоит символ '*',
никогда не сможет попасть в систему. Дело в том, что
алгоритм кодирования не позволяет символу '*' поя!
виться в закодированной строке. Таким образом, совпа!
дение введенного и затем закодированного пароля и '*'
невозможно. Обычно такой пароль имеют псевдополь!
зователи.
www.books-shop.com
Пользователи 53
UID
GID
comments
Идентификатор пользователя является внутренним
представлением пользователя в системе. Этот иденти!
фикатор наследуется задачами, которые запускает поль!
зователь, и файлами, которые он создает. По этому
идентификатору система проверяет пользовательские
права (например, при запуске программы или чтении
файла). Суперпользователь имеет UID = 0, что дает ему
неограниченные права в системе.
Определяет идентификатор первичной группы пользова!
теля. Этот идентификатор соответствует идентификато!
ру в файле /etc/group, который содержит имя группы и
полный список пользователей, являющихся ее членами.
Принадлежность пользователя к группе определяет до!
полнительные права в системе. Группа определяет об!
щие для всех членов права доступа и тем самым обес!
печивает возможность совместной работы (например,
совместного использования файлов).
Обычно, это полное "реальное" имя пользователя. Это
поле может содержать дополнительную информацию,
например, телефон или адрес электронной почты. Не!
которые программы (например, и почтовые
системы) используют это поле.
Домашний каталог пользователя. При входе в систему
пользователь оказывается в этом каталоге. Как правило,
пользователь имеет ограниченные права в других частях
файловой системы, но домашний каталог и его подка!
талоги определяют область файловой системы, где он
является полноправным хозяином.
Имя программы, которую UNIX использует в качестве
командного интерпретатора. При входе пользователя в
систему UNIX автоматически запустит указанную про!
грамму. Обычно это один из стандартных командных ин!
терпретаторов (Bourne shell), (C shell) или
shell), позволяющих пользователю вводить
команды и запускать задачи. В принципе, в этом поле
может быть указана любая программа, например, ко!
мандный интерпретатор с ограниченными функциями
(restricted shell), клиент системы управления базой дан!
ных или даже редактор. Важно то, что, завершив выпол!
нение этой задачи, пользователь автоматически выйдет
из системы. Некоторые системы имеют файл /etc/shells,
содержащий список программ, которые могут быть ис!
пользованы в качестве командного интерпретатора.
www.books-shop.com
54 Глава 1. Работа в операционной системе
Пароли
Наличие пароля позволяет защитить ваши данные, а возможно (если вы —
суперпользователь) и всю систему в целом. Уточним: наличие хорошего
пароля, потому что неверно выбранный пароль — серьезная брешь в безо!
пасности системы. Поэтому мы более подробно остановимся на основных
рекомендациях по выбору пароля.
Назначить или изменить пароль можно командой Обычный
пользователь может изменить свой пароль, администратор может назна!
чить пароль любому пользователю.
Перед запуском программы стоит держать в голове общее прави!
ло выбора пароля: пароль должен хорошо запоминаться и быть трудным
для подбора.
Не рекомендуется записывать пароль, его необходимо запомнить. Собствен!
ная фамилия, кличка любимой собаки, год и месяц рождения, безусловно,
легки для запоминания, но такие пароли нетрудно подобрать. Многие сис!
темы предлагают пароль, сгенерированный самой системой. Предполагается,
что он совершенно лишен какого!либо смысла, т. е. не содержит имен, на!
званий и вообще каких!либо произносимых слов. Хотя система предлагает
его в виде, удобном для запоминания, это не всегда помогает.
Если по правилам работы в вашей системе можно самостоятельно выбрать
постарайтесь подобрать что!нибудь, что легче будет запомнить. Ни!
когда не используйте примеры паролей, приводимые в книгах и руковод!
ствах (чтобы не было искушения, в этой книге примеры не приводятся).
Многие системы требуют, чтобы пароль удовлетворял следующим требо!
ваниям:
длина пароля не должна быть меньше шести символов;
пароль должен включать по крайней мере 2 алфавитных символа и
одну цифру или специальный символ;
пароль должен содержать хотя бы 3 символа, не встречавшихся в
вашем предыдущем пароле.
Пароли играют значительную роль в обеспечении безопасности системы.
Общие рекомендации, адресованные прежде всего администраторам, мож!
но свести к следующим:
1. В системе не должно существовать незащищенных пользовательских
входов. Это относится как к пользовательским входам без пароля, так
и ко входам пользователей, покинувших систему. Если пользователь
длительное время не работает в системе, удалите его запись или хотя
бы защитите его вход символом '*' в поле пароля.
2. Если ваша система допускает, установите минимальную длину пароля.
В зависимости от требований безопасности в системе это число может
варьироваться от 8 до 12.
www.books-shop.com
Пользователи системы 55
Всегда меняйте пароль в следующих случаях:
• если кто!либо узнал ваш пароль.
• если пользователь больше не работает в вашей системе, все па!
роли, которые он знал, должны быть изменены.
• если меняется администратор системы, должны быть изменены
все системные пароли.
• если у вас появилось подозрение, что файл паролей был считан
по сети, будет разумным сменить все пароли в системе.
4. Пароль администратора должен периодически меняться, независимо
от обстоятельств.
5. Это может показаться странным, но не стоит заставлять пользователей
менять пароли чересчур часто. Скорее всего, в этом случае пользова!
тель выберет не лучший пароль. Но менять пароли все же следует.
Частота смены зависит от степени доступности вашей системы (изоли!
рованная станция, сервер с сетевым доступом, наличие сетевых экра!
нов).
Не преуменьшайте роль паролей в системе.
Стандартные пользователи и группы
После установки UNIX обычно уже содержит несколько зарегистрирован!
ных пользователей. Перечислим основные из них (в разных версиях сис!
темы UID этих пользователей могут незначительно отличаться):
Имя Пользователь
root Суперпользователь, администратор системы, UID=0. Пользователь с
этим именем имеет неограниченные полномочия в системе. Для него
не проверяются права доступа, и таким образом он имеет все "рычаги"
для управления системой. Для выполнения большинства функций ад%
министрирования требуется вход именно с этим именем. Следует отме%
тить, что root — это только имя. На самом деле значение имеет UID.
Любой пользователь с UID=0 имеет полномочия суперпользователя
Псевдопользователь, владеющий файлами системы ведения журналов
bin Обычно это владелец всех исполняемых файлов, являющихся коман%
дами UNIX
cron Псевдопользователь, владеющий соответствующими файлами, от име%
ни которого выполняются процессы подсистемы запуска программ по
расписанию
или Псевдопользователь, от имени которого выполняются процессы систе%
мы печати, владеющий соответствующими файлами
news Псевдопользователь, от имени которого выполняются процессы систе%
мы телеконференций
www.books-shop.com
56 Глава Работа в операционной системе UNIX
(продолжение)
Имя Пользователь
nobody Псевдопользователь, используемый в работе NFS
uucp Псевдопользователь подсистемы copy (uucp), позволяю%
щей передавать почтовые сообщения и файлы между UNIX%хостами
Новая система также содержит ряд предустановленных групп. Поскольку
группы, как правило, менее значимы, приведем лишь две категории:
Имя Группа
root или wheel Административная группа, GID=0
user или users или staff Группа, в которую по умолчанию включаются все обычные
пользователи UNIX
Пользовательская среда UNIX
Сегодня характер работы в UNIX существенно отличается от того, каким он
был, скажем, пятнадцать лет назад. Графический многооконный интерфейс,
миллионы цветов, системы меню, техника drag!and!drop, — все это, казалось
бы, стирает различия в работе с UNIX и, например, с Windows NT. Но
взгляните внимательнее на экран монитора — и вы обязательно найдете хо!
тя бы одно окно простого алфавитно!цифрового терминала.
Это — базовая пользовательская среда. Интерфейс командной строки мо!
жет показаться безнадежно устаревшим, но в случае с UNIX это — самый
непосредственный способ выполнения множества небольших задач адми!
нистрирования. И программа, с которой вы рано или поздно столкне!
тесь, — командный интерпретатор shell. Поэтому здесь мы рассмотрим ба!
зовый пример работы в UNIX — использование командной строки интер!
претатора shell.
Командный интерпретатор shell
Все современные системы UNIX поставляются по крайней мере с тремя
командными интерпретаторами: Bourne shell С shell и
shell Существует еще несколько интерпретаторов, напри!
мер shell (bash), со сходными функциями.
Командный интерпретатор занимает важное место в операционной систе!
ме UNIX, прежде всего, благодаря следующим обстоятельствам:
www.books-shop.com
Пользовательская UNIX 57
1. Первая программа, с которой по существу начинается работа пользо!
вателя, — shell. В UNIX реализуется следующий сценарий работы в
системе (рис. 1.8):
• При включении терминала активизируется процесс
который является сервером терминального доступа и запускает
программу которая, в свою очередь, запрашивает у
пользователя имя и пароль.
• Если пользователь зарегистрирован в системе и ввел правиль!
ный пароль, запускает программу, указанную в послед!
нем поле записи пользователя в файле В принципе
это может быть любая программа, но в нашем случае — это ко!
мандный интерпретатор shell.
• Shell выполняет соответствующий командный файл инициали!
зации, и выдает на терминал пользователя приглашение. С этого
момента пользователь может вводить команды.
• Shell считывает ввод пользователя, производит синтаксический
анализ введенной строки, подстановку шаблонов и выполняет
действие, предписанное пользователем (это может быть запуск
программы, выполнение внутренней функции интерпретатора)
или сообщает об ошибке, если программа или функция не най!
дены.
• По окончании работы пользователь завершает работу с интер!
претатором, вводя команду exit, и выходит из системы.
2. Командный интерпретатор является удобным средством программиро!
вания. Синтаксис языка различных командных интерпретаторов не!
сколько отличается, в качестве базового мы рассмотрим командный
интерпретатор Bourne. С помощью shell вы можете создавать сложные
программы, конструируя их, как из кирпичиков, из существующих
утилит UNIX. Программы на языке shell часто называют скриптами
или сценариями (script). Интерпретатор считывает строки из файла!
скрипта и выполняет их, как если бы они были введены пользовате!
лем в командной строке.
Как уже упоминалось, при входе пользователя в систему запускается
его скрипт, выполняющий несколько функций:
установку пути поиска программ, инициализацию терминала, опреде!
ление расположения почтового ящика. Помимо этого может быть вы!
полнен целый ряд полезных действий, — например, установка при!
глашения. Скорее всего вам придется "покопаться" в этом скрипте, по
крайней мере, чтобы добавить необходимые пути поиска. Инициали!
зационный скрипт находится в домашнем каталоге пользователя.
В данном разделе мы не останавливаемся на подробностях запуска Эти вопросы
будут рассмотрены позднее в главе 3.
www.books-shop.com
58 Глава 1. в операционной системе UNIX
Для разных командных интерпретаторов используются различные
скрипты инициализации:
Командный интерпретатор Скрипт инициализации
Bourne shell (sh)
С shell (csh) и
Korn shell (ksh) и
Bourne%Again shell (bash) и
Скрипты и выполняются при первом входе в систему.
Скрипты и выполняются при каждом запуске ин!
терпретатора.
Рис. 1.8. Процессы, обеспечивающие вход пользователя в систему
www.books-shop.com
UNIX
4. Наконец, основная инициализация операционной системы происхо!
дит в результате выполнения скриптов shell. Если вам понадобится
модифицировать процесс инициализации (например, добавить новый
системный сервис), то придется заглянуть в эти скрипты.
Синтаксис языка Bourne shell
Любой из стандартных командных интерпретаторов имеет развитый язык
программирования, позволяющий создавать командные файлы, или
скрипты, для выполнения достаточно сложных задач. Следует, однако,
иметь в виду, что shell является интерпретатором, он последовательно счи!
тывает команды из скрипта и выполняет их, как если бы они последова!
тельно вводились пользователем с терминала. При таком характере работы
трудно ожидать большой производительности от скриптов, однако их эф!
фективность определяется простотой и наглядностью. Если же производи!
тельность программы играет главную роль, то самым эффективным сред!
ством по!прежнему остается язык программирования С.
В этом разделе приведены сведения о языке Bourne shell, достаточные,
чтобы разобраться в системных скриптах и написать простейшие скрипты.
Данное описание ни в коем случае не претендует на полное руководство
по программированию на языке командного интерпретатора.
Общий синтаксис скрипта
Как уже было замечено, скрипт представляет собой обычный текстовый
файл, в котором записаны инструкции, понятные командному интерпре!
татору. Это могут быть команды, выражения shell или функции. Команд!
ный интерпретатор считывает эти инструкции из файла и последовательно
выполняет их.
Безусловно, как и в случае любого другого языка программирования, при!
менение комментариев существенно облегчает последующее использова!
ние и модификацию написанной программы. В Bourne shell комментарии
начинаются с символа '#':
Этот скрипт выполняет поиск "мусора" (забытых временных
файлов, файлов core и т.п.) в каталогах пользователей
Комментарии могут занимать не всю строку, а следовать после команды:
find /home name core print Выполним поиск файлов core
Поскольку в системе могут существовать скрипты для различных интер!
претаторов, имя интерпретирующей команды обычно помещается в пер!
вой строке следующим образом:
В данном случае последующий текст скрипта будет интерпретироваться
Bourne shell. Заметим, что при запуске скрипта из командной строки (для
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
60 Глава 1. Работа в операционной UNIX
этого он должен обладать правом на выполнение — х), будет запущен но!
вый командный интерпретатор, ввод команд для которого будет выпол!
няться из файла скрипта.
Переменные
В командной строке или скрипте командного интерпретатора можно оп!
ределить и использовать переменные. Значением переменной является
строка, которая передается присвоением:
где var — имя переменной, a value — ее значение.
Значение переменной можно получить, используя знак Например, вы!
вести значение переменной name на экран можно с помощью команды
echo следующим образом:
$ echo
Так же можно присвоить другой переменной значение перемен!
ной name:
$
Значение переменной можно присвоить иначе. Поскольку значение пред!
ставляет собой строку, shell предоставляет удобный способ генерации
строк из потока вывода команды. Синтаксис присвоения при этом сле!
дующий:
Так, например, где var — имя переменной, a command — название коман!
ды, команда выводит строку со значением текущего каталога:
$ pwd
Можно присвоить переменной значение текущего каталога, которое
сохранится в ней:
$
$ echo $cdir
$ cd /usr/bin
$ pwd
/usr/bin
$ cd $cdir
$ pwd
При использовании переменной, например var, командный интерпретатор
подставляет вместо $var ее значение. Более сложные синтаксические кон!
струкции получения значения переменной приведены в табл. 1.7.
www.books-shop.com
Пользовательская UNIX 61
Таблица 1.7. Способы получения значения переменной
$var Значение var; ничего, если переменная var не определена
То же, но отделяет имя переменной var от последующих символов
Значение var, если определено; в противном случае — string.
Значение var при этом не изменяется
То же, но если переменнвя var не определена, ей присваивается
значение строки string
Если переменная var не определена, выводится строка string и
интерпретатор прекращает работу. Если строка string пуста, то
выводится сообщение var: parameter not set
Строка переменная var определена, в противном слу%
чае — ничего
Приведем несколько примеров, используя команду echo:
$ var=userl
$ varl=user2
$ echo $varl
user2
$ echo
userll
$ echo want to redefine
do you want to redefine var?
Для нормальной работы в UNIX ряд переменных должен быть определен
и зависит от тех приложений, с которыми вы работаете. Приведем не!
сколько наиболее употребительных переменных:
Имя
НОМЕ
PATH
MAIL
TERM
PS1
PS2
Описание
Каталог верхнего уровня пользователя
Поисковый путь
Имя почтового ящика
Имя терминала
Первичное приглашение shell
Вторичное приглашение shell
Возможное значение
ansi
#
>
Начальное окружение вашего сеанса устанавливается программой
исходя из записей в файле паролей, и имеет следующий вид:
Переменная окружения Поле файла паролей
N
В данном примере утилита выводит регистрационное имя пользователя, таким
образом для пользователя переменная НОМЕ примет следующее значение:
www.books-shop.com
62 Глава 1. Работа в операционной системе UNIX
(продолжение)
Переменная окружения Поле файла паролей
PATH=/usr/bin: %
7
1
определено системой
Переменная НОМЕ в основном используется в команде которая слу!
жит для перехода в каталог:
$ pwd
/u/usr
$ cd some/new/directory
$ pwd
В результате текущим каталогом (команда выводит на терминал
полное имя текущего каталога) становится Вы!
зов команды cd без параметра эквивалентен следующему вызову:
$ cd $HOME
который вернет вас в домашний каталог.
Переменная PATH служит для поиска командным интерпретатором запус!
каемых на выполнение программ, если их имя не содержит пути. Напри!
мер, при запуске программы:
$ run
интерпретатор попытается найти файл run в каталогах пути поиска. В то
же время при запуске программы run с указанием пути, переменная PATH
использоваться не будет:
$
В последнем примере было задано относительное имя программы (отно!
сительно текущего каталога, обозначаемого точкой). Предполагается, что
файл программы имеется в текущем каталоге, в противном случае shell вы!
ведет сообщение об ошибке.
Каталоги поиска в переменной PATH разделены символом ':'. Заметим,
что текущий каталог поиска должен быть задан явно ('.'), shell не произво!
дит поиск в текущем каталоге по умолчанию.
Поиск запускаемых программ в текущем каталоге таит потенциальную
опасность, поэтому для суперпользователя переменная PATH обычно
инициализируется без '.'. Рассмотрим следующую ситуацию. Злоумышлен!
ник создает программу, наносящую вред системе (удаляющую файл паро!
лей), помещает ее в каталог общего пользования, например в /tmp, откры!
тый на запись всем пользователям системы, с именем Известно, что в
www.books-shop.com
UNIX
UNIX существует стандартная команда (она обычно находится в ката!
логе выводящая на экран список файлов каталога. Допустим теперь,
что администратор системы делает текущим каталог и хочет вывести
список файлов данного каталога. Если текущий каталог ('.') расположен в
пути поиска (переменной PATH) раньше каталога то выполнится
программа, "подложенная" злоумышленником. Даже если текущий каталог
указан последним в пути поиска, все равно существует вероятность, что вы
захотите запустить команду, которая расположена в каталоге, не попавшем
в переменную PATH, на самом деле вы можете запустить троянского коня.
Переменная MAIL определяет местоположение вашего почтового ящика,
программы работы с электронной почтой используют эту переменную.
Переменная MAIL инициализируется программой
Переменная TERM содержит имя терминала и используется программами
для доступа к базе данных терминалов. Обычно это программы, обеспечи!
вающие полноэкранный режим работы, цвета и системы меню (редакторы,
различные пользовательские оболочки). Поскольку наборы команд работы
с различными терминалами отличаются друг от друга, используется специ!
альная база данных, где хранятся конкретные команды для конкретного
терминала.
Переменные PS1 и PS2 устанавливают первичное и вторичное приглаше!
ния командного интерпретатора. Первичное приглашение указывает на го!
товность интерпретатора к вводу команд. Значение этой переменной уста!
навливается при исполнении скрипта при
входе пользователя в систему, и имеет вид для обычных пользователей
и для суперпользователя. Однако вид приглашения легко изменить,
соответствующим образом задав значение переменной PS1. Например, ес!
ли вы хотите, чтобы в приглашении присутствовало имя хоста, на котором
вы работаете, задайте значение PS1 следующим образом:
—
В этом случае, если имя вашей системы, например, telemak, при входе в
систему командный интерпретатор выведет следующее приглашение:
Вторичное приглашение появляется, если вы нажали клавишу <Enter>, син!
таксически не закончив ввод команды. Например:
$ while : нажатие клавиши <Enter>
> do нажатие клавиши <Enter>
> echo нажатие клавиши <Enter>
> done нажатие клавиши <Enter>
После этого вы увидите слово выводимое на экран в бесконеч!
ном цикле. (Если вы все!таки воспроизвели этот пример, нажмите клави!
ши <Del>.)
www.books-shop.com
(54 Глава 1. Работа в UNIX
Переменные, которые определены, являются внутренними переменными
командного интерпретатора и не попадают в его окружение автоматически.
Таким образом, они не могут быть использованы другими программами,
запускаемыми из shell (окружение наследуется порожденными процессами).
Для того чтобы поместить необходимые переменные в окружение shell и тем
самым сделать их доступными для других приложений, эти переменные
должны быть отмечены как экспортируемые. В этом случае при вызове ка!
кой!либо программы они автоматически попадут в ее окружение. Например,
программа работы с электронной почтой получает имя файла — почтового
ящика через переменную MAIL, программы, работающие с терминалом,
например полноэкранный редактор, обращаются к базе данных терминалов,
используя переменную TERM. Разработанная вами программа также может
получать часть информации через переменные окружения. Для этого она
должна использовать соответствующие функции и
которые мы подробнее рассмотрим в следующей главе.
Встроенные переменные
Помимо переменных, определяемых явно, shell имеет ряд внутренних пере!
менных, значения которых устанавливаются самим интерпретатором. По!
скольку это внутренние переменные, имя переменной вне контекста полу!
чения ее значения не имеет смысла (т. е. не существует переменной #, име!
ет смысл лишь ее значение $#). Эти переменные приведены в табл. 1.8.
Таблица 1.8. Внутренние переменные shell
$2, . . . Позиционные параметры скрипта
Число позиционных параметров скрипта
$ Код возврата последнего выполненного процесса
текущего shell
РЮ последнего процесса, запущенного в фоновом режиме
Все параметры, переданные скрипту. Передаются как единое
слово, будучи заключенным в кавычки:
$2 $3 . .
$@ Все параметры, переданные скрипту. Передаются как отдельные
слова, будучи заключенным в кавычки:
. .
Эти переменные редко используются при работе в командной строке, основ!
ная область их применения — скрипты. Рассмотрим несколько примеров.
Текст скрипта Запуск скрипта
а4
echo $0
echo $1 $2 $3
а2 аЗ а4
echo $1 $2 $3
www.books-shop.com
UNIX
Переменные $1, $2, ... $9 содержат значения позиционных параметров —
аргументов запущенного скрипта. В $1 находится первый аргумент в
$2 — а2 и т. д. до девятого аргумента. При необходимости передать боль!
шее число аргументов, требуется использовать команду shift n, производя!
щую сдвиг значений аргументов на п позиций (по умолчанию — на одну
позицию). Приведенный скрипт иллюстрирует этот прием. В переменной
$0 находится имя запущенного скрипта. Здесь наблюдается полная ана!
логия с массивом параметров argv[], передаваемом программе на языке С.
Значение $# равно числу позиционных параметров. Его удобно использо!
вать при проверке соответствия числа введенных пользователем парамет!
ров требуемому.
Текст скрипта Запуск скрипта
$ test2.sh
if [ $# 2 ] usage: test2.sh arg2
then $ h2
echo usage: $0 argl arg2 $
exit 1
fi
В данном примере использовано условное выражение if и проверка, кото!
рые мы рассмотрим ниже.
Код возврата последней выполненной задачи ($?) удобно использовать в ус!
ловных выражениях. По правилам успешным завершением задачи считается
код возврата, равный 0, ненулевой код возврата свидетельствует об ошибке.
Код возврата скриптов генерируется с помощью команды exit п, где п — код
возврата (см. предыдущий пример). В приведенном ниже примере определя!
ется, зарегистрирован ли в системе пользователь с именем Для
этого программой grep(l) производится поиск слова sergey в файле паролей.
В случае удачи grep(l) возвращает 0. Если слово не найдено, то grep(l) воз!
вращает ненулевое значение, в данном случае это свидетельствует, что поль!
зователь с именем sergey в системе не зарегистрирован.
Текст скрипта test3.sh:
grep sergey /etc/passwd
if [ $? ne 0 ]
then
echo пользователь sergey в системе не зарегистрирован
fi
Каждый активный процесс в UNIX имеет уникальный идентификатор
процесса, PID. Запуская скрипт, вы порождаете в системе процесс с уни!
кальным PID. Значение PID сохраняется в переменной $$. Эту перемен!
ную удобно использовать в названиях временных файлов, поскольку их
имена будут уникальными, например:
www.books-shop.com
66 1. Работа в системе UNIX
Текст скрипта test4.sh:
$
Перенаправление ввода/вывода
Каждая запущенная из командного интерпретатора программа получает
три открытых потока ввода/вывода:
П стандартный ввод
стандартный вывод
стандартный вывод ошибок
По умолчанию все эти потоки ассоциированы с терминалом. То есть лю!
бая программа, не использующая потоки, кроме стандартных, будет ожи!
дать ввода с клавиатуры терминала, весь вывод этой программы, включая
сообщения об ошибках, будет происходить на экран терминала. Большое
число утилит, с которыми вам предстоит работать, используют только
стандартные потоки. Для таких программ shell позволяет независимо пе!
ренаправлять потоки ввода/вывода. Например, можно подавить вывод со!
общений об ошибках, установить ввод или вывод из файла и даже пере!
дать вывод одной программы на ввод другой.
В табл. 1.9 приведен синтаксис перенаправления ввода/вывода, а на рис. 1.9
схематически показаны примеры перенаправления потоков.
Таблица 1.9. Перенаправление потоков
>file Перенаправление стандартного потока вывода в файл file
Добавление в файл file данных из стандартного потока вывода
<file Получение стандартного потока ввода из файла file
р1 |р2 Передача стандартного потока вывода программы р1 в поток ввода р2
n>file Переключение потока вывода из файла с дескриптором п в файл file
To же, но записи добавляются в файл file
n>&m Слияние потоков с дескрипторами
"Ввод здесь": используется стандартный поток ввода до подстроки str.
При этом выполняются подстановки метасимволов командного интерпре%
татора
To же, но подстановки не выполняются
Рассмотрим несколько примеров перенаправления потоков.
Запуск некой программы ведения журнала можно выполнить следующим
образом:
$ logger
www.books-shop.com
среда UNIX 67
При этом вывод программы logger будет записываться в конец файла
сохраняя все предыдущие записи. Если файла file.log не существу!
ет, он будет создан. В отличие от этого, использование символа '>' указы!
вает, что сначала следует очистить файл, а затем производить запись.
Стандартным потокам ввода, вывода и вывода ошибок присваиваются де!
скрипторы — числовые значения, являющиеся указателями на соответст!
вующий поток. Они, соответственно, равны О, 1 и 2. Перенаправлять по!
токи можно, используя эти числовые значения. Таким образом, предыду!
щему примеру эквивалентна следующая запись:
$ logger . log
Рис. 1.9. Пример перенаправления стандартных потоков
Чаще всего числовое значение дескриптора потока используется для пото!
ка ошибок. Например, чтобы подавить вывод ошибок, можно использо!
вать следующую запись:
$ run 2>/dev/null
где является псевдоустройством, удаляющим все введенные в
него символы.
Командный интерпретатор предоставляет возможность слияния потоков.
Например, при запуске команды
$ 2>S1 &
сообщения об ошибках будут также выводиться в файл /dev/null. Символ
'&' перед именем потока необходим, чтобы отличить его от файла с име!
нем 1. Заметим, что изменение порядка двух перенаправлений потоков
приведет к тому, что сообщения об ошибках будут по!прежнему выводить!
ся на экран. Дело в том, что Shell анализирует командную строку слева
направо, таким образом сначала будет осуществлено слияние потоков и
www.books-shop.com
Глава Работа в системе UNIX
оба будут указывать на терминал пользователя, а затем стандартный поток
вывода будет перенаправлен в файл
Передача потока вывода одной программы в поток ввода другой осуществ!
ляется с помощью конвейера (программного канала). Программные ка!
налы часто используются для фильтрации вывода некоторой команды:
$ ps — ef I grep
позволяет получить информацию о конкретном процессе myproc. Утилита
ps(l) выводит на экран информацию обо всех процессах в системе, про!
грамма grep(l) фильтрует этот поток, оставляя лишь строки, в которых
присутствует слово
Можно усложнить задачу и попытаться получить идентификатор процесса
myproc. Однако здесь нам не обойтись без других средств системы. В дан!
ном случае мы будем использовать интерпретатор
$ ps ef | grep myproc I awk print $2
Идея заключается в фильтрации второго поля записи о процессе myproc,
содержащего идентификатор процесса (см. описание утилиты
Иногда возникает необходимость разместить поток ввода вместе с коман!
дой. Для этого используется выражение "ввод здесь". Проиллюстрируем
его на примере:
$ at Dec 31
cat | elm Новым Годом"
По определению, команда at(l) устанавливает вызов команды, полученной
ею со стандартного ввода (клавиатуры терминала), на определенное время
(в данном случае — на 31 декабря каждого года). С помощью выражения
"ввод здесь" мы явно задали вид этой команды, точнее комплекса команд:
cat(l) передает текст поздравления программе отвечающей за от!
правление сообщения электронной почты.
Команды, функции и программы
Все команды, которые вводятся в строке приглашения shell, относятся к
одной из следующих категорий:
Более правильно было бы записать:
$ ps !ef I grep myproc | grep !v grep
Дело в том, что в списке, созданном командой будут две строки, содержащие слово
myproc: собственно строка процесса myproc и строка процесса grep(l) с параметром
myproc (ps имя породившей процесс, вместе со всеми пара!
метрами).
www.books-shop.com
Пользовательская UNIX
встроенные функции
функции shell, определенные пользователем
внешние программы и утилиты
Непосредственное отношение к shell имеют только первые две категории,
а программы и утилиты являются обычными исполняемыми файлами.
Запуск встроенной функции не требует порождения нового процесса, по!
скольку эта функция реализована в самой программе shell (например,
Соответственно, встроенные функции shell выполняются быстрее
всего. Рассмотрим важнейшие встроенные функции shell.
: Пустая команда. Код возврата всегда 0 (успех).
Пустая команда удобна для создания бесконечных
циклов, например:
while :
do
done
Текущий командный интерпретатор выполняет команды,
указанные в файле При этом не происходит поро%
ждения нового shell, как в случае запуска на выполнение
runme. Например, использование в скрипте команды
. выполнит команды фай%
ла include_script, как если бы они являлись частью теку%
щего скрипта.
. runme
break [л] Производит выход из цикла for или while. Если пара[
метр л указан, происходит выход из вложенных циклов
ps %ef I awk print $1 I
while read uid pid
do
if [$pid !eq $PID]
then
echo pid=$pid user=$uid
break
fi
done
cd Осуществляет переход в каталог Если параметр не
указан, происходит переход в домашний каталог
echo [string] Строка string выводится на стандартное устройство вы%
вода (терминал)
exec Выполняет программу runme, заменяя ею текущий ко%
мандный интерпретатор. Например, если в login shell
(командном интерпретаторе, запускаемом при регистра%
ции пользователя в системе) мы вызовем exec Is, то после
вывода имен файлов текущего каталога произойдет за%
вершение работы в системе
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
j obs
www.books-shop.com
Пользовательская UNIX 71
trap command
sig2
type name
unset var2 .
wait pad
Определяет команду command, которая будет выполнена
при получении сигналов, указанных в качестве аргументов
sig. См. раздел "Сигналы" ранее в этой главе
Показывает, как name будет интерпретироваться команд%
ным интерпретатором
Выводит или устанавливает значение пределов, ограничи%
вающих использование задачей системных ресурсов
(времени процессора, памяти, дискового пространства).
рассматриваться в главе 2
Устанавливает маску прав доступа для вновь создаваемых
файлов равной ппп
Удаляет переменные, указанные в качестве аргументов, из
списка определенных переменных командного интерпре%
татора. Некоторые переменные, например PATH, PS1,
PS2, не могут быть удалены
Ожидает завершения выполнения процесса с идентифи%
катором и возвращает его код возврата
Пользователь может определить функцию командного интерпретатора и
использовать ее как встроенную функцию shell. С другой стороны, функ!
ции мало отличаются от скриптов, включая синтаксис и передачу аргумен!
тов. Однако являясь частью shell, функции работают быстрее.
Синтаксис функции имеет следующий вид:
{
}
Как можно заметить, телом функции является обычный скрипт shell.
В качестве примера приведем функцию позволяющую отобразить в
приглашении shell имя текущего каталога.
mcd
{
cd
}
Подстановки, выполняемые командным интерпретатором
Прежде чем выполнить команду, указанную либо в командной строке, ли!
бо в скрипте, командный интерпретатор производит определенную после!
довательность действий:
1. Анализирует синтаксис команды. В случае, если обнаружена синтак!
сическая ошибка, выводится соответствующее сообщение. Естествен!
www.books-shop.com
72 Глава Работа в системе UNIX
но, shell анализирует командную строку в соответствии с синтаксисом
собственного языка, а не семантику вызова конкретной команды, на!
пример, наличие тех или иных аргументов.
2. Производит подстановки, а именно:
• Заменяет все указанные переменные их значениями.
Например, если значение переменной var равно то при
вызове команды find $var !name sh !print переменная
будет заменена ее значением. Другими словами, фактиче!
ский запуск команды будет иметь вид:
find /usr/bin !name sh !print
• Формирует списки файлов, заменяя шаблоны. При этом произ!
водится подстановка следующих шаблонов:
* — соответствует любому имени файла (или его части), кроме
начинающихся с символа '.',
[abc] — соответствует любому символу из перечисленных (а или
или с),
? — соответствует любому одиночному символу.
Делает соответствующие назначения потоков ввода/вывода. Если в
строке присутствуют символы перенаправления (>, <, |), shell
производит соответствующее перенаправление потоков. Программный
интерфейс ввода/вывода мы рассмотрим в разделе "Работа с файлами"
следующей главы.
4. Выполняет команду, передавая ей аргументы с выполненными подста!
новками. При этом:
• Если команда является функцией, определенной пользователем,
вызывается функция.
В противном случае, если команда является встроенной коман!
дой shell, запускается встроенная команда.
• В противном случае производится поиск программы в каталогах,
указанных переменной если имя команды задано без
пути. Если имя команды задано явно, т. е. содержит элементы
пути (относительный или абсолютный путь), производится за!
пуск программы. В случае, если программа не найдена, выво!
дится сообщение об ошибке.
Описанные подстановки, выполняемые интерпретатором, следует иметь в
виду при запуске команд. Например, запуск команды rm приведет к уда!
лению всех файлов данного каталога:
$ Вывести список файлов каталога
client
server
$ rm * Удалить файлы
$
$ Каталог пуст
www.books-shop.com
UNIX
Команда rm(l) без колебаний выполнит свою функцию, поскольку в каче!
стве аргументов она получит обычный список файлов. Замену символа '*'
на список всех файлов каталога произведет shell, и трудно догадать!
ся, что вы собираетесь удалить все файлы. Реальный же вызов rm(l) будет
иметь вид:
client server
Точно так же запускаемые программы ничего не знают о перенаправлении
потоков ввода/вывода, произведенных командным интерпретатором. На!
помним, что перенаправление ввода/вывода возможно лишь для стандарт!
ных потоков ввода, вывода и сообщений об ошибках. Впрочем, большин!
ство утилит UNIX используют только стандартные потоки.
Запуск команд
Как уже говорилось, запускаемые команды могут являться либо функция!
ми, определенными пользователем, либо встроенными командами интер!
претатора, либо исполняемыми файлами — прикладными программами и
утилитами. В любом случае, синтаксис их вызова одинаков.
Если необходимо запустить сразу несколько команд, это можно сделать в
одной строке, разделив команды символом ';'• Например:
$ date
Apr 18 1997 21:07
Заметим, что команды будут выполнены последовательно: сначала выпол!
нится команда которая выведет имя текущего каталога, а затем
которая покажет дату и время.
Можно запустить программу в фоновом режиме. В этом случае shell не бу!
дет ожидать завершения выполнения программы, а сразу выведет пригла!
шение, и вы сможете продолжить работу в командном интерпретаторе.
Для этого строку команды необходимо завершить символом '&':
$ find print &
$
Пока утилита find(l) производит поиск файла с именем скани!
руя файловую систему, вы сможете выполнить еще массу полезных дел,
например, отправить почту или распечатать документ на принтере. Мы
вернемся к этой схеме запуска программ далее в этой главе при обсужде!
нии системы управления заданиями.
Наконец, командный интерпретатор предоставляет возможность условного
запуска команд. Например, если необходимо выполнить команду только в
случае успешного завершения предыдущей, следует воспользоваться сле!
дующей синтаксической конструкцией:
& &
www.books-shop.com
74 Глава Работа в операционной системе UNIX
В качестве примера рассмотрим поиск имени пользователя в файле паро!
лей, и в случае успеха — поиск его имени в файле групп:
$ grep sergey grep sergey /etc/group
Успехом считается нулевой код возврата программы, неудачей — все дру!
гие значения.
Можно назначить выполнение команды только в случае неудачного за!
вершения предыдущей. Для этого команды следует разделить двумя сим!
волами
$ \ \ echo Команда завершилась неудачно
Приведенный синтаксис является упрощенной формой условного выраже!
ния. Командный интерпретатор имеет гораздо более широкие возможно!
сти проверки тех или иных условий, которые мы рассмотрим в следующем
разделе.
Условные выражения
Язык Bourne shell позволяет осуществлять ветвление программы, предос!
тавляя оператор if. Приведем синтаксис этого оператора:
if условие
then
fi
Команды commandl, и т. д. будут выполнены, если истинно ус!
ловие. Условие может генерироваться одной или несколькими командами.
По существу, ложность или истинность условия определяется кодом воз!
врата последней выполненной команды. Например:
if grep sergey
then
echo пользователь sergey найден в файле паролей
fi
Если слово sergey будет найдено программой grep(l) в файле паролей (код
возврата равен 0), то будет выведено соответствующее сообщение.
Возможны более сложные формы оператора if.
set Установим позиционные параметры равными значениям
полей вывода программы
if [ = ] Девятое поле вывода — предыдущий уровень выполнения
системы; символ означает однопользовательский режим
then
echo Система загружается
www.books-shop.com
Пользовательская UNIX
if [ = "2" ] Седьмое поле — текущий уровень
echo Переход на уровень выполнения 2
else
echo Переход на уровень выполнения 3
fi
Данный фрагмент скрипта проверяет уровень выполнения, с которого сис!
тема совершила переход, и текущий уровень выполнения системы. Соот!
ветствующие сообщения выводятся на консоль администратора. В этом
фрагменте условие генерируется командой test, эквивалентной (и более
наглядной) формой которой является Команда test является наиболее
распространенным способом генерации условия для оператора if.
Команда test
Команда test имеет следующий синтаксис:
test выражение
или
[ выражение ]
Команда вычисляет логическое выражение (табл. 1.10) и возвращает 0, ес!
ли выражение истинно, и 1 в противном случае.
Таблица 1.10. Выражения, используемые в команде test
Выражения с файлами
%s file Размер файла больше О
Для файла file разрешен доступ на чтение
%w file Для файла разрешен доступ на запись
%х Для файла разрешено выполнение
%f Файл существует и является обычным файлом
file Файл file является каталогом
%с file Файл file является специальным файлом символьного устройства
%b file Файл является специальным файлом блочного устройства
%р file Файл является поименованным каналом
file Файл file имеет установленный флаг
%g file Файл file имеет установленный флаг SGID
%k file Файл file имеет установленный флаг sticky bit
Выражения со строками
!z string Строка имеет нулевую длину
!n string string О
= string2 Две строки идентичны
stringl != string2 Две строки различны
www.books-shop.com
76 Глава Работа в операционной UNIX
Таблица 1.10 (продолжение)
Более сложные выражения могут быть образованы с помощью логических
операторов:
.' выражение Истинно, если выражение ложно (оператор NOT)
!а если оба выражения истинны (оператор AND)
!о Истинно, если хотя бы одно из выражений истинно
(оператор OR)
Приведем несколько примеров использования выражений.
Фрагмент скрипта, используемый при регистрации нового пользователя.
Скрипт проверяет наличие в домашнем каталоге
скрипта и в случае его отсутствия копирует шаблон:
if [ ! f ]
then
echo "файла не существует — скопируем шаблон"
ср
fi
Фрагмент скрипта, проверяющего наличие новой почты в почтовом ящике
пользователя
if [ s $MAIL ]
then
echo "Пришла почта"
fi
Фрагмент скрипта инициализации системы — запуска "суперсервера"
Internet Если исполняемый файл /etc/inetd существует, он за!
пускается на выполнение.
if [ х /etc/inetd ]
then
/etc/inetd
echo "запущен сервер
fi
Фрагмент скрипта, анализирующий ввод пользователя, сохраненный в пе!
ременной Если пользователь ввел или скрипт завершает
свою работу.
Сравнение целых чисел
— eq равно
11 %пе 12 не равно 12
12 11 строго меньше 12
11 %1е 11 меньше или равно 12
11 12 строго больше
%де 12 11 больше или равно 12
www.books-shop.com
UNIX 77
if [ = !о = ]
then
exit
f i
Циклы
Язык программирования Bourne shell имеет несколько операторов цикла.
Приведем их синтаксис:
1) while условие
do
done
2) until условие
do
commandl
done
3) for var in список
do
commandl
done
С помощью оператора while команды commandl, и т. д. будут
выполняться, пока условие не станет ложным. Как и в случае с операто!
ром if, условие генерируется кодом возврата команды, например, test.
В случае оператора until команды commandl, и т. д. будут вы!
полняться, пока условие не станет истинным.
Оператор for обеспечивает выполнение цикла столько раз, сколько слов в
списке. При этом переменная var последовательно принимает значения,
равные словам из списка. Список может формироваться различными спо!
собами, например как вывод некоторой команды
или с помощью шаблонов shell.
В другой форме for, когда список отсутствует, переменная var принимает
значения позиционных параметров, переданных скрипту.
Чтобы наглядно представить себе приведенные операторы, обратимся к
конкретным примерам.
Например, скрипт монтирования всех файловых систем для
системы Solaris 2.5 включает в себя их проверку, исходя из данных, ука!
занных в файле При этом используется оператор while.
www.books-shop.com
78 Глава 1. Работа в операционной системе UNIX
cat /etc/vfsck |
while read special fsckdev fstype fsckpass mntopts
Построчно считывает записи файла vfsck и присваивает переменным
# fsckdev и т. д. значения соответствующих конфигурационных
do
case $special in
' ' * | ' ' ) # Игнорируем комментарии
continue
tt Игнорируем строки, не требующие действия
continue
esac
Последовательно проверяем файловые системы с помощью утилиты
#
F $fstype $fsckdev >/dev/null 2>&1
done
Скрипт очистки давно не используемых файлов во временных каталогах
(обычно он запускается при загрузке системы) использует оператор for.
for dir in
do
find $dir ! type d +7 exec
done
При этом удаляются все файлы в указанных каталогах /usr/tmp и
последний доступ к которым осуществлялся более недели назад.
Селекторы
Оператор case предоставляет удобную форму селектора:
case слово in
command
command
esac
Значение слово сравнивается с шаблонами, начиная с первого. Если совпа!
дение найдено, то выполняются команды соответствующего раздела, кото!
рый заканчивается двумя символами ';'• Шаблоны допускают наличие масок,
которые были рассмотрены нами в разделе "Подстановки, выполняемые ко!
www.books-shop.com
Пользовательская среда UNIX 79
интерпретатором". Раздел с шаблоном аналогичен разделу default
в синтаксисе селектора switch языка С: если совпадения с другими шаблона!
ми не произошло, то будут выполняться команды раздела '*)'.
В качестве примера использования селектора приведем скрипт запуска и
останова системы печати в SCO UNIX.
state=$l
set
case $state in
if [ $9 = "2" o $9 = "3" ]
then
exit
fi
[ f ]
[ f ]
*)
echo "usage $0
esac
В случае, когда скрипт вызван с параметром start, будет произведен за!
пуск системы печати. Если параметр скрипта — stop, то система печати
будет остановлена. Запуск скрипта с любым другим параметром приведет к
выводу сообщения об ошибке.
Ввод
Как мы уже видели, присвоение значений переменным может осуществ!
ляться явно или с помощью вывода некоторой программы. Команда read
предоставляет удобный способ присвоить переменным значения, считан!
ные из стандартного потока ввода. Это может быть строка, введенная
пользователем или считанная из файла в случае перенаправления потока.
Команда read считывает строку из стандартного потока ввода и последова!
тельно присваивает переменным, переданным в качестве параметров, зна!
чения слов строки. Если число слов в строке превышает число перемен!
ных, то в последней переменной будут сохранены все оставшиеся слова.
Продемонстрируем это на простом примере:
Текст скрипта Запуск скрипта
$
echo "input: input: пример работы команды read
while read var2 var3
do
echo varl=$varl read
echo var2=$var2 еще пример
echo var3 = $var3
echo "input:
done var3=
$
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
80 Глава 1. Работа в операционной системе UNIX
В приведенном примере read в цикле считывает пользовательский ввод.
Цикл завершается, когда достигнут конец файла (что эквивалентно пользо!
вательскому вводу поскольку при этом read возвращает неуда!
чу (код возврата равен 1) и while завершает работу. В первом цикле число
введенных слов превышает количество переменных, поэтому значение пе!
ременной var3 состоит из двух слов. Во втором цикле значение var3 пусто.
Система управления заданиями
Командный интерпретатор может поддерживать управление заданиями.
Для Bourne shell который мы рассматриваем, систему управления
заданиями включает парный ему интерпретатор В остальном этот
интерпретатор имеет те же возможности.
В системе управления заданиями каждая команда (простая или составная),
которую пользователь запускает со своего терминала, называется заданием.
Все задания могут выполняться либо в текущем режиме, либо в фоновом
режиме, либо быть приостановлены. Задание в каждом из этих состояний
обладает рядом характеристик:
Состояние задания Характеристики
Выполняется в текущем режиме Задание может считывать данные и выводить
данные на терминал пользователя
Выполняется в фоновом режиме Заданию запрещен ввод с терминала. Возмож%
ность вывода на терминал определяется дополни%
тельными установками
Приостановлено Задание не выполняется
Каждое задание при запуске получает уникальный идентификатор, назы!
ваемый номером задания, который используется в командах системы управ!
ления. Синтаксис номера задания, применяемый в командах:
%
где может принимать следующие значения:
% или + Текущее задание — самое последнее запущенное или вновь запущен%
ное задание
Предыдущее задание (по отношению к текущему)
строка Задание, для которого строка присутствует в командной строке запуска
Задание с номером п
Задание, на которое можно уникально указать префиксом pref, на%
пример, команда ls(1), запущенная в фоновом режиме, адресуется за%
данием %ls
Система управления заданиями позволяет использовать следующие допол!
нительные команды:
www.books-shop.com
Пользовательская UNIX 81
bg
fg
jobs [!p | !1]
kill
stop
wait
Продолжает выполнение остановленного
задания в фоновом режиме. Без парамет[
ра относится к текущему заданию.
Продолжает выполнение остановленного
задания в текущем режиме. Если задание
выполнялось в фоновом режиме, ко[
манда перемещает его в текущий режим.
Выводит информацию об остановленных и
фоновых заданиях с указанными номера[
ми. Если последний аргумент опущен, вы[
водится информация обо всех остановлен[
ных и фоновых заданиях. Приведенные
ниже опции изменяют формат вывода:
[1 Вывести идентификатор группы про[
цессов и рабочий каталог.
Вывести только идентификатор группы
процессов.
Обеспечивает те же возможности, что и ко[
манда но по отношению к заданиям.
Останавливает выполнения фонового за[
дания.
Ожидает завершения выполнения задания
jobid и возвращает его код возврата.
Приведенный ниже пример иллюстрирует использование команд управле!
ния заданиями и не нуждается в комментариях:
$ &
[1] 9112
$
[2] 9113
$ jobs
[1] — Running
+ Running comml
$ stop %1
$ jobs
[1] — Stopped (signal) inf.j
[2] + Running comml
$ stop %%
$ jobs 1
[1]  9112 Stopped (signal)
[2] + 9113 Stopped (signal)
$ bg
[1] inf.j &
$ jobs
[1] + Running
[2] — Stopped (signal) comml
$ kill
$ jobs
inf.j (wd: /home/andy/SH/JOB)
comml (wd:
www.books-shop.com
82 Глава /. Работа в операционной системе UNIX
[1] +
[2] ! Done
$
Основные утилиты UNIX
В предыдущих разделах мы использовали некоторые утилиты UNIX. Ниже
приводятся краткие характеристики утилит, выпавших из поля нашего
зрения. Более подробно с различными утилитами можно познакомиться в
электронном справочнике
Утилиты для работы с файлами
Поле [opt] содержит конкретные опции каждой утилиты.
cd [dir] Изменяет текущий каталог. При задании без параметра —
производит переход в домашний каталог пользователя.
[opt] file2 Утилита cmp(1) сравнивает два файла, указанных в ка%
diff [opt] filel file2 аргументов. Если файлы одинаковы, никакого
сообщения не выводится. В противном случае выводятся
данные о первом несоответствии между этими файлами
(в данном примере первое различие найдено в 13%м
символе 4%й строки):
$ cat filel
1
2 3
7 8 9 10
11 12 13 14 15
$ cat file2
1
2 3
7 8 9 10
11 12 13 14 15 d i f f 2
$ cmp filel file2
filel file2 d i f f e r : char 13, line 4
Утилита также сравнивает два файла и выводит
список изменений, которые необходимо внести в содер%
жимое этих файлов для того, чтобы преобразовать первый
файл во второй. По существу, вывод утилиты пред%
ставляет собой команды редактора ed(1), необходимые
для преобразования filel в file2:
$ filel file2
За4
> diffl
< 11 12 13 14 15
> 11 12 13 14 15 diff2
www.books-shop.com
Пользовательская среда UNIX 83
ср [opt] filel file2
ср [opt] filel dir
[opt] filel file2
mv [opt] filel dir
[opt] filel...
[opt] filel file2
[opt] source target
mode] [!p]
dirl...
pwd
fgrep [opt]
filel...
grep [opt]
filel.
egrep
filel.
Утилита ср(1) служит для копирования файлов. При этом
создается не жесткая связь, а новый файл:
$ ср filel file2
$ filel file2
261425 1 andy user 49 Dec 24 filel
261427 1 andy user 49 Dec 24 file2
Утилита mv(1) изменяет имя файла.
Если последний параметр является каталогом, то число
аргументов утилит ср(1) или mv(1) может превышать 2. В
этом случае будет производиться копирование или пе%
ремещение указанных файлов в каталог.
Утилиты удаления файлов и каталогов. При этом удаля%
ются только записи имен файлов в соответствующих
каталогах, фактическое содержимое файла (мета%
данные и дисковые данные) будет удалено, если число
жестких связей для файла станет равным 0.
Без параметров утилита ls(1) выводит имена файлов
текущего каталога. В качестве параметров можно задать
имена каталогов, содержимое которых необходимо вы%
вести, или имена файлов, информацию о которых нужно
получить. Опции утилиты позволяют получить список
различной информативности и формата.
Утилита создает жесткую связь имени source с
файлом, адресуемым именем target. При использовании
опции %s будет создана символическая связь.
Создать каталог.
Вывести имя текущего каталога.
Утилиты поиска фрагментов текста в файлах. Могут ис%
пользоваться в качестве фильтров в программных каналах.
Для поиска подстроки в файлах можно использовать
самую простую из утилит fgrep(1) (fast grep).
Если подстрока поиска содержит пробелы или знаки
табуляции, ее необходимо заключить в кавычки. Если
подстрока уже содержит кавычки, их надо экранировать,
поместив символ непосредственно перед кавычками:
5 fgrep "рассмотрим в разделе chap*
Если вы хотите сделать поиск нечувствительным к за%
главным/строчным символам, используйте ключ !у. Для
поиска строк, не содержащих указанную подстроку, ис%
пользуется ключ !v.
Утилиты grep(1) и egrep(1) позволяют производить более
сложный поиск, например, когда вы не уверены в напи%
сании искомого слова, или хотите найти слова, распо%
ложенные в определенных местах файла. В этом случае
www.books-shop.com
84 Глава 1. Работа в операционной системе UNIX
в качестве подстроки поиска указывается регулярное
выражение
Например, чтобы произвести поиск слова "центр" в аме%
риканском (center) и британском (centre) написании,
можно задать следующую команду:
$ grep file
ИЛИ
$ grep file
[er] является регулярным выражением, соответствую%
щим либо символу ' либо ' Регулярное выраже%
ние должно быть заключено в кавычки для предотвра%
щения интерпретации специальных символов команд%
ным интерпретатором shell.
cat [opt] file Утилиты просмотра содержимого файла.
more [opt] e Команда cat file выводит содержимое файла file
head file терминала. Если у вас есть подозрение, что
tail [opt] file файл не текстовый, т. е. содержит "непечатные" симво%
лы, лучше запустить cat(1) с ключом !v. В этом случае
вывод таких символов (которые, кстати, могут нарушить
настройки вашего терминала) будет подавлен.
Если размер файла велик и его содержимое не поме%
щается в терминальном окне, удобнее будет воспользо%
ваться утилитами рд(1) и more(1), позволяющими выво%
дить файл порциями.
Посмотреть только начало (первые n строк) или конец
(последние n строк) файла можно с помощью утилит
head(1) и tail(1), соответственно.
Для сортировки строк файла используется утилита
Например, для сортировки текста в алфавитном
порядке необходимо ввести следующую команду:
$ sort file
Вы можете указать номер слова строки, по которому
необходимо произвести сортировку (точнее, номер поля
записи; по умолчанию записью является строка, а поля
разделены пробелами). Например, для сортировки строк
файла
Андрей Май
Борис Январь
Владимир Март
по месяцам, можно использовать команду
$ sort +1 file
в результате получим:
Борис Январь
Владимир Март
Андрей Май
www.books-shop.com
UNIX
Опция определяет сортировку по месяцам (не по ал%
фавиту), опция +1 указывает, что сортировку необходи%
мо проводить по второму полю каждой строки.
cut Позволяет отфильтровать указанные поля строк файла.
Разделитель полей указывается опцией %d<sep>. На%
пример, чтобы получить реальные имена пользователей
системы (пятое поле файла паролей), можно использо%
вать следующую команду:
$ cat /etc/passwd | cut !d:
WWW Administrator
Yuri Korenev
Serge Smirnoff
W3 group
Konstantin Fedorov
Andrei Robachevsky
Sergey Petrov
Позволяет вывести число строк, слов и символов текста
файла.
find [opt] Выполняет поиск файла в файловой системе UNIX, на%
чиная с каталога dir. Например, для вывода полного
имени исполняемого файла командного интерпретатора
Bourne shell введите команду:
$ find / !name sh !print 2>/dev/null
/usr/bin/sh
/sbin/sh
С помощью опции %name указывается имя искомого
файла, а с помощью опции %print — действие (вывести
полное имя).
С помощью find(1) можно производить поиск файлов по
другим критериям, например, размеру, последнему
времени модификации и т. д. Например, чтобы найти
файлы с именем core (образ процесса, создаваемый
при неудачном его завершении и используемый в целях
отладки), последнее обращение к которым было, ска%
жем, более месяца назад (скорее всего такие файлы не
нужны пользователям и только "засоряют" файловую
систему), можно задать команду:
$ find / !name core !atime +30 !print
www.books-shop.com
86 Глава Работа в операционной системе UNIX
Если вы сторонник жесткого администрирования, то
можно применить следующую команду:
$ / name core +30 exec
которая автоматически удалит все найденные файлы.
user file . Изменяет владельца%пользователя указанных файлов.
chgrp group file Изменяет владельца%группу указанных файлов.
mode file . Изменяет права доступа и дополнительные атрибуты
файлов.
. . . Сканирует начало файла и пытается определить его тип.
Если это текстовый файл (ASCII), file(1) пытается опре%
делить его синтаксис (текст, программа на С и т. д.).
Если это бинарный файл, то классификация ведется по
так называемому magic number, определения которого
находятся в файле /etc/magic.
$ file *
tar archive
report.doc: ascii text
work: directory
с program text
ELF 32bit MSB executable
figure.gif: data
Утилиты для управления процессами
nice % [ command Утилита применяется для запуска программы на
renice new nice полнение с относительным приоритетом (nice number), отлич%
от принятого по умолчанию. Например, ввод команды:
$ nice 10
приведет к запуску с большим значением
nice. В UNIX чем больше значение nice number, тем
меньший приоритет имеет процесс. Таким образом, при
планировании выполнения процессов вероятность того,
что ядро операционной системы выберет именно
для запуска, уменьшится. Как следствие,
big_program станет выполняться дольше, но будет ме%
нее интенсивно потреблять процессорные ресурсы.
Только администратор системы может повысить приори%
тет процесса (уменьшить значение nice number):
$ nice ! !10
Утилита renice(1) позволяет изменять приоритет процес%
са во время его выполнения. Например, команда
$ renice 5 1836
устанавливает значение nice number процесса с иден%
тификатором 1836 равным 5. Как и в случае команды
nice(1), увеличить приоритет процесса может только ад%
министратор системы.
www.books-shop.com
Пользовательская среда UNIX 87
ps
kill
Утилита ps(1) выводит информацию о существующих
процессах. При использовании различных опций она
позволяет получить следующую информацию:
F статус процесса (системный процесс,
блокировки в памяти и т. д.)
S состояние процесса (О — выполняется
процессором, S — находится в состоянии
сна, R — готов к выполнению, I — созда%
ется, Z — зомби)
идентификатор (имя) пользователя —
владельца процесса
идентификатор процесса
идентификатор родительского процесса
текущий динамический приоритет процес%
са
значение nice number процесса
управляющий терминал процесса ('?' —
означает отсутствие управляющего тер%
минала)
суммарное время выполнения процесса
процессором
время создания процесса (может отли%
чаться от времени запуска команды)
имя команды, соответствующей процессу
Посылает процессам с идентификаторами и
т. д. сигнал signo. Сигнал signo может быть указан как
в числовой, так и в символьной форме. Команда kill !I
выводит таблицу соответствия между символьными име%
нами сигналов и их числовыми значениями:
$ kill !I
UID
PID
PPID
PRI
TTY
TIME
COMMAND
1)
5)
9)
13) SIGPIPE
2)
6)
10)
14)
3)
7)
11)
15)
4)
8) SIGFPE
12) SIGSYS
16)
at [opt]
Таким образом, следующие две команды эквивалентны:
$ kill 9 18793
$ kill SIGKILL 18793
Утилита at(1) считывает команды стандартного потока
ввода и группирует их в задание at, которое будет вы%
полнено в указанное пользователем время. Для выпол%
нения задания будет запущен командный интерпретатор,
в среде которого и будут исполнены команды.
Например, следующая команда, позволит вам поздра%
вить друга с днем рождения в назначенное время:
www.books-shop.com
Глава Работа в операционной системе UNIX
$ at May 30
cat I elm Днем
Вы можете добавить опцию %т, и после выполнения за%
дания вам будет отправлено уведомление по электрон%
ной почте.
Об администрировании UNIX
Достаточно открыть оглавление любого "Руководства системного админи!
стратора" для UNIX, чтобы оценить то многообразие задач и проблем, с
которыми приходится сталкиваться при обслуживании системы:
Настройка жизненно важных для пользователей подсистем, таких
как файловая система, система печати и сетевая поддержка. Каждая
из них, в свою очередь, может быть разделена на десятки подзадач.
О Регистрация пользователей. Каждый новый пользователь добавляет
"забот" администратору системы, но какой же UNIX без пользовате!
лей!
Постоянный мониторинг системы и борьба с авариями. Причем, как
правило, неполадки возникают в самый неподходящий момент и
там, где их совсем не ждешь. Здесь от администратора потребуется
хорошее знание не только операционной системы, но и аппаратуры,
на которой она работает.
Настройка производительности системы.
Обучение, наставление, "ссоры" и "примирения" с пользователями
операционной системы, которую вы обслуживаете.
В этой книге вы не найдете практического руководства по администриро!
ванию системы. Вместо этого в следующих главах мы попытаемся взгля!
нуть на UNIX изнутри, понять как устроена эта система и как она работа!
ет. Может быть после этого вы посмотрите на руководства другими глаза!
ми, а администрирование системы не сведется к простому заучиванию
команд.
В качестве компенсации за отсутствие практического руководства предла!
гаю вашему вниманию перевод материала, найденный мною на одном из
WWW!серверов Internet, в котором приведена забавная классификация
системных администраторов.
Можно выделить четыре типа системных администраторов UNIX:
Технический бандит. Обычно в прошлом системный программист,
вынужденный заниматься системным администрированием. Пишет
88
www.books-shop.com
Пользовательская UNIX 89
скрипты на смеси языков интерпретатора Bourne shell, sed, С, awk,
perl и APL.
Администраторфашист. Обычно это законченный тунеядец (реже —
бывшая ведьма!секретарша), вынужденный заниматься системным
администрированием.
Маньяк. Стареющий хакер, обнаруживший, что ни ни Куба
не собираются достойно оплачивать его услуги по компьютерному
шпионажу, вследствие чего подавшийся в системные администраторы.
Идиот. Полный кретин или старый программист на Коболе, вы!
бранный в системные администраторы комитетом, состоящим из та!
ких же кретинов или старых программистов на Коболе.
Как определить, к какому типу принадлежит ваш системный админи!
стратор?
Ситуация Нехватка дискового пространства
Технический бандит. Пишет набор скриптов для мониторинга использова!
ния дискового пространства, для сопровождения базы данных статистики
использования диска, для прогнозирования будущего использования с по!
мощью регрессионного анализа, для выявления пользователей, которые
превысили стандартное отклонение от среднего значения и, наконец, для
отправления нарушителям почтовых сообщений. Помещает скрипты под
управление В результате свободное дисковое пространство не уве!
личивается, поскольку "дисковые обжоры" обычно не читают почту.
Администраторфашист. Помещает правила использования диска в сооб!
щение дня Активно пользуется квотированием дискового простран!
ства. Не допускает никаких исключений, чем полностью останавливает
деятельность разработчиков. Блокирует регистрацию пользователей, пре!
высивших квоту.
Маньяк: # cd /home
# !rf !s * | sort I head !1 | awk
Идиот: # cd /home
cat !s * | sort !rn | head !1 I awk printf
I compress
Ситуация 2. Избыточная загрузка процессора
Технический бандит. Пишет набор скриптов для мониторинга использова!
ния вычислительных ресурсов, для сопровождения базы данных статисти!
ки их использования, для выявления процессов, превысивших стандартное
значение и для изменения приоритета таких процессов. Помещает скрип!
ты под управление В результате понижения приоритета офисной
базы данных, предает ее забвению, ставя всю работу на грань срыва к не!
малой радости поклонников игры в
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
90 Глава I. Работа в операционной UNIX
Администраторфашист. Помещает правила использования вычислитель!
ных ресурсов в сообщение дня motd. Активно пользуется квотированием
процессорных ресурсов. Не допускает никаких исключений, чем полно!
стью останавливает деятельность разработчиков к немалой радости по!
клонников игры в
Маньяк: # kill !9 | sort !rn +8 !9 1 head !1 |
Идиот: # compress !augxww | sort !rn +8 !9 | head !1
I awk ' $2}
Ситуация З. Регистрация новых пользователей
Технический бандит. Пишет скрипт на языке Perl, создающий домашний
каталог пользователя, определяющий непонятное окружение и помещаю!
щий записи в файлы /etc/passwd, /etc/shadow и /etc/group. Устанавливает
на скрипт бит и обязывает секретаршу обеспечить регистрацию но!
вых пользователей. Поскольку обычно секретарша так и не может разо!
браться в разнице между и ни один новый пользователь
не зарегистрирован.
Администраторфашист. Помещает правила регистрации пользователей в
сообщение дня motd. Поскольку незарегистрированные пользователи не
могут прочитать это сообщение, никто не выполняет бюрократических
требований, и, как следствие, ни один новый пользователь не зарегистри!
рован.
Маньяк. "Если ты настолько глуп, что не можешь взломать машину и са!
мостоятельно зарегистрироваться, тебе нечего делать в моей системе. В
этом ящике и так слишком много придурков".
Идиот: # cd /home; mkdir home directory"
echo "Bob !f" >
/etc/passwd
Ситуация 4. Авария загрузочного диска
Технический бандит. Чинит диск. Обычно ему удается восстановить фай!
ловую систему прямо из приглашения загрузки. Если это не помогает, за!
пускает микроядро, которое запускает на соседнем компьютере скрипт,
копирующий на аварийную машину загрузочный код, переформатирую!
щий диск и инсталлирующий операционную систему. Оставляет скрипт
работать до конца уик!энда, а сам отправляется в поход в горы.
Администраторфашист. Начинает расследование аварии. Отказывается ис!
править аварию до тех пор, пока виновный не найден, и с него не взыска!
на стоимость сломанного оборудования.
www.books-shop.com
среда UNIX
Маньяк. Извлекает диск. С помощью кузнечного молота пытается подо!
гнать отдельные пластины. Звонит производителю. Во время установки
нового диска и операционной системы наносит оскорбления присланному
инженеру.
Идиот. Не замечает ничего необычного.
Ситуация 5. Слабая производительность сети
Технический бандит. Пишет скрипт для мониторинга сети, переписывает
программное обеспечение, чем повышает производительность на 2%. По!
жимает плечами, говорит: "Я сделал все, что мог", и отправляется в поход
в горы.
Администраторфашист. Помещает правила работы в сети в сообщение дня
Звонит в Беркли и в AT&T, приставая к ним, как установить сете!
вые квоты. Пытается уволить поклонников игры в xtrek.
Маньяк. Каждые два часа размыкает кабель Ethernet и ждет тайм!аута на
сетевых соединениях.
Идиот: # compress !f /dev/enO
Ситуация 6. "Глупые" вопросы пользователей
Технический бандит. Отвечает на вопросы в или дво!
ичном виде, иногда по!французски, пока пользователь не уходит.
Администраторфашист. Блокирует вход пользователя в систему, пока тот
не представит веские доказательства своей квалификации.
Маньяк: # cat cshrc
alias vi v BoZo > ~/.z;
f
Идиот. Отвечает на все вопросы в меру своего понимания. Приглашает
пользователя в группу администрирования системы.
Ситуация 7. Установка новой версии операционной системы
Технический бандит. Изучает исходные тексты новой версии и выбирает из
них только то, что ему нравится.
Администраторфашист. В первую очередь изучает законодательные акты про!
тив производителя, поставляющего программное обеспечение с ошибками.
Маньяк: # uptime
l:33pm up 19 days, 2 2 : 4 9 , users, load average: 6 . 4 9 ,
6.45, 6.31
www.books-shop.com
92 Глава Работа в операционной системе UNIX
wall
Итак, настало время установки новой версии. Займет
несколько часов, и если нам повезет — управимся к 500. Мы
работаем для
Идиот: #
Ситуация 8. Пользователям необходима электронная телефонная книга
Технический бандит. Пишет программу на RDBMS, perl и Smalltalk. Отча!
явшиеся пользователи возвращаются к использованию записных книжек.
Администраторфашист. Устанавливает Oracle. Отчаявшиеся пользователи
возвращаются к использованию записных книжек.
Маньяк. Предлагает пользователям хранить данные в едином сплошном
файле и применять grep(l) для поиска телефонных номеров.
Идиот: % dd ibs=80 if=/dev/rdisk001s7 | grep "Fred"
Заключение
Эта глава знакомит с пользовательской средой UNIX, а также с основны!
ми подсистемами этой операционной системы — файловой подсистемой,
подсистемой управления процессами и памятью, и с подсистемой вво!
да/вывода.
Большое внимание уделено командному интерпретатору shell, и его языку
программирования. Это, как вы убедились, достаточно мощный инстру!
мент, который, в частности, используется при администрировании систе!
мы и конфигурации процесса инициализации UNIX. В конце главы при!
ведены наиболее распространенные утилиты, которые можно найти в лю!
бой версии UNIX.
www.books-shop.com
программирования
UNIX
Одной из целей, которые изначально ставились перед разработчиками
UNIX, являлось создание удобной среды программирования. Во многом
это справедливо и сегодня.
Разговор в данной главе пойдет о программировании в UNIX. Может по!
казаться, что предлагаемый материал интересен лишь разработчикам про!
граммного обеспечения. Это не совсем так. Безусловно, разработка про!
грамм невозможна без знания интерфейса системных вызовов и без пони!
мания внутренних структур и функций, предоставляемых операционной
системой. Однако осмысленное администрирование системы также за!
труднительно без представления о том, как работает UNIX. Программный
интерфейс UNIX позволяет наглядно показать внутренние механизмы
этой операционной системы.
В начале главы дана общая характеристика программного интерфейса
UNIX и связанной с ним среды разработки; затронуты такие важные те!
мы, как обработка ошибок, различия между системными вызовами и
функциями стандартных библиотек, форматы исполняемых файлов и раз!
мещение образа программы в памяти; также описано, как происходит за!
пуск и завершение программы с точки зрения программиста.
Следующие два раздела посвящены подробному обсуждению программ!
ного интерфейса двух важнейших подсистем операционной системы
UNIX: файловой подсистемы и подсистемы управления процессами и па!
мятью. В них рассматриваются важнейшие системные вызовы работы с фай!
лами, функции стандартной библиотеки ввода/вывода, системные вызовы
создания процесса, запуска новой программы и управления процессами.
В заключение приводятся два типичных приложения: демон и командный
интерпретатор, на примере которых проиллюстрированы темы, затронутые
в данной главе.
Программный интерфейс UNIX
Системные вызовы и функции стандартных библиотек
Все версии UNIX предоставляют строго определенный ограниченный на!
бор входов в ядро операционной системы, через которые прикладные за!
www.books-shop.com
94 Глава 2. Среда программирования UNIX
дачи имеют возможность воспользоваться базовыми услугами, предостав!
ляемыми UNIX. Эти точки входа получили название системных вызовов
(system calls). Системный вызов, таким образом, определяет функцию, вы!
полняемую ядром операционной системы от имени процесса, выполнив!
шего вызов, и является интерфейсом самого низкого уровня взаимодейст!
вия прикладных процессов с ядром. Седьмая редакция UNIX включала
около 50 системных вызовов, современные версии, например, SVR4, пред!
лагают более 120.
Системные вызовы обычно документированы в разделе 2 электронного
справочника. В среде программирования UNIX они определяются как
функции С, независимо от фактической реализации вызова функции ядра
операционной системы. В UNIX используется подход, при котором каж!
дый системный вызов имеет соответствующую функцию (или функции) с
тем же именем, хранящуюся в стандартной библиотеке языка С (в даль!
нейшем эти функции будем для простоты называть системными вызова!
ми). Функции библиотеки выполняют необходимое преобразование аргу!
ментов и вызывают требуемую процедуру ядра, используя различные
приемы. Заметим, что в этом случае библиотечный код выполняет только
роль оболочки, в то время как фактические инструкции расположены в
ядре операционной системы.
Помимо системных вызовов программисту предлагается большой набор
функций общего назначения. Эти функции не являются точками входа в
ядро операционной системы, хотя в процессе выполнения многие из них
выполняют системные вызовы. Например, функция использует
системный вызов для записи данных в файл, в то время как функ!
ции strcpy(3C) (копирование строки) или (преобразование символа
в его числовое значение) вообще не прибегают к услугам операционной
системы. Функции, о которых идет речь, хранятся в стандартных библио!
теках С и наряду с системными вызовами составляют основу среды про!
граммирования в UNIX. Подробное описание этих функций приведено в
разделе 3 электронного справочника.
Таким образом, часть библиотечных функций является "надстройкой" над
системными вызовами, обеспечивающей более удобный способ получения
системных услуг. В качестве примера рассмотрим процесс получения те!
кущей даты и времени. Соответствующий системный вызов воз!
вращает время в секундах, прошедшее с момента Epoch: 1 января 1970 го!
да. Дополнительная интерпретация этого значения, такая как преобразо!
вание в вид, удобный для восприятия (дата и время) с учетом временной
зоны, осуществляется библиотечными функциями
и т. д.). К этим функциям можно отнести функции библиотеки вво!
да/вывода, функции распределения памяти, часть функций управления
процессами и т. д.
www.books-shop.com
Программный интерфейс UNIX 95
На рис. 2.1 показана схема взаимодействия приложения с ядром операци!
онной системы при использовании системных вызовов и библиотечных
функций.
Процесс
Интерфейс
системных
вызовов
Рис. Системные вызовы и библиотечные функции
Обработка ошибок
В предыдущем разделе мы обсудили разницу между системными вызовами
и библиотечными функциями. Они также различаются по способу переда!
чи процессу информации об ошибке, произошедшей во время выполнения
системного вызова или функции библиотеки.
Обычно в случае возникновения ошибки системные вызовы возвращают
и устанавливают значение переменной errno, указывающее причину воз!
никновения ошибки. Так, например, существует более десятка причин за!
вершения вызова с ошибкой, и все они могут быть определены с
помощью переменной errno. Файл заголовков <errno.h> содержит коды
ошибок, значения которых может принимать переменная errno, с кратки!
ми комментариями.
Библиотечные функции, как правило, не устанавливают значение пере!
менной errno, а код возврата различен для разных функций. Для уточне!
ния возвращаемого значения библиотечной функции необходимо обра!
титься к электронному справочнику
Поскольку базовым способом получения услуг ядра являются системные
вызовы, рассмотрим более подробно обработку ошибок в этом случае.
Переменная errno определена следующим образом:
external int errno;
www.books-shop.com
96 Глава 2. программирования UNIX
Следует обратить внимание, что значение не обнуляется следующим
нормально завершившимся системным вызовом. Таким образом, значение
errno имеет смысл только после системного вызова, который завершился с
ошибкой.
Стандарт ANSI С определяет две функции, помогающие сообщить причи!
ну ошибочной ситуации: и
Функция имеет вид:
ttinclude <string.h>
char
Функция принимает в качестве аргумента errnum номер ошибки и возвра!
щает указатель на строку, содержащую сообщение о причине ошибочной
ситуации.
Функция объявлена следующим образом:
<errno.h>
void char
Функция выводит в стандартный поток сообщений об ошибках информа!
цию об ошибочной ситуации, основываясь на значении переменной errno.
Строка s, передаваемая функции, предваряет это сообщение и может слу!
жить дополнительной информацией, например содержа название функции
или программы, в которой произошла ошибка.
Следующий пример иллюстрирует использование этих двух функций:
<errno.h>
<stdio.h>
argc, char
{
errno =
perror (argv [ )
}
Запустив программу, мы получим следующий результат на экране:
$
ENOMEM: Not enough space
Exec format error
Эти функции используются, в частности, командным интерпретатором и
большинством стандартных утилит UNIX. Например:
$
No such file or directory ошибка ENOENT
$ pg
do_not_read: Permission denied ошибка EACCESS
$
www.books-shop.com
Программный интерфейс UNIX 97
В табл. 2.1 приведены наиболее общие ошибки системных вызовов, вклю!
чая сообщения, которые обычно выводят функции и
а также их краткое описание.
Таблица 2.1. Некоторые ошибки системных вызовов
Код ошибки и сообщение Описание
E2BIG
Arg list too long
Размер списка аргументов, переданных систем%
ному вызову плюс размер экспортируе%
мых переменных окружения превышает ARG_MAX
байт
EACCESS
Permission denied
Попытка доступа к файлу с недостаточными пра%
вами для данного класса (определяемого эффек%
тивным и GID процесса и соответствующими
идентификаторами файла)
EAGAIN
Resource temporarily unavailable
Превышен предел использования некоторого ре%
сурса, например, переполнена таблица процессов
или пользователь превысил ограничение по коли%
честву процессов с одинаковым UID. Причиной
также может являться недостаток памяти или
превышение соответствующего ограничения (см.
раздел "Ограничения" далее в этой главе)
EALREADY
Operation already in progress
Попытка операции с неблокируемым объектом,
уже обслуживающим некоторую операцию
EBADF
Bad file number
Попытка операции с файловым дескриптором, не
адресующим никакой файл; также попытка опе%
рации чтения или записи с файловым дескрипто%
ром, полученным при открытии файла на запись
или чтение, соответственно
EBADFD
File descriptor in bad state
Файловый дескриптор не адресует открытый
файл или попытка операции чтения с файловым
дескриптором, полученным при открытии файла
только на запись
EBUSY
Device busy
Попытка монтирования устройства (файловой
системы), которое уже примонтировано; попытка
размонтировать файловую систему, имеющую
открытые файлы; попытка обращения к недоступ%
ным ресурсам (семафоры, блокираторы и т. п.)
ECHILD
No child processes
Вызов функции процессом, не имеющим
дочерних процессов или процессов, для которых
уже был сделан вызов
EDQUOT
Disk quota exceeded
Попытка записи в файл, создание каталога или
файла при превышении квоты пользователя на
дисковые блоки, попытка создания файла при
превышении пользовательской квоты на число
inode
www.books-shop.com
98 Глава 2. программирования UNIX
Таблица 2.1 (продолжение)
Код ошибки и Описание
EEXIST
File exists
Имя существующего файла использовано в недо%
пустимом контексте, например, сделана попытка
создания символической связи с именем уже
существующего файла
EFAULT
Bad address
Аппаратная ошибка при попытке использования
системой аргумента функции, например, в каче%
стве указателя передан недопустимый адрес
EFBIG
File too large
Размер файла превысил установленное ограни%
чение RLIMIT_FSIZE или максимально допусти%
мый размер для данной файловой системы (см.
раздел "Ограничения" далее в этой главе)
EINPROGRESS
Operation now in progress
Попытка длительной операции (например, уста%
новление сетевого соединения) для неблокируе%
мого объекта
EINTR
Interrupted system call
Получение асинхронного сигнала, например, сиг%
нала SIGINT или во время обработки сис%
темного вызова. Если выполнение процесса будет
продолжено после обработки сигнала, прерванный
системный вызов завершится с этой ошибкой
EINVAL
Invalid argument
Передача неверного аргумента системному вызо%
ву. Например, размонтирование устройства (фай%
ловой системы), которое не было примонтирова%
но. Другой пример — передача номера несущест%
вующего сигнала системному вызову kill(2)
ЕЮ
I/O error
Ошибка физического устройства
EISDIR
Is a directory
Попытка операции, недопустимой для каталога,
например, запись в каталог с помощью вызова
ELOOP
Number of symbolic links encoun%
tered during path name traversal
exceeds
При попытке трансляции имени файла было обна%
ружено недопустимо большое число символических
связей, превышающее значение MAXSYMLINKS
EMFILE
Too many open files
Число открытых файлов для процесса превысило
максимальное значение OPEN MAX
File name too long
Длина полного имени файла (включая путь) пре%
высила максимальное значение PATH MAX
File table overflow
Переполнение файловой таблицы
ENODEV
No such device
Попытка недопустимой операции для устройства. На%
пример, попытка чтения устройства только для записи
или операция для несуществующего устройства
www.books-shop.com
Программный интерфейс UNIX 99
Таблица 2.1 (продолжение)
Код ошибки и сообщение Описание
ENOENT
No such file or directory
Файл с указанным именем не существует или
отсутствует каталог, указанный в полном имени
файла
ENOEXEC
Exec format error
Попытка запуска на выполнение файла, который
имеет права на выполнение, но не является фай%
лом допустимого исполняемого формата
ENOMEM
Not enough space
При попытке запуска программы или
размещения памяти размер запрашивае%
мой памяти превысил максимально возможный в
системе
No message of desired type
Попытка получения сообщения определенного
типа, которого не существует в очереди (см. раз%
дел "Сообщения" в главе 3)
ENOSPC
No space left on device
Попытка записи в файл или создания нового ка%
талога при отсутствии свободного места на уст%
ройстве (в файловой системе)
ENOSR
Out of stream resources
Отсутствие очередей или головных модулей при
попытке открытия устройства STREAMS. Это со%
стояние является временным. После освобожде%
ния соответствующих ресурсов другими процес%
сами операция может пройти успешно
ENOSTR
Not a stream device
Попытка применения операции, определенной
для устройств типа STREAMS (например систем%
ного вызова putmsg(2) или для устрой%
ства другого типа
ENOTDIR
Not a directory
В операции, предусматривающей в качестве ар%
гумента имя каталога, было указано имя файла
другого типа (например, в пути для полного имени
файла)
ENOTTY
Inappropriate for device
Попытка системного вызова ioctl(2) для устройст%
ва, которое не является символьным
EPERM
Not owner
Попытка модификации файла, способом, разре%
шенным только владельцу и суперпользователю и
запрещенным остальным пользователям. Попыт%
ка операции, разрешенной только суперпользо%
вателю
EPIPE
Broken pipe
Попытка записи в канал (pipe), для которого не
существует процесса, принимающего данные. В
этой ситуации процессу обычно отправляется со%
ответствующий сигнал. Ошибка возвращается при
сигнала
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 2. Среда программирования UNIX
Таблица 2.1 (окончание)
Код ошибки и сообщение Описание
EROFS Попытка модификации файла или каталога для
Read%only file system устройства (файловой системы), примонтирован%
ного только на чтение
ESRCH Процесс с указанным PID не существует в системе
No such process
Создание программы
Создание любой программы обычно начинается с базовой идеи (но не все!
гда), разработки ее блок!схемы (современные программисты часто пропус!
кают этот этап), интерфейса пользователя (весьма ответственный процесс) и
написания исходного текста. Далее следуют этапы компиляции и отладки.
В этом разделе рассмотрен процесс создания написанного на
языке С и разработанного для операционной системы UNIX. Предвидя
обвинения в архаизме, мы все!таки остановимся на добротном ANSI С и
базовой среде разработки UNIX, во!первых, полагая, что старый друг
лучше новых двух, а во!вторых потому, что объектом нашего обсуждения
все же является UNIX, а не современные средства создания приложений.
Заметим также, что язык программирования С является "родным" языком
UNIX, поскольку ядро операционной системы написано на этом
Это, безусловно, не ограничивает возможности других языков и техноло!
гий программирования, которые сегодня, наверное, используются даже
чаще, чем обсуждаемый нами традиционный подход.
Опустим также процесс рождения базовой идеи и разработку блок!схем,
полагая, что все это уже сделано. Итак, начнем с исходного текста буду!
щей программы.
Исходный текст
Исходные тексты программы, разработанной для UNIX, по большому сче!
ту мало отличаются от текстов приложений, создаваемых для других опе!
рационных систем. Можно сказать уверенно, что синтаксис языка опреде!
ляется не операционной системой. Все, что вам потребуется, это хорошее
знание самого языка и особенностей системы UNIX, а именно — ее сис!
темных вызовов.
Несмотря на то, что многие современные версии UNIX (особенно коммерческие) постав!
ляются без исходных текстов, основная часть кода ядра в них получена компиляции
С!модулей.
www.books-shop.com
программы 101
Во!первых, не забудьте включить в исходный текст необходимые файлы
заголовков. Во!вторых, уточните синтаксис вызова библиотечных и сис!
темных функций. В!третьих, используйте их по назначению. В!четвертых,
не пренебрегайте комментариями.
В этом (за исключением, пожалуй, четвертого совета) вам помогут элек!
тронный справочник ваш опыт, и, надеюсь, эта книга.
Заголовки
Использование системных функций обычно требует включения в текст
программы файлов содержащих определения — чис!
ло передаваемых аргументов, типы аргументов и возвращаемого значения.
Большинство системных файлов заголовков расположены в каталогах
или Если вы планируете использовать мало!
знакомую системную функцию, будет нелишним изучить соответствующий
раздел электронного справочника тап(1). Там же, помимо описания фор!
мата функции, возвращаемого значения и особых ситуаций, вы найдете
указание, какие файлы заголовков следует включить в программу.
Файлы заголовков включаются в программу с помощью директивы
#include. При этом, если имя файла заключено в угловые скобки (<>), это
означает, что поиск файла будет производиться в общепринятых каталогах
хранения файлов заголовков. Если же имя файла заголовка заключено в
кавычки, то используется явно указанное абсолютное или относительное
имя файла.
Например, системный вызов creat(2) служащий для создания обычного
файла, объявлен в файле <fcntl.h> следующим образом:
linclude
ttinclude <sys/stat.h>
<fcntl.h>
int char
Включение в исходный текст прототипа системного вызова creat(2) позво!
ляет компилятору произвести дополнительную проверку правильности ис!
пользования этой функции, а именно — числа аргументов и их типов.
Можно заметить, что наряду со стандартными типами языка С, например
char, для второго аргумента используется производный тип —
В ранних версиях UNIX большинство системных вызовов исполь!
зовали стандартные типы, например, creat(2) для второго аргумента охотно
принимала тип int. Производные типы переменных, имеющие окончание
_t, которые вы в большом количестве встретите при программировании в
UNIX, получили название примитивов системных данных. Большинство
этих типов определены в файле <sys/types.h>, а их назначение заключает!
ся в улучшении переносимости написанных программ. Вместо конкретных
типов данных, каковыми являются int, char и т. п., приложению предлага!
www.books-shop.com
102 Глава 2. UNIX
ется набор системных типов, гарантированно неизменных в контексте сис!
темных вызовов. Другими словами, во всех версиях UNIX сегодня и спустя
десять лет, системный вызов creat(2) в качестве второго аргумента будет
принимать переменную типа mode_t. Фактический размер переменных
этого типа может быть разным для различных версий системы, но это от!
разится в изменении соответствующего файла заголовков и потребует
только перекомпиляции вашей программы.
Среда программирования UNIX определяется несколькими стандартами,
обсуждавшимися во введении, и может незначительно различаться для
разных версий системы. В частности, стандарты ANSI С, POSIX. 1 и XPG4,
определяют названия и назначения файлов заголовков, приведенных
в табл. 2.2.
Таблица 2.2. Стандартные файлы заголовков
Файл заголовка Назначение
Содержит прототип функции используемой для
диагностики
<cpio.h> Содержит определения, используемые для файловых архи%
вов cpio(1)
Содержит определения символьных типов, а также прототи%
пы функций определения классов символов (ASCII, печат%
ные, цифровые и т. д.) — isdigit(3C) и
<dirent.h> Содержит определения структур данных каталога, а также
прототипы функций работы с каталогами
и т. д.
<errno.h>
<fcntl.h>
<ftw.h>
Содержит определения кодов ошибок (см. раздел "Обра%
ботка ошибок" в начале главы)
Содержит прототипы системных вызовов open(2) и
creat(2), а также определения констант и структур данных,
необходимых при работе с файлами
Содержит определения констант, необходимых для опера%
ций с плавающей точкой
Содержит прототипы функций, используемых для сканиро%
вания дерева файловой системы (file tree walk) ftw(3C) и
nftw(3C), a также определения используемых констант
<grp.h> Содержит прототипы функций и определения структур дан%
ных, используемых для работы с группами пользователей:
getgrnam(3C), getgrgid(3C) и т. д.
<langinfo.h> Содержит определения языковых констант: дни недели,
названия месяцев и т. д., а также прототип функции
www.books-shop.com
программы ЮЗ
Таблица 2.2 (продолжение)
Файл
<limits.h>
<locale.h>
<math.h>
<regex.h>
<search.h>
<setjmp.h>
<signal.h>
<stdarg.h>
<stddef.h>
<stdio.h>
<stdlib.h>
<string.h>
<tar.h>
Назначение
Содержит определения констант, определяющих значения
ограничений для данной реализации: минимальные и мак%
симальные значения основных типов данных, максимальное
значение файловых связей, максимальная длина имени
файла и т. д.
Содержит определения констант, используемых для созда%
ния пользовательской среды, зависящей от языковых и
культурных традиций (форматы дат, денежные форматы и
т. д.), а также прототип функции setlocale(3C)
Содержит определения математических констант (я, е, и
Содержит определения для каталогов сообщений (message
catalog), а также прототипы функций catopen(3C) и
catclose(3C)
Содержит определение структуры файла паролей
/etc/passwd, а также прототипы функций работы с ним:
getpwnam(3C), getpwent(3C), и т. д.
Содержит определения констант и структур данных, исполь%
зуемых в регулярных выражениях, а также прототипы функ%
ций для работы с ними: и т. д.
Содержит определения констант и структур данных, а также
прототипы функций, необходимых для поиска: hsearch(3C),
hcreate(3C),
Содержит прототипы функций перехода setjmp(3C),
siglongjmp(3C), a также опреде%
ления связанных с ними структур данных
Содержит определения констант и прототипы функций, не%
обходимых для работы с сигналами:
sigemptyset(3C), и т. д. (см. раздел "Сигналы"
далее в этой главе)
Содержит определения, необходимые для поддержки спи%
сков аргументов переменной длины
Содержит стандартные определения (например size_t)
Содержит определения стандартной библиотеки вво%
Содержит определения стандартной библиотеки
Содержит прототипы функций работы со строками
string(3C), strcasecmp(3C), strcat(3C), strcpy(3C) и т. д.
Содержит определения, используемые для файловых архи%
вов tar(1)
www.books-shop.com
704 Глава 2. программирования UNIX
Таблица 2.2 (продолжение)
Файл заголовка Назначение
<termios.h> Содержит определения констант, структур данных и прото%
типы функций для обработки терминального
<time.h> Содержит определения типов, констант и прототипы функ%
ций для работы со временем и датами: time(2), ctime(3C),
localtime(3C), tzset(3C), а также определения, относящиеся
к таймерам getitimer(2), setitimer(2). Таймеры будут рас%
смотрены в главе 3
<ulimit.h> Содержит определения констант и прототип системного
вызова ulimit(2) для управления ограничениями, наклады%
ваемыми на процесс. См. также раздел "Ограничения" да%
лее в этой главе
<unistd.h> Содержит определения системных символьных констант, а
также прототипы большинства системных вызовов
<utime.h> Содержит определения структур данных и прототип систем%
ного вызова utime(2) для работы с временными характери%
стиками файла (временем доступа и модификации)
<sys/ipc.h> Содержит определения, относящиеся к системе межпро%
цессного взаимодействия (IPC), которые рассматриваются в
главе 3
<sys/msg.h> Содержит определения, относящиеся к (сообщениям) под%
системе IPC. См. также раздел "Сообщения" главы 3
<sys/resource.h> Содержит определения констант и прототипы системных
вызовов управления размерами ресурсов, доступных про%
цессу: getrlimit(2) и setrlimit(2). Более подробно ограничения
на ресурсы обсуждаются в разделе "Ограничения" далее в
этой главе
<sys/sem.h> Содержит определения, относящиеся к (семафорам) под%
системе IPC. См. также раздел "Семафоры" главы 3
<sys/shm.h> Содержит определения, относящиеся к (разделяемой памя%
ти) подсистеме IPC. См. также раздел "Разделяемая па%
мять" главы 3
<sys/stat.h> Содержит определения структур данных и прототипы сис%
темных вызовов, необходимых для получения информации
о файле: stat(2), lstat(2), Подробнее эти системные
вызовы рассмотрены в разделе "Метаданные файла" далее
в этой главе
<sys/times.h> Содержит определения структур данных и прототипа сис%
темного вызова times(2), служащего для получения стати%
стики выполнения процесса (времени выполнения в режиме
ядра, задачи и т. д.)
<sys/types.h> Содержит определения примитивов системных данных
www.books-shop.com
программы 105
Таблица 2.2 (окончание)
Файл заголовка Назначение
<sys/utsname.h> Содержит определения структур данных и прототип систем%
ного вызова используемого для получения имен
системы (компьютера, операционной системы, версии и
т.д.)
<sys/wait.h> Содержит определения констант и прототипы системных
вызовов используемых для синхрониза%
ции выполнения родственных процессов
Компиляция
Процедура создания большинства приложений является общей и приведе!
на на рис. 2.2.
Рис. 2.2. Схема компиляции программы
www.books-shop.com
2. программирования UNIX
Первой фазой является стадия компиляции, когда файлы с исходными
текстами программы, включая файлы заголовков, обрабатываются компи!
лятором сс(1). Параметры компиляции задаются либо с помощью файла
(или Makefile), либо явным указанием необходимых опций ком!
пилятора в командной строке. В итоге компилятор создает набор проме!
жуточных объектных файлов. Традиционно имена созданных объектных
файлов имеют суффикс
На следующей стадии эти файлы с помощью редактора связей связы!
ваются друг с другом и с различными библиотеками, включая стандартную
библиотеку по умолчанию и библиотеки, указанные пользователем в каче!
стве параметров. При этом редактор связей может выполняться в двух ре!
жимах: статическом и динамическом, что задается соответствующими оп!
циями. В статическом, наиболее традиционном режиме связываются все
объектные модули и статические библиотеки (их имена имеют суффикс
производится разрешение всех внешних ссылок модулей и создается
единый исполняемый файл, содержащий весь необходимый для выполне!
ния код. Во втором случае, редактор связей по возможности подключает
разделяемые библиотеки (имена этих библиотек имеют суффикс В
результате создается исполняемый файл, к которому в процессе запуска на
выполнение будут подключены все разделяемые объекты. В обоих случаях
по умолчанию создается исполняемый файл с именем
Для достаточно простых задач все фазы автоматически выполняются вызо!
вом команды:
$ make prog
или эквивалентной ей
$ !о prog
которые создают исполняемый файл с именем prog. В этом случае умалчи!
ваемое имя исполняемого файла изменено на prog с помощью оп!
ции !о.
Впрочем, указанные стадии можно выполнять и раздельно, с использова!
нием команд и Заметим, что на самом деле команда явля!
ется программной оболочкой и компилятора и редактора связей, которую
и рекомендуется использовать при создании программ.
Проиллюстрируем процесс создания более сложной программы с помо!
щью конкретных вызовов команд.
$ %с f с f ile2 . с Создадим промежуточные объектные
файлы и file2.o
$ %о prog filel.o Создадим исполняемый файл с именем
prog, используя промежуточные объ%
ектные файлы и библиотеку или
www.books-shop.com
программы /07
Форматы исполняемых файлов
Виртуальная память процесса состоит из нескольких сегментов или облас!
тей памяти. Размер, содержимое и расположение сегментов в памяти оп!
ределяется как самой программой, например, использованием библиотек,
размером кода и данных, так и форматом исполняемого файла этой про!
граммы. В большинстве современных операционных систем UNIX исполь!
зуются два стандартных формата исполняемых файлов — COFF (Common
Object File Format) и ELF (Executable and Linking Format).
Описание форматов исполняемых файлов может показаться лишним, одна!
ко представление о них необходимо для описания базовой функционально!
сти ядра операционной системы. В частности, информация, хранящаяся в
исполняемых файлах форматов COFF и ELF позволяет ответить на ряд во!
просов весьма важных для работы приложения и системы в целом:
Какие части программы необходимо загрузить в память?
Как создается область для неинициализированных данных?
П Какие части процесса должны быть сохранены в дисковой области
свопинга (специальной области дискового пространства, предназна!
ченной для временного хранения фрагментов адресного пространст!
ва процесса), например, при замещении страниц, а какие могут быть
при необходимости считаны из файла, и таким образом не требуют
сохранения?
П Где в памяти располагаются инструкции и данные программы?
П Какие библиотеки необходимы для выполнения программы?
П Как связаны исполняемый файл на диске, образ программы в памя!
ти и дисковая область свопинга?
На рис. 2.3 приведена базовая структура памяти для процессов, загружен!
ных из исполняемых файлов форматов COFF и ELF, соответственно. Хотя
расположение сегментов различается для этих двух форматов, основные
компоненты одни и те же. Оба процесса имеют сегменты кода (text), дан!
ных (data), стека (stack). Как видно из рисунка, размер сегментов данных и
стека может изменяться, а направление этого изменения определяется
форматом исполняемого файла. Размер стека автоматически изменяется
операционной системой, в то время как управление размером сегмента
данных производится самим приложением. Эти вопросы мы подробно об!
судим в разделе "Выделение памяти" далее в этой главе.
Сегмент данных включает инициализированные данные, копируемые в
память из соответствующих разделов исполняемого файла, и неинициали!
зированные данные, которые заполняются нулями перед началом выпол!
нения процесса. Неинициализированные данные часто называют сегмен!
том BSS.
www.books-shop.com
108 Глава 2. программирования UNIX
Рис. 2.3. Исполняемые образы программ форматов COFF и ELF
Формат ELF
Формат ELF имеет файлы нескольких типов, которые до сих пор мы на!
зывали по!разному, например, исполняемый файл или объектный файл.
Тем не менее стандарт ELF различает следующие типы:
1. Перемещаемый файл (relocatable хранящий инструкции и данные,
которые могут быть связаны с другими объектными файлами. Резуль!
татом такого связывания может быть исполняемый файл или разде!
ляемый объектный файл.
2. Разделяемый объектный файл (shared object file) также содержит инст!
рукции и данные, но может быть использован двумя способами. В
первом случае, он может быть связан с другими перемещаемыми фай!
лами и разделяемыми объектными файлами, в результате будет
создан новый объектный файл. Во втором случае, при запуске про!
граммы на выполнение операционная система может динамически
связать его с исполняемым файлом программы, в результате чего будет
создан исполняемый образ программы. В последнем случае речь идет
о разделяемых библиотеках.
Исполняемый файл хранит полное описание, позволяющее системе соз!
дать образ процесса. Он содержит инструкции, данные, описание не!
обходимых разделяемых объектных файлов, а также необходимую
символьную и отладочную информацию.
www.books-shop.com
программы
На рис. 2.4 приведена структура исполняемого файла, с помощью кото!
рого операционная система может создать образ программы и запустить
программу на выполнение.
Заголовок имеет фиксированное расположение в файле. Остальные ком!
поненты размещаются в соответствии с информацией, хранящейся в заго!
ловке. Таким образом заголовок содержит общее описание структуры фай!
ла, расположение отдельных компонентов и их размеры.
2.4. Структура исполняемого файла в формате ELF
Поскольку заголовок ELF!файла определяет его структуру, рассмотрим его
более подробно (табл. 2.4).
Таблица 2.3. Поля заголовка ELF%файла
Поле Описание
[ ] Массив байт, каждый из которых определяет некоторую общую харак%
теристику файла: формат файла номер версии, архитектуру
системы (32%разрядная или 64%разрядная) и т. д.
e_type Тип файла, поскольку формат ELF поддерживает несколько типов
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 2. Среда программирования UNIX
Таблица 2.3 (продолжение)
Поле
е shoff
Описание
Архитектура аппаратной платформы, для которой создан данный
файл. В табл. 2.4 приведены возможные значения этого поля
Номер версии ELF%формата. Обычно определяется как EV_CURRENC
(текущая), что означает последнюю версию
Виртуальный адрес, по которому системой будет передано управле%
ние после загрузки программы (точка входа)
e_phoff Расположение (смещение от начала файла) таблицы заголовков
программы
Расположение таблицы заголовков секций
е Размер заголовка
Размер каждого заголовка программы
e_phnum Число заголовков программы
e_shentsize Размер каждого заголовка сегмента (секции)
е Число заголовков сегментов (секций)
Расположение сегмента, содержащего таблицу строк
Значение
Таблица 2.4. Значения поля e_machine заголовка ELF%файла
Аппаратная платформа
ЕМ
ЕМ Sun SPARC
ЕМ 386 Intel 80386
ЕМ 68К Motorola 68000
ЕМ 88К Motorola 88000
ЕМ 486 Intel 80486
ЕМ 860 Intel i860
ЕМ MIPS MIPS RS3000 Big%Endian
EM MIPS RS3 LE MIPS RS3000
EM RS6000 RS6000
EM PA RISC PA%RISC
EM nCUBE
EM VPP500 Fujitsu VPP500
EM SPARC32PLUS Sun SPARC 32+
Информация, содержащаяся в таблице заголовков программы, указывает
ядру, как создать образ процесса из сегментов. Большинство сегментов
www.books-shop.com
программы
копируются (отображаются) в память и представляют собой соответствую!
щие сегменты процесса при его выполнении, например, сегменты кода
или данных.
Каждый заголовок сегмента программы описывает один сегмент и содер!
жит следующую информацию:
Тип сегмента и действия операционной системы с данным сегментом
Расположение сегмента в файле
Стартовый адрес сегмента в виртуальной памяти процесса
Размер сегмента в файле
П Размер сегмента в памяти
Флаги доступа к сегменту (запись, чтение, выполнение)
Часть сегментов имеет тип LOAD, предписывающий ядру при запуске
программы на выполнение создать соответствующие этим сегментам
структуры данных, называемые областями, определяющие непрерывные
участки виртуальной памяти процесса и связанные с ними атрибуты. Сег!
мент, расположение которого в ELF!файле указано в соответствующем
заголовке программы, будет отображен в созданную область, виртуальный
адрес начала которой также указан в заголовке программы. К сегментам
такого типа относятся, например, сегменты, содержащие инструкции про!
граммы (код) и ее данные. Если размер сегмента меньше размера области,
неиспользованное пространство может быть заполнено нулями. Такой ме!
ханизм, в частности используется при создании неинициализированных
данных процесса (BSS). Подробнее об областях мы поговорим в главе 3.
В сегменте типа INTERP хранится программный интерпретатор. Данный
тип сегмента используется для программ, которым необходимо динамиче!
ское связывание. Суть динамического связывания заключается в том, что
отдельные компоненты исполняемого файла (разделяемые объектные фай!
лы) подключаются не на этапе компиляции, а на этапе запуска программы
на выполнение. Имя файла, являющегося динамическим редактором
хранится в данном сегменте. В процессе запуска программы на
ние ядро создает образ процесса, используя указанный редактор связей.
Таким образом, первоначально в память загружается не исходная про!
грамма, а динамический редактор связей. На следующем этапе динамиче!
ский редактор связей совместно с ядром UNIX создают полный образ ис!
полняемого файла. Динамический редактор загружает необходимые разде!
ляемые объектные файлы, имена которых хранятся в отдельных сегментах
исходного исполняемого файла, и производит требуемое размещение и
связывание. В заключение управление передается исходной программе.
Наконец, завершает файл таблица заголовков или секций (section).
Разделы (секций) определяют разделы файла, используемые для связывания
с другими модулями в процессе компиляции или при динамическом связы!
вании. Соответственно, заголовки содержат всю необходимую информацию
www.books-shop.com
Глава 2. программирования UNIX
для описания этих разделов. Как правило разделы содержат более детальную
информацию о сегментах. Так, например, сегмент кода может состоять из
нескольких разделов, таких как хэш!таблица для хранения индексов исполь!
зуемых в программе символов, раздел кода програм!
мы, таблица связывания, используемая динамическим редактором, а также
раздел, содержащий собственно инструкции программы.
Мы еще вернемся к формату ELF в главе 3 при обсуждении организации
виртуальной памяти процесса, а пока перейдем к следующему распростра!
ненному формату — COFF.
COFF
На рис. 2.5 приведена структура исполняемого файла формата COFF. Ис!
полняемый файл содержит два основных заголовка — заголовок COFF и
стандартный заголовок системы UNIX — Далее следуют заголовки
разделов и сами разделы файла, в которых хранятся инструкции и данные
программы. Наконец, в файле также хранится символьная информация,
необходимая для отладки.
Рис. 2.5. Структура исполняемого файла в формате COFF
В файле находятся только инициализированные данные. Поскольку не!
инициализированные данные всегда заполняются нулями при загрузке
www.books-shop.com
Создание программы
программы на выполнение, для них необходимо хранить только размер и
расположение в памяти.
Символьная информация состоит из таблицы символов (symbol table) и
таблицы строк (string table). В первой таблице хранятся символы, их адреса
и типы. Например, мы можем определить, что символ locptr является
указателем и его виртуальный адрес равен Ox7fehO. Далее, используя этот
адрес, мы можем выяснить значение символа для выполняющегося про!
цесса. Записи таблицы символов имеют фиксированный размер. Если
длина символа превышает восемь знаков, его имя хранится во второй таб!
лице — таблице строк. Обычно обе эти таблицы присутствуют в объектных
и исполняемых файлах, если они явно не удалены, например, командой
strip(l).
Как и в случае ELF!файла, заголовок содержит общую информацию, позво!
ляющую определить местоположение остальных компонентов (табл. 2.5).
Таблица 2.5. Поля заголовка COFF%файла
Поле Описание
Аппаратная платформа, для которой создан файл
Количество разделов в файле
f_timdat Время и дата создания файла
Расположение таблицы символов в файле
Количество записей в таблице символов
Размер заголовка
f_f lags Флаги, указывающие на тип файла, присутствие символьной инфор%
мации и т. д.
Заголовок COFF присутствует в исполняемых файлах, промежуточных
объектных файлах и библиотечных архивах. Каждый исполняемый файл
кроме заголовка COFF содержит заголовок хранящий информацию,
необходимую ядру системы для запуска (табл. 2.6).
Таблица 2.6. Поля заголовка
Поле Описание
Номер версии заголовка
tsize Размер раздела инструкций (text)
dsize Размер инициализированных данных (data)
bsize Размер неинициализированных данных (bss)
В SCO UNIX заголовок самого ядра используется программой начальной загрузки
для запуска ядра и передачи ему управления при инициализации системы.
www.books-shop.com
Глава 2. программирования UNIX
Таблица 2.6 (продолжение)
Поле Описание
entry Точка входа программы
text_start Адрес в начала сегмента инструкций виртуальной памяти
data_start Адрес в начала сегмента данных виртуальной памяти
Все файлы формата COFF имеют один или более разделов, каждый из ко!
торых описывается своим заголовком. В заголовке хранится имя раздела
.bss или любое другое, установленное соответствующей дирек!
тивой ассемблера), размер раздела, его расположение в файле и виртуаль!
ной адрес после запуска программы на выполнение. Заголовки разделов
следуют сразу за заголовком файла.
Таблицы символов и строк являются основой системы отладки. Символом
является любая переменная, имя функции или метка, определенные в
программе.
Каждая запись в таблице символов хранит имя символа, его виртуальный
адрес, номер раздела, в котором определен символ, тип, класс хранения
(автоматический, регистровый и т. д.). Если имя символа занимает больше
восьми байт, то оно хранится в таблице строк. В этом случае в поле имени
символа указывается смещение имени символа в таблице строк.
С помощью символьной информации можно определить виртуальный ад!
рес некоторого символа. Одним из очевидных применений этой возмож!
ности является использование символьной информации в программах!
отладчиках. Эта возможность используется некоторыми программами, на!
пример, утилитой ps(l), отображающей состояние процессов в системе.
Выполнение программы в операционной системе UNIX
Выполнение программы начинается с создания в памяти ее образа и свя!
занных с процессом структур ядра операционной системы, инициализации
и передаче управления инструкциям программы. Завершение программы
ведет к освобождению памяти и соответствующих структур ядра. Образ
программы в памяти содержит, как минимум, сегменты инструкций и
данных, созданные компилятором, а также стек для хранения
ских переменных при выполнении программы.
Запуск
Функция является первой функцией, определенной пользователем
(т. е. явно описанной в исходном тексте программы), которой будет перс!
www.books-shop.com
Выполнение программы в операционной системе UNIX 115
дано управление после создания соответствующего окружения запускае!
мой на выполнение программы. Традиционно функция определяет!
ся следующим образом:
argc, char char
Первый аргумент (argc) определяет число параметров, переданных про!
грамме, включая ее имя.
Указатели на каждый из параметров передаются в массиве argv [ таким
образом, через адресуется строка, содержащая имя программы,
argv указывает на первый параметр и т. д. до argv
Массив envp [ ] содержит указатели на переменные окружения, передавае!
мые программе. Каждая переменная представляет собой строку вида
Мы уже познакомились с пере!
менными окружения в главе 1, когда обсуждали командный интерпрета!
тор. Сейчас же мы остановимся на их программной "анатомии".
Стандарт ANSI С определяет только два первых аргумента функции
— argc и argv. Стандарт POSIX.1 определяет также аргумент envp,
хотя рекомендует передачу окружения программы производить через гло!
бальную переменную environ, как это показано на рис. 2.6:
extern char
Рекомендуется следовать последнему формату передачи для лучшей пере!
носимости программ на другие платформы UNIX.
Рис. 2.6. Передача переменных окружения
Приведем пример программы, соответствующую стандарту кото!
рая выводит значения всех аргументов, переданных функции число
переданных параметров, сами параметры и значения первых десяти пере!
менных окружения.
ttinclude
extern char
argc, char
www.books-shop.com
16 2. программирования UNIX
int i
параметров, переданных
программе равно argv[0],
for i++)
=
for i++)
if (environ[i] != NULL)
В результате компиляции будет создан исполняемый файл программы (по
умолчанию a.out). Запустив его, мы увидим следующую информацию:
$ a.out first second 3
число параметров, переданных программе равно 3
argv[l] = first
= second
argv[3] = 3
Максимальный объем памяти для хранения параметров и переменных ок!
ружения программы ограничен величиной определенной в фай!
ле Это и другие системные ограничения могут быть получены с
помощью функции sysconf(2).
Для получения и установки значений конкретных переменных окружения
используются две функции: и
ttinclude <stdlib.h>
char char
возвращает значение переменной окружения name, a
int char
помещает переменную и ее значение в окружение
программы.
В качестве примера приведем программу, похожую по своей функцио!
нальности на предыдущую, которая выборочно выводит значения пере!
менных и устанавливает новые значения по желанию пользователя.
ttinclude <stddef.h>
tinclude
www.books-shop.com
Выполнение программы в операционной системе UNIX
argc,
{
char
char
определена ли переменная
if = == NULL)
/*Если переменная не определена, получим от пользователя ее значение и
поместим переменную в окружение
{
TERM не определена, введите
}
else
/*Если переменная TERM определена, предоставим пользователю возможность
изменить ее значение, после чего поместим ее в окружение
{
Change?
gets
i f ||
{
}
}
Сначала программа проверяет, определена ли переменная TERM. Если пе!
ременная TERM не определена, пользователю предлагается ввести ее значе!
ние. Если же переменная TERM определена, пользователю предлагается из!
менить ее значение, после чего новое значение помещается в окружение
программы.
Запуск этой программы приведет к следующим результатам:
$
TERM=ansi. Change? [N]y
TERM=vtlOO
new
$
К сожалению, введенное значение переменной будет действительно только
для данного процесса и порожденных им процессов: если после завершения
программы a.out вывести значение TERM, то видно, что оно не изменилось:
$ echo
ansi
$
www.books-shop.com
Глава 2. программирования UNIX
Наследование окружения программы мы обсудим в разделе "Создание и
управление процессами" далее в этой главе.
Переменные окружения, как и параметры, позволяют передавать програм!
ме некоторую информацию. Однако если программа является интерактив!
ной, основную информацию она, скорее всего, будет получать непосредст!
венно от пользователя. В связи с этим встает вопрос: каким образом про!
грамма узнает, где находится пользователь, чтобы правильно считывать и
выводить информацию? Другими словами, программе необходимо знать, с
каким терминальным устройством работает пользователь, запустивший ее.
Обычно при запуске программы на выполнение из командной строки shell
автоматически устанавливает для нее три стандартных потока вво!
да/вывода: для ввода данных, для вывода информации и для вывода сооб!
щений об ошибках. Начальную ассоциацию этих потоков (их файловых
дескрипторов) с конкретными устройствами производит терминальный сер!
вер (в большинстве систем это процесс который открывает спе!
циальный файл устройства, связанный с терминалом пользователя, и по!
лучает соответствующие дескрипторы. Эти потоки наследует командный
интерпретатор shell и передает их запускаемой программе. При этом shell
может изменить стандартные направления (по умолчанию все три потока
связаны с терминалом пользователя), если пользователь указал на это с
помощью специальных директив перенаправления потока (>, <,
см. главу 1, раздел "Пользовательская среда UNIX"). Раздел "Группы и се!
ансы" внесет окончательную ясность в этот вопрос при описании управ!
ляющего терминала.
Такой механизм позволяет программисту не задумываться о местонахож!
дении пользователя, и в то же время обеспечить получение и передачу
данных именно запустившему данную программу пользователю.
Завершая разговор о запуске программ, заметим, что при компиляции
программы редактор связей устанавливает точку входа в программу, ука!
зывающую на библиотечную функцию Эта функция инициализи!
рует процесс, создавая кадр стека, устанавливая значения переменных и, в
конечном итоге, вызывая функцию main().
Завершение
Существует несколько способов завершения программы. Основными яв!
ляются возврат из функции и вызов функций exit(2), оба приводят
к завершению выполнения задачи. Заметим, что процесс может завер!
шиться по не зависящим от него обстоятельствам, например, при получе!
Начальная функция запуска программы на выполнение написана таким
что exit(2) вызывается автоматически при возврате из функции В языке С она име!
ет следующий вид:
www.books-shop.com
Выполнение программы в операционной системе UNIX
нии сигнала, действие по умолчанию для большинства из которых приво!
дит к завершению выполнения (см. раздел "Сигналы" далее в
этой главе). В этом случае функция exit(2) будет вызвана ядром от имени
процесса.
Системный вызов exit(2) выглядит следующим образом:
void
Аргумент status, передаваемый функции возвращается родитель!
скому процессу и представляет собой код возврата программы. По согла!
шению программа возвращает 0 в случае успеха и другую величину в слу!
чае неудачи. Значение кода неудачи может иметь дополнительную трак!
товку, определяемую самой программой. Например, программа grep(l),
выполняющая поиск заданных подстрок в файлах, определяет следующие
коды возврата:
совпадение было найдено
1 совпадений найдено не было
2 синтаксическая ошибка или недоступны файлы поиска
Наличие кода возврата позволяет программам взаимодействовать друг с
другом. Например, следующая программа (назовем ее fail) может являться
условием неудачи и использоваться в соответствующих синтаксических
конструкциях shell:
{
}
$ fail
$ echo $? Выведем код возврата программы fail
i
$ | | echo Конструкция shell, использующая условие неудачи fail
fail
Помимо передачи кода возврата, функция exit(2) производит ряд действий,
в частности выводит данные и закрывает потоки вво!
да/вывода. Альтернативой ей является функция _exit(2), которая не произ!
водит вызовов библиотеки ввода/вывода, а сразу вызывает системную
функцию завершения ядра. Более подробно о процедурах завершения
процесса см. раздел "Создание и управление процессами".
Задача может зарегистрировать обработчики выхода (exit handler), — функ!
ции, которые вызываются после вызова exit(2), но до окончательного за!
В английском языке такое завершение выполнения называется более откровенно —
"убийство процесса".
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
120 Глава 2. программирования UNIX
вершения процесса. Эти обработчики, вызываемые по принципу LIFO
(последний зарегистрированный обработчик будет вызван первым), запус!
каются только при "добровольном" завершении процесса. Например, при
получении процессом сигнала обработчики выхода вызываться не будут.
Для обработки таких ситуаций следует использовать специальные функ!
ции — обработчики сигналов (см. раздел "Сигналы" далее в этой главе).
Обработчики выхода регистрируются с помощью функции
#include
int
Функцией atexit(l) может быть зарегистрировано до 32 обработчиков.
На рис. 2.7 проиллюстрированы возможные варианты запуска и заверше!
ния программы, написанной на языке С.
Рис. 2.7. Запуск и завершение
www.books-shop.com
Работа с файлами 121
Работа с файлами
В среде программирования UNIX существуют два основных интерфейса
для файлового ввода/вывода:
1. Интерфейс системных вызовов, предлагающий системные функции
низкого уровня, непосредственно взаимодействующие с ядром опера!
ционной системы.
2. Стандартная библиотека ввода/вывода, предлагающая функции буфе!
ризированного ввода/вывода.
Второй интерфейс является "надстройкой" над интерфейсом системных
вызовов, предлагающей более удобный способ работы с файлами.
В следующих разделах будут рассмотрены:
оба интерфейса, и особенно первый, поскольку именно он представ!
ляет набор базовых услуг ядра;
программный интерфейс управления жесткими и символическими
связями файла;
функции изменения владельцев файла и прав доступа;
метаданные файла;
пример программы, выводящей на экран наиболее существенную
информацию о файле, подобно тому, как это делает утилита
Основные системные функции для работы с файлами
В табл. 2.7 приведены основные системные функции работы с файлами,
являющиеся образами системных вызовов в программе С.
Функции более высокого уровня, предлагаемые стандартной библиотекой
ввода/вывода, которые в конечном счете используют описанные здесь сис!
темные вызовы, рассматриваются в следующем разделе.
Таблица 2.7. Основные системные функции работы с файлами
функция
creat(2)
close(2)
Служит для получения доступа на чтение и/или запись к указанно%
му файлу. Если файл существует, он открывается, и процессу воз%
вращается файловый дескриптор, адресующий дальнейшие опе%
рации с файлом. Если файл не существует, он может быть создан
Служит для создания файла
Закрывает файловый дескриптор, связанный с предварительно
открытым файлом
Возвращает дубликат файлового дескриптора
www.books-shop.com
]22 Глава 2. Среда программирования UNIX
Таблица 2.7 (продолжение)
функция
dup2(2)
lseek(2)
writev(2)
pipe(2)
fcntl(2)
Описание
Возвращает дубликат файлового дескриптора, но позволяет явно
указать его значение
Устанавливает файловый указатель на определенное место фай%
ла. Дальнейшие операции чтения/записи будут производиться,
начиная с этого смещения
Производит чтение указанного количества байтов из файла
Производит несколько операций чтения указанного количества
байтов из файла
Производит запись указанного количества байтов в файл
Производит несколько операций записи указанного количества
байтов в файл
Создает коммуникационный канал, возвращая два файловых де%
скриптора
Обеспечивает интерфейс управления открытым файлом
Кратко рассмотрим каждую из этих функций.
Функция
Открывает указанный файл для чтения или записи и имеет следующий вид:
int char *path, int
Первый аргумент (path) является указателем на имя файла. Это имя мо!
жет быть как абсолютным (начинающимся с корневого каталога /), так и
относительным (указанным относительно текущего каталога). Аргумент
lag указывает на режим открытия файла и представляет собой побитное
объединение флагов, приведенных в табл. 2.8, с помощью операции ИЛИ.
Напомним, что если права доступа к файлу не разрешают указанного ре!
жима работы с файлом, операция открытия файла будет запрещена, и
функция ореп(2) завершится с ошибкой (errno=EACCESS). Аргумент mode,
определяющий права доступа к файлу, используется только при создании
файла (как показано в табл. 2,8, функция может использоваться и
для создания файла) и рассматривается при описании функции
в разделе "Права доступа" этой главы.
Таблица 2.8. Флаги, определяющие режим открытия файла
Флаг Описание
O_RDONLY Открыть файл только для чтения
0_WRONLY Открыть файл только для записи
www.books-shop.com
Работа с файлами 123
Таблица 2.8 (продолжение)
O_RDWR
O_APPEND
0_EXCL
O_NOCTTY
O_SYNC
0_TRUNC
O_NONBLOCK
Описание
Открыть файл для чтения и записи
Производить добавление в файл, т. е. устанавливать фай%
ловый указатель на конец файла перед каждой записью в
файл
Если указанный файл уже существует, этот флаг не прини%
мается во внимание. В противном случае, создается файл,
атрибуты которого установлены по умолчанию (см. разделы
"Владельцы файлов" и "Права доступа к файлу" в главе
или с помощью аргумента mode
Если указан совместно с O_CREAT, то вызов ореп(2) за%
вершится с ошибкой, если файл уже существует
Если указанный файл представляет собой терминал, не
позволяет ему стать управляющим терминалом
Все записи в файл, а также соответствующие им изменения
в метаданных файла будут сохранены на диске до возврата
из вызова
Если файл существует и является обычным файлом, его
длина будет установлена равной 0
Изменяет режим выполнения операций read(2) и write(2) для
этого файла на неблокируемый. При невозможности произ%
вести запись или чтение, например, если отсутствуют данные,
соответствующие вызовы завершатся с ошибкой EAGAIN
Если операция открытия файла закончилась удачно, то будет возвращен
файловый дескриптор — указатель на файл, использующийся в последую!
щих операциях чтения, записи и т. д. Значение файлового дескриптора
определяется минимальным свободным слотом в таблице дескрипторов
процесса. Так, если дескрипторы 0 и 2 уже заняты (указывают на откры!
тые файлы), вызов ореп(2) возвратит значение Это свойство может быть
использовано в коде командного интерпретатора при перенаправлении
потоков ввода/вывода:
$
Фрагмент кода
ассоциацию стандартного потока вывода (1) с файлом
close
/*Назначим стандартный поток вывода в файл
Поскольку файловый дескриптор 1 свободен, мы можем рассчитывать
на его
= ,
0 I 0 CREATE ] 0
www.books-shop.com
}24 Глава 2. программирования UNIX
В случае неудачи возвратит !1, а глобальная переменная errno бу!
дет содержать код ошибки (см. раздел "Обработка ошибок").
Заметим, что только один из флагов 0_RDONLY, и может
быть указан в аргументе of lag.
Флаг o_SYNC гарантирует, что данные, записанные в файл и связанные с
операцией записи изменения метаданных файла, будут сохранены на дис!
ке до возврата из функции Ядро кэширует данные, считываемые
или записываемые на дисковое устройство, для ускорения этих операций.
Обычно запись данных в файл ограничивается записью в буферный кэш
ядра операционной системы, данные из которого впоследствии записыва!
ются на диск. По умолчанию возврат из функции происходит по!
сле записи в буферный кэш, не дожидаясь записи данных на диск. Более
подробно работу буферного кэша мы рассмотрим в главе 4.
Флаг изменяет стандартное поведение функций чтения/записи
файла. При указании этого флага возврат из функций и бу!
дет происходить немедленно с кодом ошибки и установленным значением
errno = EAGAIN, если ядро не может передать данные при чтении, на!
пример, ввиду их отсутствия, или процессу требуется перейти в состояние
сна при записи данных.
Функция creat(2)
Функция служит для создания обычного файла или изменения его атрибу!
тов и имеет следующий вид:
ttinclude
int creat (const char
Как и в случае аргумент path определяет имя файла в файловой
системе, a mode — устанавливаемые права доступа к файлу. При этом вы!
полняется ряд правил:
Если идентификатор группы (GID) создаваемого файла не совпадает
с эффективным идентификатором группы (EGID) или идентифика!
тором одной из дополнительных групп процесса, бит SGID аргумен!
та mode очищается (если он был установлен).
О Очищаются все биты, установленные в маске процесса
Очищается флаг Sticky bit.
Права доступа к файлу обсуждались в главе 1. Более детальная информа!
ция приведена в разделе "Права доступа" этой главы.
Если файл уже существует, его длина сокращается до 0, а права доступа и
владельцы сохраняются прежними. Вызов creat(2) эквивалентен следую!
щему вызову функции
О | О | О mode);
www.books-shop.com
Работа с файлами
Функция
Функция разрывает связь между файловым дескриптором и откры!
тым файлом, созданную функциями или
Функция имеет вид:
int
В случае успеха возвращает нулевое значение, в противном случае
возвращается а значение переменной errno указывает на причину не!
удачи.
Многие программы явно не используют close(2) при завершении выполне!
ния. Дело в том, что функция exit(2), вызываемая явно или неявно при
завершении выполнения программы, автоматически закрывает открытые
файлы.
Функции и dup2(2)
Функция используется для дублирования существующего файлового
дескриптора:
int
Файловый дескриптор fildes должен быть предварительно получен с по!
мощью функций ореп(2), creat(2), или pipe(2). В случае ус!
пешного завершения функции возвращается новый файловый деск!
риптор, свойства которого идентичны свойствам дескриптора fildes. Оба
указывают на один и тот же файл, одно и то же смещение, начиная с ко!
торого будет производиться следующая операция чтения или записи
(файловый указатель), и определяют один и тот же режим работы с фай!
лом. Правило размещения нового файлового дескриптора аналогично ис!
пользуемому в функции
Функция делает то же самое, однако позволяет указать номер фай!
лового дескриптора, который требуется получить после дублирования:
int fildes, int
Файловый дескриптор, подлежащий дублированию, передается в первом
аргументе а новый дескриптор должен быть равен fildes2. Ес!
ли дескриптор fildes2 уже занят, сначала выполняется функция
В качестве примера использования системного вызова рассмотрим
вариант реализации слияния потоков в командном интерпретаторе shell:
$ 2>61
Фрагмент кода
ассоциацию стандартного потока вывода (1) с файлом
www.books-shop.com
126 Глава 2. Среда программирования UNIX
стандартный поток вывода в файл
fd = I |
слияние
Функция lseek(2)
С файловым дескриптором связан файловый указатель, определяющий те!
кущее смещение в файле, начиная с которого будет произведена после!
дующая операция чтения или записи. В свою очередь каждая операция
чтения или записи увеличивают значение файлового указателя на число
считанных или записанных байт. При открытии файла, файловый указа!
тель устанавливается равным 0 или, если указан флаг равным
размеру файла. С помощью функции lseek(2) можно установить файловый
указатель на любое место файла и тем самым обеспечить прямой доступ к
любой части файла. Функция имеет следующий вид:
ttinclude <unistd.h>
off_t lseek(int fildes, off_t offset, whence);
Интерпретация аргумента offset зависит от аргумента whence, который
может принимать следующие значения:
SEEK_CUR Указатель смещается на байт от текущего положения
SEEK_END Указатель смещается на байт от конца файла
Указатель устанавливается равным
В случае успеха функция возвращает положительное целое, равное теку!
щему значению файлового указателя.
Относительно системного вызова lseek(2) необходимо сделать два замеча!
ния. Во!первых, lseek(2) не инициирует никакой операции ввода/вывода,
лишь изменяя значения файлового указателя в файловой таблице ядра.
Во!вторых, смещение, указанное в качестве аргумента lseek(2), может вы!
ходить за пределы файла. В этом случае, последующие операции записи
приведут к увеличению размера файла и, в то же время, к образованию
дыры — пространства, формально незаполненного данными. В реальности,
дыры заполняются нулями, но могут в ряде случаев привести к неприят!
ным последствиям, с причиной и описанием которых вы сможете ознако!
миться в главе 4 при обсуждении внутренней структуры файла.
Функция read(2) и readv(2)
Функции read(2) и readv(2) позволяют считывать данные из файла, на ко!
торый указывает файловый дескриптор, полученный с помощью функций
www.books-shop.com
Работа с файлами
pipe(2) или fcntl(2). Функции имеют сле!
дующий вид:
ssize_t fildes, void *buf, size_t
ttinclude
<sys/uio.h>
ssize_t fildes, struct iovec *iov,
Аргументы, передаваемые функции указывают, что следует считать
nbyte байт из файла, связанного с дескриптором fildes, начиная с теку!
щего значения файлового указателя. Считанные данные помещаются в бу!
фер приложения, указатель на который передается в аргументе buf. После
завершения операции значение файлового указателя будет увеличено на
nbyte.
Функция позволяет выполнить iovcnt последовательных опера!
ций чтения за одно обращение к readv(2). Аргумент iov указывает на мас!
сив структур, каждый элемент которого имеет вид:
struct {
void Указатель на начало буфера
iov_len; Размер буфера
Функция считывает данные из файла и последовательно размеща!
ет их в нескольких буферах, определенных массивом iov. Такой характер
работы, проиллюстрированный на рис. 2.8, получил название scatter read
(от scatter (англ.) — разбрасывать). Общее число считанных байт в нор!
мальной ситуации равно сумме размеров указанных буферов.
Функции write(2) и writev(2)
Функции и очень похожи на функции read(2) и но
используются для записи данных в файл. Функции имеют следующий вид:
ttinclude
ssize_t fildes, void size_t
<sys/uio.h>
ssize_t fildes, struct iovec int iovcnt);
Аргументы, передаваемые функции указывают, что следует запи!
сать nbyte байт в файл, связанный с дескриптором fildes, начиная с те!
кущего значения файлового указателя. Данные для записи находятся в бу!
фере приложения, указанном аргументом buf . После завершения опера!
ции значение файлового указателя будет увеличено на nbyte.
Аналогично функции функция позволяет выполнить
iovcnt последовательных операций записи за одно обращение к
www.books-shop.com
Глава 2. Среда программирования
Такая операция ввода/вывода получила название gather (собирать), а
функции ввода/вывода, использующие набор буферов, — общее название
Файл
Рис. 2.8. Чтение файла с использованием нескольких буферов
Функция
Функция pipe(2) служит для создания однонаправленного (симплексного)
канала (также называемого анонимным каналом) обмена данными между
двумя родственными процессами. Дело в том, что только родственные
процессы (например, родительский и дочерний) имеют возможность полу!
чить доступ к одному и тому же каналу. Этот аспект станет более понят!
ным в ходе обсуждения в разделе "Создание и управление процессами"
далее в этой главе. Функция имеет вид:
int
Функция возвращает два файловых дескриптора в массиве f ildes [ при!
чем служит для чтения данных из канала, a ! для
записи данных в канал.
Каналы являются одним из способов организации межпроцессного взаи!
модействия и будут подробно рассмотрены в главе 3. В качестве примера
www.books-shop.com
Работа с файлами
использования pipe(2) можно привести возможность командного интерпре!
татора — создание программных каналов, рассмотренное в главе
Отметим, что буферизация данных в канале стандартно осуществляется пу!
тем выделения дискового пространства в структуре файловой системы. Та!
ким образом, чтение и запись в канал связаны с дисковым вводом/выводом,
что, безусловно, сказывается на производительности этого механизма. Со!
временные операционные системы наряду с более совершенными средства!
ми межпроцессного взаимодействия предлагают и более эффективные меха!
низмы каналов. Так, например, SCO UNIX 5.0) обеспечивает
работу каналов через специальную файловую систему — HPPS (High Per!
formance Pipe System). С помощью HPPS данные в опера!
тивной памяти, что существенно ускоряет операции записи и чтения.
Функция fcntl(2)
После открытия файла и получения ссылки на него в виде файлового де!
скриптора процесс может производить различные файловые операции.
Функция позволяет процессу выполнить ряд действий с файлом,
используя его дескриптор, передаваемый в качестве первого аргумента:
<fcntl.h>
int int cmd,
Функция выполняет действие cmd с файлом, а возможный третий
аргумент зависит от конкретного действия:
F_DUPFD Разместить новый файловый дескриптор, значение которого больше
или равно значению третьего аргумента. Новый файловый дескрип%
тор будет указывать на тот же открытый файл, что и f ildes. Дейст%
вие аналогично вызову функции или
fddup = F_DUPFD, fildes2)
F_GETFD Возвратить признак сохранения дескриптора при запуске новой
программы (выполнении системного вызова — флаг
(FD_CLOEXEC). Если флаг установлен, то при вызове ехес(2)
файл, ассоциированный с данным дескриптором, будет закрыт
F_SETFD Установить флаг согласно значению, заданному
третьим аргументом
F_GETFL Возвратить режим доступа к файлу, ассоциированному с данным де%
скриптором. Флаги, установленные в возвращаемом значении, пол%
ностью соответствуют режимам открытия файла, задаваемым функ%
ции ореп(2). Их значения приведены в табл. 2.8. Рассмотрим пример:
= F_GETFL,
биты, определяющие режим
accbits = &
if (accbits == 0_RDONLY)
открыт только для
else if (accbits ==
открыт только для
else if (accbits
открыт для чтения и
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
130 Глава 2. Среда UNIX
F_SETFL Установить режим доступа к файлу согласно значению, переданно%
му в третьем аргументе. Могут быть изменены только флаги
0_APPEND, 0_NONBLOCK, 0_SYNC И 0_ASYNC.
F_GETLK Проверить существование блокирования записи файла. Блокирова%
ние записи, подлежащее проверке, описывается структурой
указатель на которую передается в качестве третьего аргумента.
Если существующие установки не позволяют выполнить блокирова%
ние, определенное структурой последняя будет возвращена
с описанием текущего блокирования записи. Данная команда не
устанавливает блокирование, а служит для проверки его возможно%
сти. Более подробно блокирование записей описано в главе 4, в
разделе "Блокирование доступа к файлу".
F_SETLK Установить блокирование записи файла. Структура описыва%
ет блокирование, и указатель на нее передается в качестве третьего
аргумента. При невозможности блокирования fcntl(2) возвращается
С ошибкой EACCESS ИЛИ EAGAIN.
F_SETLKW Аналогично предыдущему, но при невозможности блокирования по
причине уже существующих блокировок, процесс переходит в со%
стояние сна, ожидая, пока последние будут освобождены. Послед%
няя буква W в названии действия означает wait (ждать).
Стандартная библиотека ввода/вывода
Функции, которые мы только что рассмотрели представляют интерфейс
ввода/вывода между приложениями и ядром операционной системы. Хотя
их использование напоминает использование библиотечных функций С,
по существу они представляют собой лишь "обертки" к функциям ядра
UNIX, фактически выполняющим операции ввода/вывода.
Однако программисты редко используют этот интерфейс низкого уровня,
предпочитая возможности, предоставляемые стандартной библиотекой
ввода/вывода. Функции этой библиотеки обеспечивают
ввод/вывод и более удобный стиль программирования. Для использования
функций этой библиотеки в программу должен быть включен файл заго!
ловков <stdio.h>. Эти функции входят в стандартную библиотеку С (libc.so
или которая, как правило, подключается по умолчанию на этапе
связывания.
Вместо использования файлового дескриптора библиотека определяет ука!
затель на специальную структуру данных (структура FILE), называемый
потоком или файловым указателем. Стандартные потоки ввода/вывода
обозначаются символическими именами stdout, stderr соответ!
ственно для потоков ввода, вывода и сообщений об ошибках. Они опреде!
лены следующим образом:
extern FILE
extern FILE
extern FILE
www.books-shop.com
Работа с файлами
Связь потоков стандартной библиотеки с файловыми дескрипторами при!
ведена в табл. 2.9.
Таблица 2.9. Стандартные потоки и их дескрипторы
Файловый дескриптор Поток (указатель) Описание
Стандартный ввод
1 Стандартный вывод
2 stderr Сообщения об ошибках
Таблица 2.10. Наиболее употребительные функции стандартной библиотеки
Функция Назначение
fopen(3S) Открывает файл с указанным именем и возвращает файловый ука%
затель, ассоциированный с данным файлом
fclose(3S) Закрывает поток, освобождая буферы
Очищает буфер потока, открытого на запись
getc(3S) Считывает символ из потока
putc(3S) Записывает символ в поток
gets(3S) Считывает строку из потока
Записывает строку в поток
Считывает указанное число байтов из потока (бинарный ввод)
Записывает указанное число байтов в поток (бинарный вывод)
fseek(3S) Позиционирует указатель в потоке
Производит форматированный вывод
scanf(3S) Производит форматированный ввод
Возвращает файловый дескриптор данного потока
Выбор между функциями интерфейса системных вызовов и стандартной
библиотеки зависит от многих факторов, в частности, степени контроля
ввода/вывода, переносимости программы, простоты. Взгляните, например,
на следующие эквивалентные строки программы:
(1, "Здравствуй,
printf
В первой строке сообщение выводится с использованием системной функ!
ции во второй — с помощью библиотечной функции printf(3S).
Помимо того, что второй вариант кажется более лаконичным, отметим
еще ряд особенностей. В первом варианте пришлось сделать предположе!
ние о том, что файловый дескриптор стандартного вывода равен 1, что
может оказаться несправедливым для некоторых систем. Также пришлось
www.books-shop.com
Глава 2. программирования UNIX
явно указать число символов в строке, т. к. не делает никаких
предположений о формате вывода, трактуя его как последовательность
байтов. В отличие от распознает строки, представляющие
собой последовательность символов, заканчивающихся нулем. Функция
также позволяет отформатировать выводимые данные для пред!
ставления их в требуемом виде.
Но основным достоинством функций библиотеки является буферизация
ввода/вывода, позволяющая минимизировать число системных вызовов
read(2) и При открытии файла и создании потока функции биб!
лиотеки автоматически размещают необходимые буферы, позволяя прило!
жению не заботиться о них.
Библиотека предоставляет три типа буферизации:
Полная буферизация. В этом случае операция чтения или записи за!
вершается после того, как будет заполнен буфер ввода/вывода.
Ввод/вывод для дисковых файлов, как правило, полностью буфери!
зируется. Буфер размещается с помощью функции malloc(3C) при
первом обращении к потоку для чтения или записи и заполняется
системными вызовами или Это означает, что после!
дующие вызовы getc(3S), gets(3S), puts(3S) и т. д. не иниции!
руют обращений к системным функциям, а будут производить чте!
ние или запись из буфера библиотеки. Содержимое буфера очищает!
ся (т. е. данные сохраняются на диске) автоматически, либо при вы!
зове функции
буферизация. В этом случае библиотека выполняет фак!
тический ввод/вывод (т. е. производит системные вызовы read(2) или
построчно при обнаружении конца строки (символа перево!
да каретки). Такой тип буферизации обычно используется для ассо!
циированных с терминальными устройствами потоков, которыми,
как правило являются стандартные потоки ввода и вывода.
Отсутствие буферизации. В этом случае библиотека не производит
никакой буферизации, фактически являясь только программной
оболочкой системных вызовов. При этом достигаются минимальные
задержки операций чтения и записи, необходимые, например, при
выводе сообщений об ошибках. Отсутствие буферизации характерно
для стандартного потока вывода сообщений об ошибках.
Характер буферизации может быть изменен с помощью функций:
<stdio.h>
void char
int char *buf, int type,
Функция setbuf(3S) позволяет включить или отключить буферизацию для
потока stream. В первом случае buf должен указывать на буфер размером
во втором его значение должно быть равно NULL.
www.books-shop.com
Работа с файлами 133
Функция позволяет производить более тонкое управление буфе!
ризацией, явно указывая, какой ее тип мы хотим установить. Для этого ис!
пользуется аргумент type, который может принимать следующие значения:
_IOFBF
_IOLBF
Полная буферизация
Построчная буферизация
Отсутствие буферизации
В случае полной или построчной буферизации аргумент определяет
размер буфера, адресованного указателем
Каждый поток стандартной библиотеки представлен указателем на струк!
туру FILE, показанную на рис. 2.9, в которой хранится указатель на буфер
_base, указатель на следующий символ, подлежащий чтению или записи
число байт в буфере _cnt, указатель на файловый дескриптор
_file, с которым ассоциирован данный поток, а также флаги состояния
потока _f lag. При создании буфера библиотека выбирает оптимальный
размер для данного потока. Обычно этот размер равен значению поля
st_blksize структуры stat, возвращаемой системным вызовом
рассмотренный в разделе "Метаданные файла" этой главы. Если опреде!
лить оптимальный размер невозможно, например для каналов или специ!
альных файлов устройств, выбирается стандартное значение опре!
деленное в файле <stdio.h>.
Рис. 2.9. Структуры
данных потока
Связи
В метаданных каждого файла файловой системы UNIX хранится число
связей, определяющее количество имен, которое имеет данный файл. На!
www.books-shop.com
134 Глава 2. программирования UNIX
пример, файлы (или etc/rc0.d/K201p, /etc/rc2.d/K20Ip
и имеют различные имена, но ссылаются на один и тот же
физический файл (точнее, метаданные файла) и тем самым обеспечивают
доступ к одним и тем же данным. В данном случае число связей файла
равно 4. Каждый раз, когда одно из имен файла удаляется, число связей
соответственно уменьшается. Когда оно достигнет нуля — данные файла
будут удалены. Такой тип связи называется жесткой.
Жесткая связь создается с помощью системного вызова
int char const char
При этом будет образована новая запись каталога с именем new и номером
inode указывающим на метаданные файла existing. Также будет увеличе!
но число связей. Этим системным вызовом, в частности, пользуется ко!
манда рассмотренная в главе 1.
Для удаления жесткой связи используется системный вызов
ttinclude <unistd.h>
int char
Эту функцию вызывает команда при удалении файла. При этом не
обязательно будут удалены данные файла. Заметим, что системный вызов,
явно удаляющий данные файла, отсутствует, поскольку у файла может су!
ществовать несколько жестких связей, часть из которых может быть недос!
тупна процессу, вызывающему такую функцию (например, одно из имен
файла может быть расположено в недоступном каталоге).
В противоположность жестким связям, которые, как отмечалось в главе
являются естественным способом адресации данных файла, в UNIX при!
меняются символические связи, адресующие не данные файла, а его имя.
Например, если файл является символической связью, то в его данных
хранится имя файла, данные которого косвенно адресуются.
Символическая связь позволяет косвенно адресовать другой файл файло!
вой системы. Системный вызов служит для создания символиче!
ской связи. Этим вызовом, кстати, пользуется команда !s.
ttinclude <unistd.h>
int char *name, const char
После создания символической связи, доступ к целевому файлу name мо!
жет осуществляться с помощью symname. При этом, функция
принимая в качестве аргумента имя символической связи, на самом деле
открывает целевой файл. Такая особенность называется следованием симво!
лической связи. Не все системные вызовы обладают этим свойством. На!
пример, системный вызов удаляющий запись в каталоге, дейст!
вует только на саму символическую связь. В противном случае, мы не
имели бы возможности удалить ее. В табл. показано, как работают с
символическими связями различные системные вызовы.
www.books-shop.com
Работа с файлами /35
Таблица Интерпретация символической связи различными системными вызовами
Системный Не следует символической
вызов связи связи
access (2) +
chdir(2) +
chmod(2) +
chown(2) +
+
creat(2) +
exec(2) +
link(2) +
+
mknod(2) +
open(2) +
readlink(2) +
+
lstat(2) +
unlink(2) +
Для чтения содержимого файла — символической связи используется сис!
темный вызов
ttinclude
int char *path, void *buf, size_t
Аргумент path содержит имя символической связи. В буфере разме!
ром возвращается содержимое файла — символической связи.
Для иллюстрации к вышеприведенным рассуждениям приведем пример
программы, которая сначала выводит содержимое символической связи, а
затем — целевого файла, пользуясь в обоих случаях символическим име!
нем:
linclude
ttinclude
ttinclude <fcntl.h>
<stdio.h>
BUFSZ 256
/*B качестве аргумента программа принимает
имя символической
argc, char
www.books-shop.com
136 Глава 2. программирования UNIX
char
int nread, fd;
/*Прочитаем содержимое самой символической
сиволическую
nread = buf,
if (nread < 0)
{
}
/*readlink не завершает строку
=
/*Теперъ прочитаем содержимое целевого
целевой
fd =
if (fd < 0)
{
}
nread = buf,
if (nread < 0)
{
}
=
exit
}
Перед тем как запустить программу, создадим символическую связь с фай!
лом unix0.txt:
$ s
$ 1
1 user 10 Jan 6 09:54 symlink.txt !>
1 andy user 498 Jan 6 09:53 unix0.txt
$
Читаем сиволическую связь
Символическая
Читаем целевой файл
Целевой
Начиная с 1975 года фирма AT&T начала предоставлять лицензии на
использование операционной системы как научнообразовательным
учреждениям, так и коммерческим организациям. Поскольку основная
часть системы поставлялась в исходных текстах, написанных на
языке С, опытным программистам не требовалось детальной
документации, чтобы разобраться в архитектуре UNIX. С ростом
популярности микропроцессоров
www.books-shop.com
Работа с файлами
Файлы, отображаемые в памяти
Системный вызов предоставляет механизм доступа к файлам, аль!
тернативный вызовам и С помощью этого вызова процесс
имеет возможность отобразить участки файла в собственное адресное про!
странство. После этого данные файла могут быть получены или записаны
путем чтения или записи в память. Функция определяется сле!
дующим образом:
#include
caddr_t addr, size_t int prot,
int flags, int fildes,
Этот вызов задает отображение len байтов файла с дескриптором fildes,
начиная со смещения o f f , в область памяти со стартовым адресом addr.
Разумеется, перед вызовом файл должен быть открыт с помощью
функции Аргумент prot определяет права доступа к области памя!
ти, которые должны соответствовать правам доступа к файлу, указанным в
системном вызове ореп(2). В табл. 2.12 приведены возможные значения
аргумента prot и соответствующие им права доступа к файлу. Возможно
логическое объединение отдельных значений prot. Так значение
PROT_READ | соответствует доступу к файлу.
Таблица 2.12. Права доступа к области памяти
Значение аргу[ Описание Права доступа к файлу
мента prot
PROT READ
PROT WRITE
PROT EXEC
PROT NONE
Область доступна для чтения
Область доступна для записи
Область доступна для испол%
нения
Область недоступна
w
X
—
Обычно значение addr задается равным 0, что позволяет операционной
системе самостоятельно выбрать виртуальный адрес начала области ото!
бражения. В любом случае, при успешном завершении возвращаемое сис!
темным вызовом значение определяет действительное расположение об!
ласти памяти.
Операционная система округляет значение len до следующей страницы
виртуальной Например, если размер файла 96 байтов, а размер
страницы 4 Кбайт, то система все равно выделит область памяти размером
4096 байтов. При этом 96 байтов займут собственно данные файла, а ос!
тальные 4000 байтов будут заполнены нулями. Процесс может модифици!
Организация виртуальной памяти подробно рассматривается в главе 3.
www.books-shop.com
138 2. программирования UNIX
ровать и оставшиеся 4000 байтов, но эти изменения не отразятся на со!
держимом файла. При обращении к участку памяти, лежащему за преде!
лами файла, ядро отправит процессу сигнал Несмотря на то что
область памяти может превышать фактический размер файла, процесс не
имеет возможности изменить его размер.
Использование права на исполнение (prot = PROT_EXEC) позволяет про!
цессу определить собственный механизм загрузки кода. В частности, такой
подход используется редактором динамических связей при загрузке дина!
мических библиотек, когда библиотека отображается в адресное простран!
ство процесса. Значение позволяет приложению определить
собственные механизмы контроля доступа к разделяемым объектам
(например, к разделяемой памяти), разрешая или запрещая доступ к об!
ласти памяти.
Аргумент определяет дополнительные особенности управления об!
ластью памяти. В табл. 2.13 приведены возможные типы отображения, оп!
ределяемые аргументом
Таблица 2.13. Типы
аргумента flags Описание
Область памяти может совместно использовать%
ся несколькими процессами
Область памяти используется только вызываю%
щим процессом
MAP_FIXED Требует выделения памяти, начиная точно с ад%
реса addr
MAP_NORESERVE He требует резервирования области свопинга
В случае указания для процесса, определившего этот тип
отображения, будет создана собственная копия страницы памяти, которую
он пытается модифицировать. Заметим, что копия будет создана только
при вызове операции записи, до этого остальные процессы, определившие
тип отображения как MAP_SHARED могут совместно использовать одну и ту
же область памяти.
Не рекомендуется использовать флаг т. к. это не позволяет
системе максимально эффективно распределить память. В случае отсутст!
вия этого флага, ядро пытается выделить область памяти, начиная с адреса
наиболее близкого к значению addr. Если же значение addr установлено
равным 0, операционная система получает полную свободу в размещении
области отображения.
Если быть более точным, сигнал посылается процессу, когда происходит обращение к
странице памяти, на которую не отображается ни один из участков файла. Таким образом,
в приведенном примере сигнал процессу не будет отправлен.
www.books-shop.com
Работа с файлами 139
Отображение автоматически снимается при завершении процесса. Процесс
также может явно снять отображение с помощью вызова За!
крытие файла не приводит к снятию отображения. Следует отметить, что
снятие отображения непосредственно не влияет на отображаемый файл,
т. е. содержимое страниц области отображения не будет немедленно запи!
сано на диск. Обновление файла производится ядром согласно алгоритмам
управления виртуальной памятью. В то же время в ряде систем существует
функция которая позволяет синхронизировать обновление па!
мяти с обновлением файла на
В качестве примера приведем упрощенную версию утилиты копирую!
щую один файл в другой с использованием отображения файла в память.
<sys/stat.h>
#include
raain(int argc, char
{
int
caddr_t addr_src,
struct stat filestat;
аргумент — исходный файл, второй —
|
размер исходного
/*Сделаем размер целевого файла равным
lseek(fd_dst,  1,
/*3ададим
fd_src,
PROT_READ | fd_dst, 0);
/*Копируем области
addr_src,
exit
}
Поскольку, как обсуждалось выше, с помощью вызова нельзя из!
менить размер файла, это было сделано с помощью вызова lseek(2) с по!
На самом деле синхронизирует обновление страниц памяти с вторичной памятью.
Для областей типа вторичной памятью является сам файл на диске. Для об!
ластей типа вторичной памятью является область свопинга. Функция
также позволяет принудительно обновить страницы, так что при следующем об!
ращении к какой!либо из них ее содержимое будет загружено из вторичной памяти.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 2. программирования UNIX
следующей записью одного байта так, что размер целевого файла стал
равным размеру исходного. При этом в целевом файле образуется "дыра",
которая, к счастью, сразу же заполняется содержимым копируемого файла.
Владение файлами
Владелец!пользователь и владелец!группа файла могут быть изменены с
помощью системных вызовов и
int char uid_t owner, gid_t
int fildes, owner, gid_t
int char uid_t owner, gid_t
Все три вызова работают одинаково за исключением ситуации, когда адре!
суемый файл является символической связью. В последнем случае вызов
действует на сам файл — символическую связь, а не на целевой
файл (т. е. не следует символической связи). В функциях и
файл адресуется по имени, а в — по файловому деск!
риптору. Если значение owner или group установлено равным соответ!
ствующий владелец файла не изменяется.
В версиях BSD UNIX только суперпользователь может изменить владение
файлом. Это ограничение призвано, в первую очередь, не допустить
"скрытие" файлов под именем другого пользователя, например, при уста!
новке квотирования ресурсов файловой системы. Владельца!группу можно
изменить только для файлов, которыми вы владеете, причем им может
стать одна из групп, членом которой вы являетесь. Эти же ограничения
определены и стандартом
В системах ветви System V эти ограничения являются конфигурируемыми,
и в общем случае в UNIX System V пользователь может изменить владель!
ца собственных файлов.
В случае успешного изменения владельцев файла биты SUID и SGID
сбрасываются, если процесс, вызвавший не обладает правами су!
перпользователя.
Права доступа
Как уже обсуждалось в предыдущей главе, каждый процесс имеет четыре
пользовательских идентификатора — EUID и EGID. В то вре!
мя как UID и GID определяют реального владельца процесса, EUID и
EGID определяют права доступа процесса к файлам в процессе выполне!
ния. В общем случае реальные и эффективные идентификаторы эквива!
лентны. Это значит, что процесс имеет те же привилегии, что и пользова!
тель, запустивший его. Однако, как уже обсуждалось возникают
ситуации, когда процесс должен получить дополнительные привилегии,
www.books-shop.com
Работа с файлами 141
чаще всего — привилегии суперпользователя. Это достигается установкой
битов SUID и SGID. Примером такого процесса может служить утилита
изменяющая пароль пользователя.
Права доступа к файлу могут быть изменены с помощью системных вызо!
вов и
iinclude
<sys/stat.h>
int chmod(const char *path, mode_t
fildes,
Значение аргумента mode определяет устанавливаемые права доступа и допол!
нительные атрибуты (такие как SUID, SGID и Sticky bit), и создается путем
логического объединения различных флагов, представленных в табл. 2.14.
Вторая колонка таблицы содержит восьмеричные значения для девяти битов
прав доступа (чтение, запись и выполнение для трех классов доступа) и трех
битов дополнительных атрибутов.
Таблица 2.14. Флаги аргумента mode
Флаг Биты Значение
S ISUID 04000 Установить бит SUID
S_ISGID SGID, 7, 5, или 1
Установить обязательное блокирование файла, если #
равно 6, 4, 2 или О
S ISVTX 01000 Установить Sticky bit
00700 Установить право на чтение, запись и выполнение для
владельца%пользователя
S_IRUSR 00400 Установить право на чтение для владельца%пользо%
вателя
S 00200 Установить право на запись для владельца%пользователя
00100 Установить право на выполнение для владельца%поль%
зователя
00070 Установить право на чтение, запись и выполнение для
владельца%группы
S IRGRP 00040 Установить право на чтение для владельца%группы
S 00020 Установить право на запись для владельца%группы
S IXGRP 00010 Установить право на выполнение для владельца%группы
00007 Установить право на чтение, запись и выполнение для
остальных пользователей
S IROTH 00004 Установить право на чтение для остальных пользователей
S 00002 Установить право на запись для остальных пользователей
S_IXOTH 00001 Установить право на выполнение для остальных пользо%
вателей
www.books-shop.com
142 Глава 2. Среда программирования UNIX
Некоторые флаги, представленные в таблице, уже являются объединением
нескольких флагов. Так, например, флаг эквивалентен |
| S_IXUSR. Значение флага S_ISGID зависит от того, установле!
но или нет право на выполнение для группы В первом случае,
он будет означать установку SGID, а во втором — обязательное блокиро!
вание файла.
Для иллюстрации приведем небольшую программу, создающую файл с
полными правами доступа для владельца, а затем изменяющую их. После
каждой установки прав доступа в программе вызывается библиотечная
функция позволяющая запустить утилиту ls(l) и отобразить из!
менение прав доступа и дополнительных атрибутов.
ttinclude
<sys/stat.h>
<stdlib.h>
main
{
int fd;
/*Создадим файл с правами */
fd =
1
флаг
1
блокирование записей файла */
|
1
установим флаг
1
}
В результате запуска программы на выполнение, получим следующий вы!
вод:
$
rws
rws
rws
11
andy
andy
user
user
user
0
00
Jan
Jan
Jan
D
66
6
.
19:
19:
19:
; о
:28
:28
:28
my
my
my
file
file
file
Перемещение по файловой системе
Каждый процесс имеет два атрибута, связанных с файловой системой —
корневой каталог (root directory) и текущий рабочий каталог (current
working directory). Когда некоторый файл адресуется по имени (например,
в системных вызовах или ядро системы произ!
водит поиск файла, начиная с корневого каталога, если имя файла задано
как абсолютное, либо текущего каталога, если имя файла является относи!
www.books-shop.com
Работа с файлами
тельным. Абсолютное имя файла начинается с символа '/', обозначающего
корневой каталог. Все остальные имена файлов являются относительными.
Например, имя является абсолютным, в то время как
или — относительным, при котором фак!
тическое расположение файла в файловой системе зависит от текущего
Процесс может изменить свой корневой каталог с помощью системного
вызова или
int char
int
После этого поиск всех адресуемых файлов с абсолютными именами будет
производиться, начиная с нового каталога, указанного аргументом path.
Например, после изменения корневого каталога на домашний каталог
пользователя абсолютное имя скрипта станет
Изменение корневого каталога может потребоваться, например, при рас!
паковке архива, созданного с абсолютными именами файла, в другом мес!
те файловой системы, либо при работе над большим программным проек!
том, затрагивающим существенную часть корневой файловой системы. В
этом случае для отладочной версии удобно создать собственную корневую
иерархию.
Процесс также может изменить и текущий каталог. Для этого используют!
ся системные вызовы или
<unistd.h>
int char
int
Например, внутренняя команда командного интерпретатора может быть
реализована следующим кодом:
char
что имя нового каталога, введенного пользователем,
уже находится в переменной
== 1)
Изменение корневого каталога разрешено только для администратора системы — супер!
пользователя. Эта операция таит в себе определенную опасность, т. к. часть утилит опера!
ционной системы (если не все) могут оказаться недоступными, в том числе и команда
Таким образом, последствия необдуманного изменения корневого каталога
могут стать необратимыми.
www.books-shop.com
144 Глава 2. Среда программирования UNIX
Метаданные файла
Как уже говорилось, каждый файл помимо собственно данных содержит
метаданные, описывающие его характеристики, например, владельцев,
права доступа, тип и размер файла, а также содержащие указатели на фак!
тическое расположение данных файла. Метаданные файла хранятся в
структуре inode. Часть полей этой структуры могут быть получены с по!
мощью системных вызовов
<sys/stat.h>
int char struct stat
(const char struct stat
int fildes, struct stat
В качестве аргумента функции принимают имя файла или файловый деск!
риптор и возвращают заполненные поля структуры stat, которые
приведены в табл.
Таблица 2.15. Поля структуры stat
Поле Значение
mode t st mode Тип файла и права доступа
ino_t Номер inode. Поля st_ino и st_dev однозначно определя%
ют обычные файлы
Номер устройства, на котором расположен файл (номер уст%
ройства файловой системы)
dev t st dev
dev_t Для специального файла устройства содержит номер устрой%
ства, адресуемого этим файлом
t st Число жестких связей
uid t st uid Идентификатор пользователя%владельца файла
gid_t st_gid Идентификатор группы%владельца файла
Размер файла в байтах. Для специальных файлов устройств
это поле не определено
Время последнего доступа к файлу
Время последней модификации данных файла
off t st size
st_atime
time t st
time t st ctime Время последней модификации метаданных файла
long st blksize
long st_blocks
Оптимальный размер блока для операций Для
специальных файлов устройств и каналов это поле не опре%
делено
Число размещенных 512%байтовых блоков хранения данных.
Для специальных файлов устройств это поле не определено
Для определения типа файла служат следующие макроопределения, опи!
санные в файле <sys/stat.h>:
www.books-shop.com
Работа с файлами 145
Таблица 2.16. Определение типа файла
Макроопределение
S
S
S
S
Тип файла
FIFO
Специальный файл
Каталог
Специальный файл
Обычный файл
символьного устройства
блочного устройства
Символическая связь
Сокет
Все значения времени, связанные с файлом (время доступа, модифика!
ции данных и метаданных) хранятся в секундах, прошедших с 0 часов
января 1970 года. Заметим, что информация о времени создания файла
отсутствует.
Приведенная ниже программа выводит информацию о файле, имя кото!
рого передается ей в качестве аргумента:
<sys/stat.h>
#include <time.h>
argc, char
{
struct stat
char
, &s)
тип
) ptype = "Обычный файл";
else st_mode) ) ptype = "Каталог";
else ptype = связь";
else ptype = "Симв. устройство";
else ptype =
else ptype = "Сокет";
else ptype = "FIFO";
else ptype = "Неизвестный
информацию о
=
/*Права
= &
/*Номер inode*/
=
/*Число
=
/*Устройство, на котором хранятся данные
= (%d,
www.books-shop.com
Глава 2. Среда программирования UNIX
=
=
/*Для специальных файлов устройств — номера
= (%d,
=
доступа, модификации и модификации
=
=
=
}
Программа использует библиотечные функции и воз!
вращающие, соответственно, старший и младший номера устройства.
Функция преобразует системное время в удобный формат.
Запуск программы на выполнение приведет к следующим результатам:
$
type = Обычный файл
perm =
inode = 13
= 1
dev = (1,
= 286
= 100
rdev = (0, 0)
size = 1064
atime = Wed Jan 8 17:25:34 1997
mtime = Wed Jan 8 17:19:27 1997
ctime = Wed Jan 8 17:19:27 1997
$
13 1 andy user 1064 Jan 8 f с
Процессы
В главе 1 уже упоминались процессы. Однако знакомство ограничивалось
пользовательским, или командным интерфейсом операционной системы.
В этом разделе попробуем взглянуть на них с точки зрения программиста.
Процессы являются основным двигателем операционной системы. Боль!
шинство функций выполняется ядром требованию или иного процес!
са. Выполнение этих функций контролируется привилегиями процесса,
которые соответствуют привилегиям пользователя, запустившего его.
В этом разделе рассматриваются:
Идентификаторы процесса
www.books-shop.com
Процессы /47
Программный интерфейс управления памятью: системные вызовы
низкого уровня и библиотечные функции, позволяющие упростить
управление динамической памятью процесса.
Важнейшие системные вызовы, обеспечивающие создание нового
процесса и запуск новой программы. Именно с помощью этих вызо!
вов создается существующая популяция процессов в операционной
системе и ее функциональность.
Сигналы и способы управления ими. Сигналы можно рассматривать
как элементарную форму межпроцессного взаимодействия, позво!
ляющую процессам сообщать друг другу о наступлении некоторых
событий. Более мощные средства будут рассмотрены в разделе
"Взаимодействие между процессами" главы 3.
П Группы и сеансы; взаимодействие процесса с пользователем.
П Ограничения, накладываемые на процесс, и функции, которые по!
зволяют управлять этими ограничениями.
Идентификаторы процесса
Вы уже знаете, что каждый процесс характеризуется набором атрибутов и
идентификаторов, позволяющих системе управлять его работой. Важней!
шими из них являются идентификатор процесса PID и идентификатор ро!
дительского процесса PID является именем процесса в операцион!
ной системе, по которому мы можем адресовать его, например, при от!
правлении сигнала. PPID указывает на родственные отношения между
процессами, которые (как и в жизни) в значительной степени определяют
его свойства и возможности.
Однако нельзя не отметить еще четыре идентификатора, играющие ре!
шающую роль при доступе к системным ресурсам: идентификатор пользо!
вателя UID, эффективный идентификатор пользователя EUID, идентифи!
катор группы и эффективный идентификатор группы EGID. Эти
идентификаторы определяют права процесса в файловой системе, и как
следствие, в операционной системе в целом. Запуская различные команды
и утилиты, можно заметить, что порожденные этими командами процессы
полностью отражают права пользователя UNIX. Причина проста — все
процессы, которые запускаются, имеют идентификатор пользователя и
идентификатор группы. Исключение составляют процессы с установлен!
ными флагами и SGID.
При регистрации пользователя в системе утилита запускает ко!
мандный интерпретатор, — login shell, имя которого является одним из
атрибутов пользователя. При этом идентификаторам UID (EUID) и GID
(EGID) процесса shell присваиваются значения, полученные из записи
пользователя в файле паролей /etc/passwd. Таким образом, командный ин!
терпретатор обладает правами, определенными для данного пользователя.
www.books-shop.com
148 Глава 2. программирования UNIX
При запуске программы командный интерпретатор порождает процесс,
который наследует все четыре идентификатора и, следовательно, имеет те
же права, что и shell. Поскольку в конкретном сеансе работы пользователя
в системе прародителем всех процессов является login shell, то и их поль!
зовательские идентификаторы будут идентичны.
Казалось бы, эту стройную систему могут "испортить" утилиты с установ!
ленными флагами SUID и SGID. Но не стоит волноваться — как правило,
такие программы не позволяют порождать другие процессы, в противном
случае, эти утилиты необходимо немедленно уничтожить!
На рис. показан процесс наследования пользовательских идентифика!
торов в рамках одного сеанса работы.
Рис. 2.10. Наследование пользовательских идентификаторов
www.books-shop.com
Процессы 149
Для получения значений идентификаторов процесса используются сле!
дующие системные вызовы:
uid t
uid_t
gid_t
gid_t
Эти функции возвращают для сделавшего вызов процесса соответственно
реальный и эффективный идентификаторы пользователя и реальный и
эффективный идентификаторы группы.
Процесс также может изменить значения этих идентификаторов с помо!
щью системных вызовов:
ttinclude
<unistd.h>
int
int gid)
Системные вызовы и setgid(2) устанавливают сразу реальный и эф!
фективный идентификаторы, а системные вызовы и setegid(2) —
только эффективные.
Ниже приведен фрагмент программы изменяющей идентификато!
ры процесса на значения, полученные из записи файла паролей. В стан!
дартной библиотеке имеется ряд функций работы с записями файла паро!
лей, каждая из которых описывается структурой определенной в
файле <pwd.h>. Поля этой структуры приведены в табл. 2.17.
Таблица 2.17. Поля структуры passwd
Поле Значение
char Имя пользователя
char *pw_passwd Строка, содержащая пароль в зашифрованном виде; из со%
ображения безопасности в большинстве систем пароль хра%
нится в файле /etc/shadow, а это поле не используется
Идентификатор пользователя
gid_t Идентификатор группы
char Комментарий (поле GECOS), обычно реальное имя пользова%
теля и дополнительная информация
char Домашний каталог пользователя
char Командным
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 2. Средо программирования UNIX
Функция, которая потребуется для нашего примера, позволяет получить
запись файла паролей по имени пользователя. Она имеет следующий вид:
linclude <pwd.h>
struct passwd char
Итак, перейдем к фрагменту программы:
passwd *pw;
char
аргументов при запуске командного
char
командного
char
/*Проведем поиск записи пользователя с именем logname, которое
было введено на приглашение
pw =
/*Если пользователь с таким именем не найден, повторить
приглашение
if ( pw == 0 )
/*В противном случае установим идентификаторы процесса равными
полученным из файла паролей и запустим командный
else
{
arg,
}
Вызов execve(2) запускает на выполнение программу, указанную в первом
аргументе. Мы рассмотрим эту функцию в разделе "Создание и управление
процессами" далее в этой главе.
Выделение памяти
При обсуждении формата исполняемых файлов и образа программы в памя!
ти мы отметили, что сегменты данных и стека могут изменять свои размеры.
Если для стека операцию выделения памяти операционная система произ!
водит автоматически, то приложение имеет возможность управлять ростом
сегмента данных, выделяя дополнительную память из хипа (heap — куча).
Рассмотрим этот программный интерфейс.
Память, которая используется сегментами данных и стека, может быть вы!
делена несколькими различными способами как во время создания про!
цесса, так и динамически во время его выполнения. Существует четыре
способа выделения памяти:
www.books-shop.com
Процессы
1. Переменная объявлена как глобальная, и ей присвоено начальное зна!
чение в исходном тексте программы, например:
char ptype = "Unknown file type";
Строка ptype размещается в сегменте инициализированных данных
исполняемого файла, и для нее выделяется соответствующая память
при создании процесса.
2. глобальной переменной неизвестно на этапе компиляции,
например:
char
В этом случае место в исполняемом файле для ptype не
ся, но при создании процесса для данной переменной выделяется не!
обходимое количество памяти, заполненной нулями, в сегменте BSS.
Переменные автоматического класса хранения, используемые в функ!
циях программы, используют стек. Память для них выделяется при
вызове функции и освобождается при возврате. Например:
fund
{
int
char
static int с =
В примере переменные а и Ь размещаются в сегменте стека.
Переменная с размешается в сегменте инициализированных данных и
загружается из исполняемого файла либо во время создания процесса,
либо в процессе загрузки страниц по требованию. Более
страничный механизм описан в главе 3.
4. Выделение памяти явно запрашивается некоторыми системными вы!
зовами или библиотечными функциями. Например,
функция запрашивает выделение дополнительной памяти,
которая в используется для динамического
данных. Функция предоставляющая системное время в
удобном формате, также требует выделения памяти для размещения
строки, содержащей значения текущего времени, указатель на которую
возвращается программе.
Напомним, что дополнительная память выделяется из хипа (heap) — об!
ласти виртуальной памяти, расположенной рядом с сегментом данных,
размер которой меняется для удовлетворения запросов на размещение.
Следующий за сегментом данных адрес называется разделительным или
брейк!адресом (break address). Изменение размера сегмента данных по су!
ществу заключается в изменении брейк!адреса. Для изменения его
www.books-shop.com
752 Глава 2. Среда программирования UNIX
ния UNIX предоставляет процессу два системных вызова — brk(2) и
int
void
Системный вызов brk(2) позволяет установить значение брейк!адреса рав!
ным endds и, в зависимости от его значения, выделяет или освобождает
память (рис. 2.11). Функция sbrk(2) изменяет значение брейк!адреса на
величину incr. Если значение incr больше 0, происходит выделение па!
мяти, в противном случае, память
Рис. Динамическое выделение памяти с помощью brk(2)
Существуют четыре стандартные библиотечные функции, предназначен!
ные для динамического выделения/освобождения памяти.
<stdlib.h>
void
void size_t
void *ptr, size_t
void
Функция выделяет указанное аргументом size число байтов.
Функция calloc(3C) выделяет память для указанного аргументом nelem
числа объектов, размер которых elsize. Выделенная память инициализи!
руется нулями.
Функция realloc(3C) изменяет размер предварительно выделенной области
памяти (увеличивает или уменьшает, в зависимости от знака аргумента
size). Увеличение размера может привести к перемещению всей области в
Заметим, что в некоторых системах дополнительная память выделяется (или освобождает!
ся) в порциях, кратных размеру страницы. Например, выделение всего 100 байтов на са!
мом деле к выделению 4096 байтов, если размер страницы равен 4К.
www.books-shop.com
Процессы /53
другое место виртуальной памяти, где имеется необходимое свободное не!
прерывное виртуальное адресное пространство.
Функция free(3C) освобождает память, предварительно выделенную с по!
мощью функций или указатель на кото!
рую передается через аргумент ptr.
Указатель, возвращаемый функциями calloc(3C) и realloc(3C),
соответствующим образом выровнен, таким образом выделенная память
пригодна для хранения объектов любых типов. Например, если наиболее
жестким требованием по выравниванию в системе является размещение
переменных типа double по адресам, кратным 8, то это требование будет
распространено на все указатели, возвращаемыми этими функциями.
Упомянутые библиотечные функции обычно используют системные вызо!
вы sbrk(2) или brk(2). Хотя эти системные вызовы позволяют как выделять,
так и освобождать память, в случае библиотечных функций память реаль!
но не освобождается, даже при вызове free(3C). Правда, с помощью функ!
ций или можно снова выделить и исполь!
зовать эту память и снова освободить ее, но она не передается обратно яд!
ру, а остается в пуле
Для иллюстрации этого положения приведем небольшую программу, вы!
деляющую и освобождающую память с помощью функций и
free(3C), соответственно. Контроль действительного значения брейк!адреса
осуществляется с помощью системного вызова
#include
ttinclude <stdlib.h>
{
char
char
char
текущий
obrk =
брейкадрес=
64 байта из
naddr =
новый
nbrk =
адрес области Ox%x,
брейкадрес= Ох%х (увеличение на
naddr, nbrk, nbrk —
выделенную память и проверим, что произошло на
самом
obrk =
www.books-shop.com
2. программирования UNIX
"Новый брейк!адрес= Ох%х (увеличение на
obrk
}
Откомпилируем и запустим программу:
Ох20асО
адрес области = Ох20ас8, брейкадрес Ох22асО
на байтов)
(Ox20ac8)
Новый брейкадрес Ох22асО (увеличение на 0 байтов)
$
Как видно из вывода программы, несмотря на освобождение памяти
функцией free(3C), значение брейк!адреса не изменилось. Также можно
заметить, что функция выделяет больше памяти, чем требуется.
Дополнительная память выделяется для необходимого выравнивания и для
хранения внутренних данных таких как размер области, указа!
тель на следующую область и т. п.
Создание и управление процессами
Работая в командной строке shell вы, возможно, не задумывались, каким
образом запускаются программы. На самом деле каждый раз порождается
новый процесс, а затем загружается программа. В UNIX эти два этапа четко
разделены. Соответственно система предоставляет два различных системных
вызова: один для создания процесса, а другой для запуска новой программы.
Новый процесс порождается с помощью системного
. h>
или дочерний процесс, хотя это кажется странным, является
копией процесса, выполнившего этот вызов, или родительского
процесса. В частности, дочерний процесс наследует такие атрибуты роди!
теля, как:
Я идентификаторы пользователя и группы,
Я переменные окружения,
Я диспозицию сигналов и их обработчики,
Я ограничения, накладываемые на процесс,
Я текущий и корневой каталог,
Я маску создания файлов,
Я все файловые дескрипторы, включая файловые указатели,
Я управляющий терминал.
Более того, виртуальная память дочернего процесса не отличается от об!
раза родительского: такие же сегменты кода, данных, стека, разделяемой
www.books-shop.com
Процессы /56
памяти и т. д. После возврата из вызова который происходит и в
родительский и в дочерний процессы, оба начинают выполнять одну и
же инструкцию.
Легче перечислить немногочисленные различия между этими процессами,
а именно:
дочернему процессу присваивается уникальный идентификатор
идентификаторы родительского процесса PPID у этих процессов
различны,
О дочерний процесс свободен от сигналов, ожидающих доставки,
значение, возвращаемое системным вызовом fork(2) различно для
родителя и потомка.
Последнее замечание требует объяснения. Как уже говорилось, возврат из
функции происходит как в родительский, так и в дочерний про!
цесс. При этом возвращаемое родителю значение равно PID дочернего
процесса, а дочерний, в свою очередь, получает значение, равное 0. Если
возвращает !1, то это свидетельствует об ошибке (естественно, в
этом случае возврат происходит только в процесс, выполнивший систем!
ный вызов).
В возвращаемом fork(2) значении заложен большой смысл, поскольку оно
позволяет определить, кто является родителем, а кто — потомком, и соот!
ветственно разделить функциональность. Поясним это на примере:
/*Эта часть кода выполняется дочерним
}
else
часть кода выполняется родительским
}
}
Таким образом, порождение нового процесса уже не кажется
бессмысленным, поскольку родитель и потомок могут параллельно выпол!
нять различные В данном случае, это вывод на терминал раз!
личных сообщений, однако можно представить себе и более сложные при!
www.books-shop.com
156 Глава 2. Среда программирования UNIX
ложения. В частности, большинство серверов, одновременно обслужи!
вающих несколько запросов, организованы именно таким образом: при
поступлении запроса порождается процесс, который и выполняет необхо!
димую обработку. Родительский процесс является своего рода супервизо!
ром, принимающим запросы и распределяющим их выполнение. Очевид!
ным недостатком такого подхода является то, что вся функциональность
по!прежнему заложена в одном исполняемом файле и, таким образом, огра!
ничена.
UNIX предлагает системный вызов, предназначенный исключительно для
запуска программ, т. е. загрузки другого исполняемого файла. Это систем!
ный вызов представленный на программном уровне несколькими
модификациями:
int (const char const char *argO,
const char *argn, char *
int char char
int execle (const char argO [ ,
const char char * char
int execve (const char char argv [
char
int execlp (const char *file, const char *argO,
const char *argn, char *
int execvp (const char *file, char *const
Все эти функции по существу являются надстройками системного вызова
execve(2), который в качестве аргументов получает имя запускаемой про!
граммы (исполняемого файла), набор аргументов и список переменных
окружения. После выполнения не создается новый процесс, а
образ существующего полностью заменяется на образ, полученный из ука!
занного исполняемого файла. На рис. 2.12 показано, как связаны между
собой приведенные выше функции.
В отличие от fork(2), новая программа наследует меньше атрибутов.
В частности, наследуются:
идентификаторы процесса PID и PPID,
идентификаторы пользователя и группы,
эффективные идентификаторы пользователя и группы (в случае, ес!
ли для исполняемого файла не установлен флаг SUID или SGID),
П ограничения, накладываемые на процесс,
О текущий и корневой каталоги,
П маска создания файлов,
П управляющий терминал,
файловые дескрипторы, для которых не установлен флаг
FD CLOEXEC.
www.books-shop.com
Процессы 157
Рис. 2.12. Семейство функций ехес(2)
Наследование характеристик процесса играет существенную роль в работе
операционной системы. Так наследование идентификаторов владельцев
процесса гарантирует преемственность привилегий и, таким образом, неиз!
менность привилегий пользователя при работе в UNIX. Наследование фай!
ловых дескрипторов позволяет установить направления ввода/вывода для
нового процесса или новой программы. Именно так действует командный
интерпретатор. Мы вернемся к вопросу о наследовании в главе 3.
В главе 1 уже говорилось о частом объединении вызовов и ехес(2),
получившем специальное название Таким образом загружает!
ся подавляющее большинство программ, которые выполняются в системе.
www.books-shop.com
Глава 2. программирования
При порождении процесса, который впоследствии может загрузить новую
программу, "родителю" может быть небезынтересно узнать о завершении
выполнения "потомка". Например, после того как запущена утилита ls(l),
командный интерпретатор приостанавливает свое выполнение до заверше!
ния работы утилиты и только после этого выдает свое приглашение на эк!
ран. Можно привести еще множество ситуаций, когда процессам необходи!
мо синхронизировать свое выполнение с выполнением других процессов.
из способов такой синхронизации является обработка родителем
сигнала отправляемого ему при "смерти" потомка. Механизм сиг!
налов мы рассмотрим в следующем разделе. Сейчас же остановимся на дру!
гом подходе.
Операционная система предоставляет процессу ряд функций, позволяю!
щих ему контролировать выполнение потомков. Это функции
и
<sys/wait.h>
idtype, id_t id,
int options);
pid_t pid, int *stat_loc, int
Первый из этих вызовов обладает самой ограниченной функцио!
нальностью — он позволяет заблокировать выполнение процесса, пока
кто!либо из его непосредственных потомков не прекратит существование.
Вызов немедленно возвратит состояние уже завершившегося дочер!
процесса в переменной stat_loc, если последний находится в со!
стоянии зомби. Значение stat_loc может быть проанализировано с по!
мощью следующих макроопределений:
Возвращает истинное (ненулевое) значение, если про%
цесс завершился нормально.
Если WIFEXITED(status) не равно нулю, определяет код
возврата завершившегося процесса (аргумент функ%
ции
Возвращает истину, если процесс завершился по сиг%
налу.
Если WIFSIGNALLED(status) не равно нулю, определя%
ет номер сигнала, вызвавшего завершение выполне%
ния процесса.
Если WIFSIGNALLED(status) не равно нулю, макрос
возвращает истину в случае создания файла core.
Системный вызов предоставляет больше возможностей для кон!
троля дочернего процесса. Аргументы idtype и id определяют, за какими
из процессов требуется следить:
www.books-shop.com
Процессы /59
Значение аргумен[ Описание
та idtype
блокирует выполнение процесса, следя за потом%
ком, PID которого равен id.
waitid(2) блокирует выполнение процесса, следя за потом%
ками, идентификаторы группы которых равны id.
P_ALL блокирует выполнение процесса, следя за всеми
непосредственными потомками.
Аргумент options содержит флаги, объединенные логическим ИЛИ, оп!
ределяющие, за какими изменениями в состоянии потомков следит
Флаги аргумента
options
Описание
Предписывает ожидать завершения выполнения процесса.
Предписывает ожидать ловушки (trap) или точки останова
(breakpoint) для трассируемых процессов.
Предписывает ожидать останова процесса из%за получе%
ния сигнала.
Предписывает вернуть статус процесса, выполнение кото%
рого было продолжено после останова.
Предписывает завершить свое выполнение, если отсутст%
вует статусная информация (т. е. отсутствует ожидаемое
событие).
Предписывает получить статусную информацию, но не
уничтожать ее, оставив дочерний процесс в состоянии
ожидания.
Аргумент infop указывает на структуру siginfo_t, которая будет запол!
нена информацией о потомке. Мы рассмотрим эту структуру в следующем
разделе.
Функция как и функции и позволяет контроли!
ровать определенное множество дочерних процессов.
В заключение для иллюстрации описанных в этом разделе системных вы!
зовов приведем схему работы командного интерпретатора при запуске ко!
манды.
приглашение
/*Считать пользовательский
get
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
2. программирования UNIX
/*Произвести разбор ввода: выделить команду and и ее аргументы
and,
pid =
if (pid == 0)
{
/*3апустить
/*При нормальном запуске программы эта часть кода выполняться уже не бу
дет — можно смело выводить сообщение об
pexit
}
else
процесс (shell) ожидает завершения выполнения
Сигналы
Сигнал является способом передачи уведомления о некотором произо!
шедшем событии между процессами или между ядром системы и процес!
сами. Сигналы можно рассматривать, как простейшую форму межпро!
цессного взаимодействия, хотя на самом деле они больше напоминают
программные прерывания, при которых нарушается нормальное выполне!
ние процесса.
Сигналы появились уже в ранних версиях UNIX, но их реализация не бы!
ла достаточно надежной. Сигнал мог быть "потерян", возникали также
определенные сложности с отключением (блокированием) сигналов на
время выполнения критических участков кода. В последующие версии
системы, как BSD, так и System V, были внесены изменения, позволившие
реализовать надежные (reliable) сигналы. Однако модель сигналов, принятая
в версиях BSD, была несовместима с моделью версий System V. В настоя!
щее время стандарт POSIX.1 вносит определенность в интерфейс надеж!
ных сигналов.
Прежде всего, каждый сигнал имеет уникальное символьное имя и соот!
ветствующий ему номер. Например, сигнал прерывания, посылаемый про!
цессу при нажатии пользователем клавиши <Del> или <Ctrl>+<C>, имеет
имя SIGINT. Сигнал, генерируемый комбинацией <Ctrl>+<\>, называется
Седьмая редакция UNIX насчитывала 15 различных сигналов, а
в современных версиях их число увеличилось вдвое.
Сигнал может быть отправлен процессу либо ядром, либо другим процес!
сом с помощью системного вызова
ttinclude
<signal.h>
int t pid, int
www.books-shop.com
Процессы
Аргумент адресует процесс, которому посылается сигнал. Аргумент
определяет тип отправляемого сигнала.
К генерации сигнала могут привести различные ситуации:
Ядро отправляет процессу (или группе процессов) сигнал при нажа!
тии пользователем определенных клавиш или их комбинаций. На!
пример, нажатие клавиши <Del> (или приведет к от!
правке сигнала SIGINT, что используется для завершения процессов,
вышедших из!под
Аппаратные особые ситуации, например, деление на 0, обращение к
недопустимой области памяти и т. д., также вызывают генерацию
сигнала. Обычно эти ситуации определяются аппаратурой компью!
тера, и ядру посылается соответствующее уведомление (например, в
виде прерывания). Ядро реагирует на это отправкой соответствую!
щего сигнала процессу, который находился в стадии выполнения,
когда произошла особая ситуация.
П Определенные программные состояния системы или ее компонентов
также могут вызвать отправку сигнала. В отличие от предыдущего
случая, эти условия не связаны с аппаратной частью, а имеют чисто
программный характер. В качестве примера можно привести сигнал
SIGALRM, отправляемый процессу, когда срабатывает таймер, ранее
установленный с помощью вызова
С помощью системного вызова kill(2) процесс может послать сигнал как
самому себе, так и другому процессу или группе процессов. В этом случае
процесс, посылающий сигнал, должен иметь те же реальный и эффектив!
ный идентификаторы, что и процесс, которому сигнал отправляется. Разу!
меется, данное ограничение не распространяется на процессы, обладаю!
щие привилегиями суперпользователя. Такие процессы имеют возмож!
ность отправлять сигналы любым процессам системы.
Как уже говорилось в предыдущей главе, процесс может выбрать одно из
трех возможных действий при получении сигнала:
П игнорировать сигнал,
П перехватить и самостоятельно обработать
П позволить действие по умолчанию.
Текущее действие при получении сигнала называется диспозицией сигнала.
Напомним, что сигналы и SIGSTOP невозможно ни игнориро!
вать, ни перехватить. Сигнал SIGKILL является силовым методом завер!
шения выполнения "непослушного" процесса, а от работоспособности
SIGSTOP зависит функционирование системы управления заданиями.
Сигналы этого рода генерируются терминала. Настройка терминального драй!
вера позволяет связать условие генерации сигнала с любой клавишей.
www.books-shop.com
Глава 2. Среда программирования UNIX
Условия генерации сигнала и действие системы по умолчанию приведены
в табл. 2.18. Как видно из таблицы, при получении сигнала в большинстве
случаев по умолчанию происходит завершение выполнения процесса. В
случаев в текущем рабочем каталоге процесса также создается файл
core (в таблице такие случаи отмечены как в котором
хранится образ памяти процесса. Этот файл может быть впоследствии про!
анализирован программой!отладчиком для состояния процес!
са непосредственно перед завершением. Файл core не будет создан в сле!
случаях:
исполняемый файл процесса имеет установленный бит и ре!
альный владелец!пользователь процесса не является владельцем!
пользователем исполняемого файла;
О исполняемый файл процесса имеет установленный бит SGID, и ре!
альный владелец!группа процесса не является владельцем!группой
исполняемого файла;
П процесс не имеет права записи в текущем рабочем каталоге;
D размер файла core слишком велик (превышает допустимый предел
см. раздел "Ограничения" далее в этой главе).
Таблица 2.18. Сигналы
Название Действие по
умолчанию
Значение
Сигнал отправляется, если процесс вызывает
системный вызов
Завершить Сигнал отправляется, когда срабатывает тай%
мер, ранее установленный с помощью систем%
ных вызовов alarm(2) или setitimer(2).
Завершить+соге Сигнал свидетельствует о некоторой аппаратной
ошибке. Обычно этот сигнал отправляется при об%
ращении к допустимому виртуальному адресу, для
которого отсутствует соответствующая физическая
страница. Другой случай генерации этого сигнала
упоминался при обсуждении файлов, отображае%
мых в память (сигнал отправляется процессу при
попытке обращения к странице памя%
ти, лежащей за пределами файла).
Игнорировать Сигнал, посылаемый родительскому процессу
при завершении выполнения его потомка.
Завершить+соге Сигнал свидетельствует о попытке обращения к
недопустимому адресу или к области памяти, для
которой у процесса недостаточно привилегий.
Завершить+соге Сигнал свидетельствует о возникновении осо%
бых ситуаций, таких как деление на 0 или пере%
полнение операции с плавающей точкой.
www.books-shop.com
Процессы
Таблица 2.18 (продолжение)
Название
SIGQUIT
Действие по
умолчанию
Значение
Завершить Сигнал посылается лидеру сеанса, связанному
с управляющим терминалом, когда ядро обна%
руживает, что терминал отсоединился (потеря
линии). Сигнал также посылается всем процес%
сам текущей группы при завершении выполне%
ния лидера.
Этот сигнал иногда используется в качестве
простейшего средства межпроцессного взаи%
модействия. В частности, он применяется для
сообщения демонам о необходимости обновить
конфигурационную информацию. Причина вы%
бора именно сигнала SIGHUP заключается в
том, что демон по определению не имеет управ%
ляющего терминала и, соответственно, обычно
не получает этого сигнала.
SIGILL
SIGINT Завершить
Сигнал посылается ядром, если процесс попы%
тался выполнить недопустимую инструкцию.
Сигнал посылается ядром всем процессам те%
кущей группы при нажатии клавиши прерывания
<Ctrl>+<C>).
Завершить Сигнал, при получении которого выполнение
процесса завершается. Этот сигнал нельзя ни
перехватить, ни игнорировать.
SIGPIPE Завершить Сигнал посылается при попытке записи в канал
или сокет, получатель данных которого завер%
шил выполнение (закрыл соответствующий де%
скриптор).
Завершить Сигнал отправляется при наступлении опреде%
ленного события для устройства, которое явля%
ется опрашиваемым.
Игнорировать Сигнал генерируется при угрозе потери питания.
Обычно он отправляется, когда питание системы
переключается на источник бесперебойного
питания (UPS).
Завершить+соге Сигнал посылается ядром всем процессам те%
кущей группы при нажатии клавиш <Ctrl>+<\>.
SIGSTOP Остановить Сигнал отправляется всем процессам текущей
группы при нажатии пользователем клавиш
<Ctrl>+<Z>. Получение сигнала вызывает оста%
нов выполнения процесса.
Завершить+соге Сигнал отправляется ядром при попытке недо%
пустимого системного вызова.
www.books-shop.com
164 Глава 2, программирования UNIX
Таблица 2.18 (окончание)
Название
SIGTERM
SIGTTIN
SIGTTOU
Действие по
умолчанию
Завершить
Остановить
Остановить
Завершить
Завершить
Значение
Сигнал обычно представляет своего рода пре%
дупреждение, что процесс вскоре будет уничто%
жен. Этот сигнал позволяет процессу соответст%
вующим образом "подготовиться к смерти" —
удалить временные файлы, завершить необхо%
димые транзакции и т. д. Команда kill(1) по
умолчанию отправляет именно этот сигнал.
Сигнал генерируется ядром (драйвером терми%
нала) при попытке процесса фоновой группы
осуществить чтение с управляющего терминала.
Сигнал генерируется ядром (драйвером терми%
нала) при попытке процесса фоновой группы
осуществить запись на управляющий терминал.
Сигнал предназначен для прикладных задач как
простейшее средство межпроцессного взаимо%
действия.
Сигнал предназначен для прикладных задач как
простейшее средство межпроцессного взаимо%
действия.
Простейшим интерфейсом к сигналам UNIX является устаревшая, но по!
прежнему поддерживаемая в большинстве систем функция Эта
функция позволяет изменить диспозицию сигнала, которая по умолчанию
устанавливается ядром UNIX. Порожденный вызовом fork(2) процесс на!
следует диспозицию сигналов от своего родителя. Однако при вызове
ехес(2) диспозиция всех перехватываемых сигналов будет установлена на
действие по умолчанию. Это вполне естественно, поскольку образ новой
программы не содержит функции!обработчика, определенной диспозици!
ей сигнала перед вызовом ехес(2). Функция имеет следующее
определение:
<signal.h>
void (*signal (int sig, void
Аргумент sig определяет сигнал, диспозицию которого нужно изменить.
Аргумент определяет новую диспозицию сигнала, которой может
быть определенная пользователем функция!обработчик или одно из сле!
дующих значений:
SIG_DFL Указывает ядру, что при получении процессом сигнала необходимо
вызвать системный обработчик, т. е. выполнить действие по умолчанию.
Указывает, что сигнал следует игнорировать. Напомним, что не все сиг%
налы можно игнорировать.
www.books-shop.com
Процессы
В случае успешного завершения возвращает предыдущую диспо!
зицию — это может быть функция!обработчик сигнала или системные
значения или Возвращаемое значение может быть ис!
пользовано для восстановления диспозиции в случае необходимости.
Использование функции подразумевает семантику устаревших
или ненадежных сигналов. Процесс при этом имеет весьма слабые воз!
можности управления сигналами. Во!первых, процесс не может заблоки!
ровать сигнал, т. е. отложить получение сигнала на период выполнения
критического участка кода. Во!вторых, каждый раз при получении сигна!
ла, его диспозиция устанавливается на действие по умолчанию. Данная
функция и соответствующая ей семантика сохранены для поддержки ста!
рых версий приложений. В связи с этим в новых приложениях следует из!
бегать использования функции signal(3C). Тем не менее для простейшей
иллюстрации использования сигналов, приведенный ниже пример исполь!
зует именно этот интерфейс:
<signal.h>
static void signo)
{
сигнал
{
pause
В этом примере изменена диспозиция трех сигналов: SIGINT, SIGUSR1 и
При получении сигнала SIGINT вызывается обработчик
при получении сигнала SIGUSR1 производится действие по
умолчанию (процесс завершает работу), а сигнал игнорируется.
После установки диспозиции сигналов процесс запускает бесконечный
цикл, в процессе которого вызывается функция При получении
сигнала, который не игнорируется, возвращает значение !1, а пере!
менная errno устанавливается равной EINTR. Заметим, что каждый раз при
получении сигнала SIGINT мы вынуждены восстанавливать требуемую дис!
позицию, в противном случае получение следующего сигнала этого типа
вызвало бы завершение выполнения процесса (действие по умолчанию).
www.books-shop.com
Глава 2. Среда программирования UNIX
При запуске программы, получим следующий результат:
$ &
[1] 8365 PID порожденного процесса
$ kill !SIGINT 8365
Получен сигнал SIGINT Сигнал SIGINT перехвачен
$ kill 8365 Сигнал SIGUSR2 игнорируется
$ kill !SIGUSR1 8365
User Signal 1 Сигнал SIGUSR1 вызывает завер[
• шение выполнения процесса
$
Для отправления сигналов процессу использована команда описан!
ная в предыдущей главе.
Надежные сигналы
Стандарт POSIX. 1 определил новый набор функций управления сигнала!
на интерфейсе UNIX и лишенный рассмотренных
выше недостатков.
Модель сигналов, предложенная POSIX, основана на понятии набора сиг!
налов (signal set), описываемого переменной типа sigset_t. Каждый бит
этой переменной отвечает за один сигнал. Во многих тип
имеет длину 32 бита, ограничивая количество возможных сигна!
лов числом 32.
Следующие функции позволяют управлять наборами сигналов:
frinclude
int
*set, int
int *set, int signo);
int *set, int
В отличие от функции изменяющей диспозицию сигналов, дан!
позволяют модифицировать структуру данных sigset t,
определенную процессом. Для управления непосредственно сигналами ис!
дополнительные функции, которые мы рассмотрим позже.
Функция инициализирует набор, очищая все биты. Если
процесс вызывает то набор будет включать все сигналы, из!
вестные системе. Функции sigaddset(3C) и позволяют добавлять
или удалять сигналы набора. Функция позволяет прове!
рить, входит ли указанный параметром signo сигнал в набор.
Вместо функции стандарт 1 определяет функцию
позволяющую установить диспозицию сигналов, узнать ее те!
кущее значение или сделать и то и другое одновременно. Функция имеет
следующее определение:
www.books-shop.com
Процессы 167
<signal.h>
int sigaction (int sig, const struct sigaction *act,
struct sigaction
Вся необходимая для управлением сигналами информация передается че!
рез указатель на структуру sigaction, имеющую следующие поля:
void (*sa_handler) () Обработчик сигнала sig
void (int, siginfo_t *, void *) Обработчик сигнала sig
при установленном флаге
sigset_t Маска сигналов
int Флаги
Поле определяет действие, которое необходимо предпринять
при получении сигналов, и может принимать значения SIG_DFL
или адреса функции!обработчика. Если значение или
sa sigaction не равны NULL, то в поле передается набор сигна!
лов, которые будут добавлены к маске сигналов перед вызовом обработчика.
Каждый процесс имеет установленную маску сигналов, определяющую сиг!
налы, доставка которых должна быть заблокирована. Если определенный
бит маски установлен, соответствующий ему сигнал будет заблокирован.
После возврата из функции!обработчика значение маски возвращается
к исходному значению. Заметим, что сигнал, для которого установлена
функция!обработчик, также будет заблокирован перед ее вызовом. Такой
подход гарантирует, что во время обработки, последующее поступление оп!
ределенных сигналов будет приостановлено до завершения функции. Как
правило, UNIX не поддерживает очередей сигналов, и это значит, что бло!
кировка нескольких однотипных сигналов в конечном итоге вызовет достав!
ку одного.
Поле определяет флаги, модифицирующие доставку сигнала.
Оно может принимать следующие значения:
Если определена функция%обработчик сигнала, и с помощью функции
sigaltstack(2) задан стек для функции%обработчика,
то при обработке сигнала будет использоваться этот стек. Если флаг
не установлен, будет использоваться обычный стек процесса.
SA_RESETHAND* Если определена функция%обработчик, то диспозиция сигнала
будет изменена на SIG_DFL, и сигнал не будет блокироваться
при запуске обработчика. Если флаг не установлен, диспозиция
сигнала остается неизменной.
SA_NODEFER Если определена функция%обработчик, то сигнал блокируется на
время обработки только в том случае, если он явно указан в по%
ле sa mask. Если флаг не установлен, в процессе обработки
данный сигнал автоматически блокируется.
* Данные флаги не определены для UNIX BSD.
www.books-shop.com
168 Глава 2. Средо программирования UNIX
SA_RESTART Если определена функция%обработчик, ряд системных вызовов,
выполнение которых было прервано полученным сигналом, будут
автоматически перезапущены после обработки Если
флаг не установлен, системный вызов возвратит ошибку
Если диспозиция указывает на перехват сигнала, вызывается
функция, адресованная полем Если флаг не
установлен, вызывается обработчик sa_handler.
Если указанный аргументом sig сигнал равен SIGCHLD, при за%
вершении потомки не будут переходить в состояние зомби. Если
процесс в дальнейшем вызовет функции wait3(2),
или их выполнение будет блокировано до за%
вершения работы всех потомков данного процесса.
SA_NOCLDSTOP* Если указанный аргументом sig сигнал равен SIGCHLD, указан%
ный сигнал не будет отправляться процессу при завершении или
останове любого из его потомков.
В системах UNIX BSD 4.x структура sigaction имеет следующий вид:
struct sigaction {
void
sigset_t
int
где функция!обработчик определена следующим образом:
void signo, int code, struct sigcontext
В первом аргументе signo содержится номер сигнала, code определяет
дополнительную информацию о причине поступления сигнала, a scp ука!
зывает на контекст процесса.
Для UNIX System V реализована следующая возможность получения более
полной информации о сигнале. Если установлен флаг SA_SIGINFO, то при
получении сигнала sig будет вызван обработчик, адресованный полем
Помимо номера сигнала, обычно передаваемого обработ!
чику сигнала, ему будет переданы указатель на структуру siginfo_t, со!
держащую информацию о причинах получения сигнала, а также указатель
на структуру содержащую контекст процесса.
Структура siginfo_t определена в файле <siginfo.h> и включает следую!
щие поля:
int Номер сигнала
int si_errno Номер ошибки
int si_code Причина отправления сигнала
К таким системным вызовам, в частности, относятся и для медленных уст!
ройств, таких как терминалы, а также ioctl(2), и
www.books-shop.com
Процессы
В поле si_signo хранится номер сигнала. Поле si_code имеет следую!
щий смысл: если его значение меньше или равно нулю, значит сигнал был
отправлен прикладным процессом, в этом случае структура siginfo_t
содержит также следующие поля:
pid_t si_pid
uid t si uid
Идентификатор процесса
Идентификатор пользователя UID
которые адресуют процесс, пославший сигнал; если значение si_code
больше нуля, то оно указывает на причину отправления сигнала. Список
возможных значений si_code для некоторых сигналов, соответствующих
полю si_signo, приведен в табл. 2.19
Таблица 2.19. Значения поля si_code структуры для некоторых сигналов
Значение поля
si_signo
Значение поля si code Описание
SIGILL Попытка выполнения недопустимой инструкции
ILL_ILLOPN
ILL ILLTRP
ILL PRVOPC
Недопустимый код операции
(opcode)
Недопустимый операнд
Недопустимый режим адресации
Недопустимая ловушка (trap)
Привилегированный код опера%
ции
Привилегированный регистр
Ошибка сопроцессора
Ошибка внутреннего стека
SIGFPE Особая ситуация операции с плавающей точкой
FPE INTDIV
FPE_INTOVF
FPE_FLTDIV
FPE_FLTOVF
FPE FLTUND
FPE FLTRES
FPE FLTINV
FPE_FLTSUB
Целочисленное деление на ноль
Целочисленное переполнение
Деление на ноль с плавающей
точкой
Переполнение с плавающей точ%
кой
Потеря точности с плавающей
точкой (underflow)
Неоднозначный результат опе%
рации с плавающей точкой
Недопустимая операция с пла%
вающей точкой
Индекс вне
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
/70 Глава 2. программирования UNIX
Таблица 2.19 (продолжение)
Значение поля
si signo
Значение поля si code Описание
SIGSEGV Нарушение сегментации
SEGV MAPPER
SEGV ACCERR
Адрес не отображается на объект
Недостаточно прав на
объект
отобра%
SIGBUS Ошибка адресации
BUS ADRALN
BUS ADRERR
BUS OBJERR
Недопустимое выравнивание
адреса
Несуществующий физический
адрес
Аппаратная ошибка, связанная
с объектом
SIGTRAP Ловушка
TRAP
TRAP TRACE
Процессом
останова
достигнута точка
Ловушка трассирования про%
цесса
SIGCHLD Завершение выполнения дочернего процесса
CLD_EXITED
CLD KILLED
CLD DUMPED
CLD TRAPPED
CLD STOPPED
CLD CONTINUED
Дочерний процесс завершил
выполнение
Дочерний процесс был "убит"
Ненормальное завершение до%
чернего процесса
Трассируемый дочерний про%
цесс находится в ловушке
Выполнение дочернего процес%
са было остановлено
Выполнение остановленного
дочернего процесса было про%
должено
SIGPOLL Событие на опрашиваемом устройстве
POLL IN
POLL OUT
POLL_MSG
POLL ERR
POLL_PRI
POLL HUP
Поступили данные для ввода
Свободны буферы данных
Сообщение ожидает ввода
Ошибка
Высокоприоритетные данные
ожидают ввода
Устройство отключено
www.books-shop.com
Процессы 171
Уже отмечалось, что при получении сигнала от пользовательского процес!
са структура содержит дополнительные поля (табл. 2.20).
Таблица 2.20. Дополнительные поля структуры siginfo_t
Значение поля
si signo
SIGILL
SIGFPE
SIGSEGV
SIGBUS
SIGCHLD
SIGPOLL
Дополнительные поля
t
t
int
long
si addr
si addr
si pid
si status
si band
Значение
Адрес недопустимой инст%
рукции
Адрес недопустимой области
памяти
Идентификатор дочернего
процесса
Код возврата сигнала
Ошибка канала (для модулей
STREAMS)
Установить маску сигналов или получить текущую маску можно с помо!
щью функции
tinclude <signal.h>
int how, *set,
Маска сигналов изменяется в соответствии с аргументом how, который
может принимать следующие значения:
Результирующая маска получится путем те%
кущей маски и набора set
Сигналы набора будут удалены из текущей маски
Текущая маска будет заменена на набор set
Если указатель set равен NULL, то аргумент how игнорируется. Если аргу!
мент oset не равен NULL, то в набор, адресованный этим аргументом, по!
мещается текущая маска сигналов.
Функция используется для получения набора заблокирован!
ных сигналов, ожидающих доставки:
<signal.h>
int
Список сигналов, ожидающих доставки, возвращается в наборе, адресо!
ванном аргументом set.
Системный вызов замещает текущую маску набором, адресо!
ванным аргументом set, и приостанавливает выполнение процесса до по!
лучения сигналов, диспозиция которых установлена либо на завершение
выполнения процесса, либо на вызов функции!обработчика сигнала.
www.books-shop.com
2. программирования UNIX
ttinclude <signal.h>
int sigset_t
При получении сигнала, завершающего выполнение процесса, возврата из
функции не происходит. Если же диспозиция полученного
сигнала установлена на вызов функции!обработчика, возврат из
происходит сразу после завершения обработки сигнала. При
этом восстанавливается маска, существовавшая до вызова
Заметим, что в BSD UNIX вызов является упрощенным интерфей!
сом к более общей функции в то время как в ветви System V
подразумевает использование старой семантики ненадежных сигна!
лов.
В заключение для иллюстрации изложенных соображений, приведем вер!
сию функции позволяющую использовать надежные сигналы. По!
хожая реализация используется в BSD UNIX. С помощью этой "надежной"
версии мы повторим пример, рассмотренный нами выше, в измененном
виде.
ttinclude <signal.h>
ttinclude
ttinclude <sys/stat.h>
ttinclude <fcntl.h>
ttinclude <unistd.h>
/*Вариант "надежной" функции */
void (*mysignal (int signo, void (*hndlr) (int)
{
struct sigaction act, oact;
/*Установим маску
=
= 0;
if (signo != SIGALRM)
lags |=
/*Установим
< 0)
}
/*Функцияобработчик
static void signo)
{
/* Эта часть кода нам уже не нужна
(SIGINT,
*/
printf ( "Получен сигнал
www.books-shop.com
Процессы
mysignal (SIGUSR2,
}
Заметим, что при использовании надежных сигналов, не нужно восстанав!
ливать диспозицию в функции!обработчике при получении сигнала.
Группы и сеансы
После создания процесса ему присваивается уникальный идентификатор,
возвращаемый системным вызовом fork(2) родительскому процессу. До!
полнительно ядро назначает процессу идентификатор группы процессов
(process group ID). Группа процессов включает один или более процессов и
существует, пока в системе присутствует хотя бы один процесс этой груп!
пы. Временной интервал, начинающийся с создания группы и заканчи!
вающийся, когда последний процесс ее покинет, называется временем
жизни группы. Последний процесс может либо завершить свое выполне!
ние, либо перейти в другую группу.
Многие системные вызовы могут быть применены как к единичному про!
цессу, так и ко всем процессам группы. Например, системный вызов kill(2)
может отправить сигнал как одному процессу, так и всем процессам ука!
занной группы. Точно так же функция позволяет родительскому
процессу ожидать завершения конкретного процесса или любого процесса
группы.
Каждый процесс, помимо этого, является членом сеанса (session), являю!
щегося набором одной нескольких групп процессов. Понятие сеанса
было введено в UNIX для логического объединения процессов, а точнее,
групп процессов, созданных в результате регистрации и последующей ра!
боты пользователя в системе. Таким образом, термин "сеанс работы" в сис!
теме тесно связан с понятием сеанса, описывающего набор процессов, ко!
торые порождены пользователем за время пребывания в системе.
Процесс имеет возможность определить идентификатор собственной груп!
пы процессов или группы процесса, который является членом того же се!
анса. Для этого используются два системных вызова: getpgrp(2) и
ttinclude
ttinclude
pid_t
www.books-shop.com
Глава 2. UNIX
Аргумент pid, который передается функции адресует процесс,
идентификатор группы которого требуется узнать. Если этот процесс не
принадлежит к тому же сеансу, что и процесс, сделавший системный вы!
зов, функция возвращает ошибку.
Системный вызов setpgid(2) позволяет процессу стать членом существую!
щей группы или создать новую группу.
ttinclude <unistd.h>
int pid, pid_t
Функция устанавливает идентификатор группы процесса pid равным
pgid. Процесс имеет возможность установить идентификатор группы для
себя и для своих потомков (дочерних процессов). Однако процесс не мо!
жет изменить идентификатор группы для дочернего процесса, который
выполнил системный вызов ехес(2), запускающий на выполнение другую
программу.
Если значения обоих аргументов равны, то создается новая группа с иден!
тификатором pgid, а процесс становится лидером (group leader) этой груп!
пы. Поскольку именно таким образом создаются новые группы, их иден!
тификаторы гарантированно уникальны. Заметим, что группа не удаляется
при завершении ее лидера, пока в нее входит хотя бы один процесс.
Идентификатор сеанса можно узнать с помощью функции
ttinclude
#include
pid_t getsid(pid_t
Как и в случае с группой, идентификатор pid должен адресовать процесс,
являющийся членом того же сеанса, что и процесс, вызвавший getsid(2).
Заметим, что эти ограничения не распространяются на процессы, имею!
щие привилегии суперпользователя.
Вызов функции приводит к созданию нового сеанса:
#include
pid_t
Новый сеанс создается лишь при условии, что процесс не является лиде!
ром какого!либо сеанса. В случае успеха процесс становится лидером се!
анса и лидером новой группы.
Понятия группы и сеанса тесно связаны с терминалом или, точнее, с
драйвером терминала. Каждый сеанс может иметь один ассоциированный
терминал, который называется управляющим терминалом (controlling
terminal), а группы, созданные в данном сеансе, наследуют этот управ!
www.books-shop.com
Процессы
терминал. Наличие управляющего терминала позволяет ядру кон!
тролировать стандартный ввод/вывод процессов, а также дает возможность
отправить сигнал всем процессам ассоциированной с терминалом группы,
например, при его отключении. Типичным примером является регистрация
и работа пользователя в системе. При входе в систему терминал пользовате!
ля становится управляющим для лидера сеанса (в данном случае для ко!
мандного интерпретатора shell) и всех процессов, порожденных лидером
(в данном случае для всех процессов, которые запускает пользователь из ко!
мандной строки интерпретатора). При выходе пользователя из системы shell
завершает свою работу и таким образом отключается от управляющего тер!
минала, что вызывает отправление сигнала SIGHUP всем незавершенным
процессам текущей группы. Это гарантирует, что после завершения работы
пользователя в системе не останется запущенных им
Текущие и фоновые группы процессов
Как было показано, для каждого управляющего терминала существует се!
анс, включающий одну или несколько групп процессов. Одна из этих
групп является текущей (foregroud group), а остальные фоновыми
(background Сигналы SIGINT и SIGQUIT, которые генерируются
драйвером терминала, посылаются всем процессам текущей группы. По!
пытка процессов фоновых групп осуществить доступ к управляющему
терминалу, как правило, вызывает отправление им сигналов SIGSTP,
SIGTTIN ИЛИ
Рассмотрим следующие команды:
$ find / name &
$ cat | sort
При этом происходит чтение ввода пользователя с клавиатуры и
сортировка введенных данных Если интерпретатор поддерживает
управление заданиями, оба процесса, созданные для программ cat(l) и
sort(l), будут помещены в отдельную группу. Это подтверждается выводом
команды
не менее в системе будут продолжать выполняться процессы, запущенные в фоновом
режиме. Это также не справедливо для демонов — процессов, являющихся
нами сеанса, имеющего управляющего терминала. Система не имеет возможности авто!
матического отправления сигнала таким процессам при выходе пользователя, и они
будут продолжать выполняться даже после завершения пользователем работы в Для
"превращения" процесса в демона, он должен воспользоваться функцией и создать
новый сеанс, которого он автоматически окажется и который не будет ассоцииро!
ван с управляющим терминалом. Эти вопросы будут более подробно обсуждены при иллю!
страции программы!демона в этой главе.
Наличие текущей и фоновых групп в сеансе работы пользователя зависит от
возможности командного интерпретатора управлять заданиями (job control). При отсутст!
вии этой возможности все процессы будут выполняться в той же группе, что и shell.
www.books-shop.com
Глава 2. программирования UNIX
andy
andy
2436
2431
2407
2435
SID С
2407
2407
2405
2407
2435
2431
2407
2435
2407
2407
2407
2407
1
0
0
0
15:51:30
15:51:25
15:31:09
15:51:30
TTY
ttyOl
ttyOl
TIME
0:00
0:00
0:00
0:00
CMD
sort
find / name foo
sh
cat
Все четыре процесса (sh, find, cat и sort) имеют один и тот же идентифика!
тор сеанса, связанного с управляющим терминалом ttyOl. Процессы
и принадлежат одной группе, идентификатор которой (2435) отли!
чен от идентификатора группы командного интерпретатора (2407). То же
самое можно сказать и о процессе find(l), который является лидером от!
дельной группы (2431). Можно также заметить, что процессы
и являются лидерами групп, a еще и лидером сеанса.
Хотя команда ps(l) не указывает, какие группы являются фоновыми, а какая
текущей, синтаксис команд позволяет утверждать, что командный интерпре!
татор помещает cat(l) и в текущую группу. Это, во!первых, позволяет
процессу cat(l) читать данные со стандартного потока ввода, связанного с
терминалом ttyOl. Во!вторых, пользователь имеет возможность завершить
выполнение обоих процессов путем нажатия клавиши <Del> (или
что вызовет генерацию сигнала SIGINT. Получение процесса!
ми этого сигнала вызовет завершение их выполнения (действие по умолча!
нию), если, конечно, процесс не установил игнорирование SIGINT. На
рис. представлена схема взаимодействия управляющего терминала, се!
анса и групп процессов для приведенного выше примера. Более детально вза!
имосвязь между терминалом и процессами рассмотрена в следующей главе.
Рис. 2.13. Связь между управляющим терминалом, сеансом и группами
$ ps !efj | egrep
www.books-shop.com
Процессы
Если командный интерпретатор не поддерживает управление заданиями,
оба процесса станут членами той же группы, что и сам shell. В этом случае
командный интерпретатор должен позаботиться об игнорировании сигна!
лов SIGINT и чтобы допустимые действия пользователя (такие
как нажатие клавиши <Del> или <Ctrl>+<C>) не привели к завершению
выполнения shell и выходу из системы.
Ограничения
UNIX является многозадачной системой. Это значит, что несколько процес!
сов конкурируют между собой при доступе к различным ресурсам. Для
"справедливого" распределения разделяемых ресурсов, таких как память,
дисковое пространство и т. п., каждому процессу установлен набор ограни!
чений. Эти ограничения не носят общесистемного характера, как, напри!
мер, максимальное число процессов или областей, а устанавливаются для
каждого процесса отдельно. Для получения информации о текущих ограни!
чениях и их изменения предназначены системные вызовы и
ttinclude
int resource, struct rlimit
int resource, const struct rlimit
Аргумент resource определяет вид ресурса, для которого мы хотим узнать
или изменить ограничения процесса. Структура rlimit состоит из двух
полей:
определяющих, соответственно, изменяемое (soft) и жесткое (hard) ограни!
чение. Первое определяет текущее ограничение процесса на данный ре!
сурс, а второе — максимальный возможный предел потребления ресурса.
Например, изменяемое ограничение на число открытых процессом файлов
может составлять 64, в то время как жесткое ограничение равно 1024.
Любой процесс может изменить значение текущего ограничения вплоть до
максимально возможного предела. Жесткое ограничение может быть из!
менено в сторону увеличения предела потребления ресурса только процес!
сом с привилегиями суперпользователя. Обычные процессы могут только
уменьшить значение жесткого ограничения. Обычно ограничения устанав!
ливаются при инициализации системы и затем наследуются порожденны!
ми процессами (хотя в дальнейшем могут быть изменены).
Вообще говоря, максимальный возможный предел потребления ресурса
может иметь бесконечное значение. Для этого необходимо установить зна!
чение rlim_max равным RLIM_INFINITY. В этом случае физические огра!
ничения системы (например, объем памяти и дискового пространства) бу!
дут определять реальный предел использования того или иного ресурса.
Различные ограничения и связанные с ними типы ресурсов приведены в
табл. 2.21.
www.books-shop.com
178 Глава 2. Среда программирования UNIX
Таблица 2.21. Ограничения процесса (значения аргумента resource)
Ограничение Тип ресурса Эффект
Максимальный размер соз%
даваемого файла core, со%
держащего образ памяти
процесса. Если предел уста%
новлен равным 0, файл core
создаваться не будет.
После создания файла core за%
пись в этот файл будет останов%
лена при достижении предельно%
го размера.
Максимальное время исполь%
зования процессора в секун%
дах.
При превышении предела про%
цессу отправляется сигнал
SIGXCPU.
Максимальный размер сег%
мента данных процесса в бай%
тах, т. е. максимальное значе%
ние смещения брейк%адреса.
При достижении этого предела
последующие вызовы функции
brk(2) завершатся с ошибкой
FSIZE Максимальный размер фай%
ла, который может создать
процесс. Если значение этого
предела равно 0, процесс не
может создавать файлы.
При достижении этого предела
процессу отправляется сигнал
SIGXFSZ. Если сигнал перехва%
тывается или игнорируется про%
цессом, последующие попытки
увеличить размер файла закон%
чатся С Ошибкой EFBIG.
RLIMIT NOFILE Максимальное количество
назначенных файловых деск%
рипторов процесса.
При достижении этого предела,
последующие попытки получить
новый файловый дескриптор
закончатся с ошибкой EMFILE.
RLIMIT STACK Максимальный размер стека
процесса.
При попытке расширить стек за
установленный предел отправля%
ется сигнал SIGSEGV. Если про%
цесс перехватывает или игнори%
рует сигнал и не использует аль%
тернативный стек с помощью
функции диспози%
ция сигнала устанавливается на
действие по умолчанию перед
отправкой процессу.
Максимальный размер ото%
бражаемой памяти процесса
в байтах. (Предел определен
в версиях System V.)
При достижении этого предела
последующие вызовы brk(2) или
завершатся с ошибкой
ENOMEM.
RLIMIT NPROC Максимальное число процес%
сов с одним реальным
Определяет максимальное
число процессов, которые мо%
жет запустить пользователь.
(Предел определен в версиях
BSD UNIX.)
При достижении этого предела,
последующие вызовы для
порождения нового процесса
завершатся с ошибкой
www.books-shop.com
Процессы
Таблица 2.21 (окончание)
Ограничение Тип ресурса Эффект
Максимальный размер в бай%
тах резидентной части про%
цесса (RSS — Resident Set
Size). Определяет макси%
мальное количество физиче%
ской памяти, предоставляе%
мой процессу. (Предел опре%
делен в версиях BSD UNIX.)
Если система ощущает недоста%
ток памяти, ядро освободит па%
мять за счет процессов, превы%
сивших свой RSS.
RLIMIT MEMLOCK Максимальный физи%
ческой памяти (физических
страниц) в байтах, который
процесс может заблокировать
с помощью системного вызо%
ва mlock(2). (Предел опреде%
лен в версиях BSD UNIX.)
При превышении предела сис%
темный вызов mlock(2) завер%
шится С Ошибкой EAGAIN.
В заключение приведем пример программы, выводящий на экран установ!
ленные ограничения для процесса:
вывода на экран текущего и максимального пределов
потребления ресурса
void resource, char *rname)
{
struct rlimit
изменяемого
if ==
else
printf (
жесткого
if ==
printf
else
}
STACK, "RLIMIT
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 2. программирования UNIX
/* BSD */
RLIMIT_NPROC
/* BSD */
ttifdef
/* BSD */
ttifdef RLIMIT_MEMLOCK
)
#endif
/* System V */
#endif
}
Запуск программы под управлением операционной системы Solaris 2.5 даст
следующие результаты:
$
infinite infinite
infinite infinite
2147479552 2147479552
infinite infinite
64 1024
8388608 2147479552
infinite infinite
Примеры программ
В качестве заключительной иллюстрации к обсуждавшимся выше вопро!
сам приводятся фрагменты двух приложений, которые в достаточной сте!
пени демонстрируют практическое применение программного интерфейса
UNIX. Заметим, что приведенные примеры не являются законченными
программами — во многих местах участки кода намеренно опущены, а
функциональность сведена к минимуму. Задачей являлось показать прин!
цип взаимодействия программ с операционной системой и идеологию
программирования в UNIX. Рассмотрим два диаметрально противополож!
ных приложения — неинтерактивную программу!демон и интерактивный
командный интерпретатор.
Демон
Демоны играют важную роль в работе операционной системы. Достаточно
будет сказать, что возможность терминального входа пользователей в
www.books-shop.com
Примеры программ
тему, доступ по сети, использование системы печати и электронной поч!
ты, — все это обеспечивается соответствующими демонами — неинтерак!
тивными программами, составляющими собственные сеансы (и группы) и
не принадлежащими ни одному из пользовательских сеансов (групп).
Некоторые демоны работают постоянно, наиболее яркий пример такого
демона — процесс являющийся прародителем всех прикладных
процессов в системе. Другими примерами являются позволяю!
щий запускать программы в определенные моменты времени,
обеспечивающий доступ к сервисам системы из сети, и обес!
печивающий получение и отправку электронной почты.
При описании взаимодействия процессов с терминалом и пользователем в
разделе "Группы и сеансы", отмечалось особое место демонов, которые не
имеют управляющего терминала. Теперь в отношении демонов можно
сформулировать ряд правил, определяющих их нормальное функциониро!
вание, которые необходимо учитывать при разработке таких программ:
1. Демон не должен реагировать на сигналы управления заданиями, по!
сылаемые ему при попытке операций ввода/вывода с управляющим
терминалом. Начиная с некоторого времени, демон снимает ассоциа!
цию с управляющим терминалом, но на начальном этапе запуска ему
может потребоваться вывести то или иное сообщение на экран.
2. Необходимо закрыть все открытые файлы (файловые дескрипторы),
особенно стандартные потоки ввода/вывода. Многие из этих файлов
представляют собой терминальные устройства, которые должны быть
закрыты, например, при выходе пользователя из системы. Предполага!
ется, что демон остается работать и после того, как пользователь "по!
кинул" UNIX.
3. Необходимо снять его ассоциацию с группой процессов и управляю!
щим терминалом. Это позволит демону избавиться от сигналов, гене!
рируемых терминалом (SIGINT или например, при
определенных клавиш или выходе пользователя из системы.
4. Сообщения о работе демона следует направлять в специальный жур!
нал с помощью функции syslog(3), — это наиболее корректный способ
передачи сообщений от демона.
5. Необходимо изменить текущий каталог на корневой. Если этого не
сделать, а текущий каталог, допустим, находится на примонтирован!
ной файловой системе, последнюю нельзя будет размонтировать. Са!
мым надежным выбором является корневой каталог, всегда принадле!
жащий корневой файловой системе.
Приведем скелет программы!демона:
<stdio.h>
<syslog.h>
ttinclude <signal.h>
www.books-shop.com
Глава 2. Среда программирования UNIX
argc, char **argv)
{
fd;
struct rlimit
/*Если родительский процесс — init, можно не беспокоиться за
терминальные сигналы. Если нет — необходимо игнорировать сигналы,
связанные с вводом/выводом на терминал фонового процесса:
SIGTTOU, SIGTTIN,
if != 1)
{
signal (SIGTSTP, SIG_IGN)
/*Теперь необходимо организовать собственную группу и сеанс, не
имеющие управляющего Однако лидером группы и сеанса
может стать процесс, если он еще не является лидером. Поскольку
предыстория запуска данной программы неизвестна, необходима га
рантия, что наш процесс не является лидером. Для этого порождаем
дочерний Т. к. его PID уникален, то ни группы, ни
с таким идентификатором не существует, а значит нет и При
этом родительский процесс немедленно завершает выполнение, по
скольку он уже не нужен.
Существует еще одна причина необходимости порождения дочернего
процесса. Если демон был запущен из командной строки командного
интерпретатора shell не в фоновом режиме, последний будет ожидать
выполнения демона, и таким образом, терминал будет за
блокирован. Порождая процесс и завершая выполнение родителя, ими
тируем для командного интерпретатора завершение работы демона,
после чего shell выведет свое
if !=0)
/*Родитель заканчивает
/*Дочерний процесс с помощью системного вызова
становится лидером новой группы, сеанса и не имеет
ассоциированного
}
/*Теперь необходимо закрыть открытые файлы. Закроем все возможные
файловые дескрипторы. Максимальное число открытых файлов получим
с помощью функции
for (fd = 0; fd < fd++)
текущий каталог на
Использование вызова справедливо для UNIX System V. Для BSD UNIX процесс
должен создать группу, лидером которой он становится, а затем открыть
управляющий терминал и с помощью команды TIOCNOTTY отключиться от него.
www.books-shop.com
Примеры программ
о себе в системном Для этого сначала установим
опции ведения каждая запись будет предваряться идентифи
катором PID демона, при невозможности записи в журнал
будут выводиться на источник сообщений определим как
"системный демон" (см. комментарии к функциям ведения журнала
. * /
демона", |
"Демон начал плодотворную
следует текст программы, реализующий полезные функции
Эта часть предоставляется читателю для собственной
}
В программе использовалось еще не обсуждавшаяся возможность систем!
ного журнала сообщений выполняющихся программ. Функцией генерации
сообщений является syslog(3), отправляющая сообщение демону
ного журнала syslogd(lM), который в свою очередь либо дописывает сооб!
щения в системный журнал, либо выводит на их консоль, либо перена!
правляет в соответствии со списком пользователей данной или удаленной
системы. Конкретный пункт назначения определяется конфигурационным
файлом Функция имеет определение:
<syslog.h>
void (int priority, char *logstring, /*
Каждому сообщению logstring назначается приоритет, указанный пара!
метром priority. Возможные значения этого параметра включают:
LOG_EMERG Идентифицирует состояние "паники" в системе. Обычно рассы%
лается всем пользователям.
Идентифицирует ненормальное состояние, которое должно
быть исправлено немедленно, например, нарушение целостно%
сти системной базы данных.
Идентифицирует критическое событие, например, ошибку дис%
кового устройства.
LOG_ERR Идентифицирует различные ошибки.
Идентифицирует предупреждения.
LOG_NOTICE Идентифицирует события, которые не являются ошибками, но
требуют внимания.
Идентифицирует информационные сообщения, как, например,
использованное в приведенной программе.
Идентифицирует сообщение, обычно используемое только при
отладке программы.
www.books-shop.com
Глава 2. программирования UNIX
Последний тип сообщений подсказывает еще одну возможность использо!
вания системного журнала — для отладки программ, особенно неинтерак!
тивных.
Строка logstring может включать элементы форматирования, такие же,
как и в функции с одним дополнительным выражением кото!
рое заменяется сообщением, соответствующим ошибке errno. При этом
может осуществляться вывод значений дополнительных параметров.
Функция позволяет определить ряд опций ведения журнала. Она
имеет следующее определение:
void int logopt,
Строка ident будет предшествовать каждому сообщению программы. Ар!
гумент logopt задает дополнительные опции, в том числе:
LOG_PID Позволяет указывать идентификатор процесса в каждом сообще%
нии. Эта опция полезна при нескольких демонов с
одним и тем же значением ident, например, когда демоны порожда%
ются вызовом fork(2).
LOG_CONS Позволяет выводить сообщения на консоль при невозможности за%
писи в журнал.
Наконец, аргумент facility позволяет определить источник сообщений:
LOG_KERN Указывает, что сообщения отправляются ядром.
Указывает, что сообщения отправлены прикладным процессом
(используется по умолчанию).
Указывает, что инициатором сообщений является система элек%
тронной почты.
Указывает, что инициатором сообщений является системный демон.
Указывает, что инициатором сообщений является система телекон%
ференций USENET.
LOG_CRON Указывает, что инициатором сообщений является система
Закончив работу с журналом, следует аккуратно закрыть его с помощью
функции
void closelog
Командный интерпретатор
Для примера интерактивного приложения, мы выбрали простейший ко!
мандный интерпретатор. Данный пример позволяет продемонстрировать
использование системных вызовов для порождения процесса, запуска
программы и синхронизации выполнения процессов.
Функции приведенного командного интерпретатора сведены к минимуму:
он распознает и выполняет несколько встроенных команд, остальной ввод
www.books-shop.com
Примеры программ
он расценивает как внешние программы, которые и пытается запустить с
помощью системного вызова ехес(2).
ttinclude <sys/wait.h>
extern char ** environ;
#define 80
команды
#define CD
ttdefine ECHO 2
EXEC 3
define PROGRAM 1000
/*Функция, которая производит анализ строки, введенной
пользователем, выполняет подстановки и определяет, встроенная ли
это команда или В качестве аргумента функция принимает
строку введенную пользователем, и возвращает имя
команды/программы path и переданные ей параметры arguments.
Возвращаемое значение указывает на внутреннюю команду или внешнюю
программу, которую необходимо
int char char
main
{
int command;
int
char
char
while (1)
{
/*Выведем сообщение
write (1, 2)
/*Считаем ввод пользователя и проанализируем
cmdsize = read(0,
=
command =
{
/*Если это внутренняя команда, обработаем
(CD) : break;
(1, args[0],
break;
args,
write (2, "shell: cannot execute",
21)
break;
www.books-shop.com
Глава 2, Среда программирования UNIX
/*Если это внешняя программа, создадим дочерний процесс, который
и запустит
=
if (pid < 0}
w r i t e ( 2 , "shell: cannot f o r k " ,
else if (pid == 0)
{
args,
write
"shell: cannot execute",
}
else
/*0жидаем завершения выполнения
break;
}
}
}
Предложенный командный интерпретатор работает в бесконечном цикле,
запрашивая ввод пользователя и анализируя строку с помощью функции
текст которой здесь не приведен. В случае, если поль!
зователь ввел встроенную команду интерпретатора, он выполняет команду
собственными силами. В противном случае shell порождает дочерний про!
цесс, который с помощью вызова execve(2) запускает указанную програм!
му. В это время родительский процесс выполняет системный вызов
и приостанавливает свое выполнение до завершения работы программы,
после чего на экран вновь выводится приглашение.
Заключение
Изначально система UNIX создавалась как среда разработки программ. Хотя
сегодня UNIX применяется во многих областях, не связанных с разработкой
программного обеспечения, эта операционная система по!прежнему пользу!
ется большой популярностью среди программистов. В этой главе рассмотре!
ны уже известные подсистемы операционной системы с точки зрения их
программного интерфейса. В первую очередь — это интерфейс системных
вызовов, определяющий базовые услуги, предоставляемые ядром системы
прикладным процессам. При обсуждении вопросов, связанных с програм!
мированием в UNIX были проиллюстрированы отдельные положения фраг!
ментами программ, написанными на языке С — стандартном языке UNIX,
на котором написаны ядро и основные утилиты системы.
www.books-shop.com
управления процессами
Сердцем операционной системы UNIX является подсистема управления
процессами. Практически все действия ядра имеют отношение к процес!
сам, будь то обслуживание системного вызова, генерация сигнала, разме!
щение памяти, обработка особых ситуаций, вызванных выполнением про!
цесса или обеспечением услуг ввода/вывода по запросу прикладного про!
цесса.
Вся функциональность операционной системы в конечном счете опреде!
ляется выполнением тех или иных процессов. Даже так называемые уровни
выполнения системы (run levels) представляют собой ни что иное, как удоб!
ную форму определения группы выполняющихся процессов. Возможность
терминального или сетевого доступа к системе, различные сервисы, тра!
диционные для UNIX, — система печати, удаленные архивы FTP, элек!
тронная почта и система телеконференций (news) — все это результат вы!
полнения определенных процессов.
В этой главе рассматриваются вопросы: что такое процесс в представлении
операционной системы, каковы связанные с ним структуры данных, по!
зволяющие UNIX осуществлять управление процессом, а также описыва!
ется жизненный цикл процесса — от его создания до прекращения выпол!
нения.
Процессы в UNIX неотъемлемо связаны с двумя важнейшими ресурсами
системы — процессором (или процессорами) и оперативной памятью. Как
правило, этих ресурсов никогда не бывает "много", и в операционной сис!
теме происходит активная конкурентная борьба за Цраво обладания про!
цессором и памятью. Мы рассмотрим принципы организации и управле!
ния памятью, т. к. даже при самом умеренном объеме физической памяти
адресное пространство процесса составляет несколько гигабайт! Мы также
подробно остановимся на том, как операционная система планирует вы!
полнение процессов — ведь в каждый момент времени в однопроцессор!
ной системе UNIX может не более одного процесса. UNIX
является многозадачной системой общего назначения, поэтому задача
справедливого распределения этого ресурса между задачами различного
класса и с различными требованиями является нетривиальной.
www.books-shop.com
Глава 3. управления процессами
Мы познакомимся с тем, как создаются новые процессы и запускаются
новые программы (из предыдущих глав вы помните, что это не одно и то
же). По существу процесс является "рамкой", в которую необходимо вста!
вить "картину" или "фотографию" — некоторую прикладную программу. В
этой главе рассматриваются важные этапы жизни процесса, такие как сон
и пробуждение, переключение контекста, связанного со сменой задачи, и
завершение его выполнения.
Последние разделы главы посвящены взаимодействию между процессами.
Хотя основной задачей операционной системы является изоляция отдель!
ного процесса от остальных, время от времени процессам все же требуется
обмениваться данными. Для этого UNIX предлагает широкий спектр
средств — от элементарного механизма сигналов до сложных подсистем
межпроцессного взаимодействия — UNIX System V и сокетов BSD.
Основы управления процессом
Уже говорилось, что процесс UNIX представляет собой исполняемый об!
раз программы, включающий отображение в памяти исполняемого файла,
полученного в результате компиляции, стек, код и данные библиотек, а
также ряд структур данных ядра, необходимых для управления процессом.
На рис. 3.1 схематически представлены компоненты, необходимые для
создания и выполнения процесса.
Процесс во время выполнения использует различные системные ресурсы —
память, процессор, услуги файловой подсистемы и подсистемы вво!
да/вывода. Операционная система UNIX обеспечивает иллюзию одновре!
менного выполнения нескольких процессов, эффективно распределяя сис!
темные ресурсы между активными процессами и не позволяя в то же время
ни одному из них монополизировать использование этих ресурсов.
Новорожденная операционная система UNIX обеспечивала выполнение
всего двух процессов, по одному на каждый подключенный к PDP!7 тер!
минал. Спустя год, на той же PDP!7 число процессов заметно увеличи!
лось, появился системный вызов fork(2). В Первой редакции UNIX поя!
вился вызов ехес(2), но операционная система по!прежнему позволяла
размещать в памяти только один процесс в каждый момент времени. По!
сле реализации аппаратной подсистемы управления памятью на
операционная система была модифицирована, что позволило загружать в
память сразу несколько процессов, уменьшая тем самым время на сохра!
нение образа процесса во вторичной памяти (на диске) и считывание его,
когда процесс продолжал выполнение. Однако до 1972 года UNIX нельзя
было назвать действительно многозадачной системой, т. к. операции вво!
да/вывода оставались синхронными, и другие процессы не могли выпол!
няться, пока их "коллега" не завершал операцию ввода/вывода
www.books-shop.com
Основы управления процессом
достаточно продолжительную). Истинная многозадачность появилась
только после того, как код UNIX был переписан на языке С в 1973 году. С
тех пор основы управления процессами практически не изменились.
Рис. 3.1. Инфраструктура процесса операционной системы UNIX
Выполнение процесса может происходить в двух режимах — в режиме ядра
(kernel mode) или в режиме задачи (user mode). В режиме задачи процесс
выполняет инструкции прикладной программы, допустимые на неприви!
легированном уровне защиты процессора. При этом процессу недоступны
системные структуры данных. Когда процессу требуется получение каких!
либо услуг ядра, он делает системный вызов, который выполняет инструк!
ции ядра, находящиеся на привилегированном уровне. Несмотря на то что
выполняются инструкции ядра, это происходит от имени процесса, сде!
лавшего системный вызов. Выполнение процесса при этом переходит в
режим ядра. Таким образом ядро системы защищает собственное адресное
пространство от доступа прикладного процесса, который может нарушить
целостность структур данных ядра и привести к разрушению операцион!
ной системы. Более того, часть процессорных инструкций, например, из!
менение регистров, связанных с управлением могут быть выпол!
нены только в режиме ядра.
Соответственно и образ процесса состоит из двух частей: данных режима
ядра и режима задачи. Образ процесса в режиме задачи состоит из сегмен!
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 3. Подсистема управления процессами
та кода, данных, стека, библиотек и других структур данных, к которым он
может получить непосредственный доступ. Образ процесса в режиме ядра
состоит из структур данных, недоступных процессу в режиме задачи, кото!
рые используются ядром для управления процессом. Сюда относятся дан!
ные, диктуемые аппаратным уровнем, например состояния регистров, таб!
лицы для отображения памяти и т. д., а также структуры данных, необхо!
димые ядру для обслуживания процесса. Вообще говоря, в режиме ядра
процесс имеет доступ к любой области памяти.
Структуры данных процесса
Каждый процесс представлен в системе двумя основными структурами
данных — и user, описанными, соответственно, в файлах
<sys/proc.h> и Содержимое и формат этих структур различ!
ны для разных версий UNIX. В табл. 3.1 приведены некоторые поля
структуры в SCO UNIX, позволяющие проиллюстрировать информа!
цию, необходимую ядру, для управления процессом.
Таблица Структура
char Состояние процесса (выполнение, приостановлен,
сон и т. д.)
char Текущий приоритет процесса
unsigned int Флаги, определяющие дополнительную инфор%
мацию о состоянии процесса
unsigned short UID процесса
unsigned short p suid процесса
int Идентификатор сеанса
short p_pgrp Идентификатор группы процессов (равен иден%
тификатору лидера группы)
short Идентификатор процесса (PID)
short
sigset t
unsigned int
time t
p size
p
Идентификатор родительского процесса
Сигналы, ожидающие доставки
Размер адресного пространства процесса в страницах
Время выполнения в режиме задачи
t Время выполнения в режиме ядра
caddr t p Указатель на LDT процесса
struct pregion *p_region Список областей памяти процесса
short Код возврата, передаваемый родительскому процессу
unsigned int [ ] Массив записей таблицы страниц для u%area
www.books-shop.com
Основы управления процессом
В любой момент времени данные структур для всех процессов долж!
ны присутствовать в памяти, хотя остальные структуры данных, включая
образ процесса, могут быть перемещены во вторичную память, — область
свопинга. Это позволяет ядру иметь под рукой минимальную информа!
цию, необходимую для определения местонахождения остальных данных,
относящихся к процессу, даже если они отсутствуют в памяти.
Структура является записью системной таблицы процессов, которая,
как мы только что заметили, всегда находится в оперативной памяти. За!
пись этой таблицы для выполняющегося в настоящий момент
процесса адресуется системной переменной curproc. Каждый раз при пе!
реключении контекста, когда ресурсы процессора передаются другому
процессу, соответственно изменяется значение переменной curproc, ко!
торая теперь указывает на структуру активного процесса.
Вторая упомянутая структура — user, также называемая или block,
содержит дополнительные данные о процессе, которые требуются ядру
только во время выполнения процесса (т. е. когда процессор выполняет
инструкции процесса в режиме ядра или задачи). В отличие от структуры
адресованной указателем curproc, данные user размещаются
(точнее, отображаются) в определенном месте виртуальной памяти ядра и
адресуются переменной и. На рис. 3.2 показаны две основные структуры
данных процесса и способы их адресации ядром UNIX.
В u!area хранятся данные, которые используются многими подсистемами
ядра и не только для управления процессом. В частности, там содержится
информация об открытых файловых дескрипторах, диспозиция сигналов,
статистика выполнения процесса, а также сохраненные значения регист!
ров, когда выполнение процесса приостановлено. Очевидно, что процесс
не должен иметь возможности модифицировать эти данные произвольным
образом, поэтому u!area защищена от доступа в режиме задачи.
Как видно из рис. 3.2, u!area также содержит стек фиксированного разме!
ра, — системный стек или стек ядра (kernel stack). При выполнении про!
цесса в режиме ядра операционная система использует этот стек, а не
обычный стек процесса.
Состояния процесса
Жизненный цикл процесса может быть разбит на несколько состояний.
Переход процесса из одного состояния в другое происходит в зависимости
от наступления тех или иных событий в системе. На рис. 3.3 показаны со!
стояния, в которых процесс может находиться с момента создания до за!
вершения выполнения.
www.books-shop.com
Глава 3. процессами
Рис. 3.2. Основные структуры данных процесса
1. Процесс выполняется в режиме задачи. При этом процессором выпол!
няются прикладные инструкции данного процесса.
2. Процесс выполняется в режиме ядра. При этом процессором выпол!
няются системные инструкции ядра операционной системы от имени
процесса.
www.books-shop.com
Основы управления процессом
3. Процесс не выполняется, но готов к запуску, как только планировщик
выберет его (состояние Процесс находится в очереди на вы!
полнение и обладает всеми необходимыми ему ресурсами, кроме вы!
числительных.
Процесс находится в состоянии сна (asleep), ожидая недоступного в
данный момент ресурса, например завершения операции вво!
да/вывода.
Процесс возвращается из режима ядра в режим задачи, но ядро пре!
рывает его и производит переключение контекста для запуска более
высокоприоритетного процесса.
Процесс только что создан вызовом fork(2) и находится в переходном
состоянии: он существует, но не готов к запуску и не находится в со!
стоянии сна.
7. Процесс выполнил системный вызов exit(2) и перешел в состояние
зомби (zombie, defunct). Как такового процесса не существует, но ос!
таются записи, содержащие код возврата и временную статистику его
выполнения, доступную для родительского процесса. Это состояние
является конечным в жизненном цикле процесса.
4.
5.
6.
Рис. 3.3. Состояния процесса
Необходимо отметить, что не все процессы проходят через все множество
состояний, приведенных выше.
www.books-shop.com
Глава 3. управления процессами
Процесс начинает свой жизненный путь с состояния 6, когда родитель!
ский процесс выполняет системный fork(2). После того как создание
процесса полностью завершено, процесс завершает "дочернюю часть" вы!
зова и переходит в состояние 3 готовности к запуску, ожидая своей
очереди на выполнение. Когда планировщик выбирает процесс для вы!
полнения, он переходит в состояние 1 и выполняется в режиме задачи.
Выполнение в режиме задачи завершается в результате системного вызова
или прерывания, и процесс переходит режим ядра, в котором выполня!
ется код системного вызова или прерывания. После этого процесс опять
может вернуться в режим задачи. Однако во время выполнения системного
вызова в режиме ядра процессу может понадобиться недоступный в дан!
ный момент ресурс. Для ожидания доступа к такому ресурсу, процесс вы!
зывает функцию ядра sleep () и переходит в состояние сна (4). При этом
процесс добровольно освобождает вычислительные ресурсы, которые пре!
доставляются следующему наиболее приоритетному процессу. Когда ре!
сурс становится доступным, ядро "пробуждает процесс", используя функ!
цию wakeup помещает в очередь на выполнение, и процесс перехо!
дит в состояние "готов к
При предоставлении процессу вычислительных ресурсов происходит пере!
ключение контекста (context switch), в результате которого сохраняется об!
раз, или контекст, текущего процесса, и управление передается новому.
Переключение контекста может произойти, например, если процесс пе!
решел в состояние сна, или если в состоянии готовности к запуску нахо!
дится процесс с более высоким приоритетом, чем текущий. В последнем
случае ядро не может немедленно прервать текущий процесс и произвести
переключение контекста. Дело в том, что переключению контекста при
выполнении в режиме ядра может привести к нарушению целостности са!
мой системы. Поэтому переключение контекста откладывается до момента
перехода процесса из режима ядра в режим задачи, когда все системные
операции завершены, и структуры данных ядра находятся в нормальном
состоянии.
Таким образом, после того как планировщик выбрал процесс на запуск, по!
следний начинает свое выполнение в режиме ядра, где завершает переклю!
чение контекста. Дальнейшее состояние процесса зависит от его предысто!
рии: если процесс был только что создан или был прерван, возвращаясь в
режим задачи, он немедленно переходит в этот режим. Если процесс начи!
нает выполнение после состояния сна, он продолжает выполняться в режи!
ме ядра, завершая системный вызов. Заметим, что такой процесс может
быть прерван после завершения системного вызова в момент перехода из
режима ядра в режим задачи, если в очереди существует более высокопри!
оритетный процесс.
В UNIX определены дополнительные состояния процесса, в пер!
вую очередь связанные с системой управления заданиями и взаимодейст!
www.books-shop.com
Принципы управления
вием процесса с терминалом. Процесс может быть переведен в состояние
"остановлен" с помощью сигналов останова SIGSTOP, SIGTTIN или
SIGTTOU. В отличие от других сигналов, которые обрабатываются только
для выполняющегося процесса, отправление этих сигналов приводит к
немедленному изменению состояния В этом случае, если про!
цесс выполняется или находится в очереди на запуск, его состояние изме!
няется на "остановлен". Если же процесс находился в состоянии сна, его
состояние изменится на "остановлен в состоянии сна". Выход из этих со!
стояний осуществляется сигналом продолжения SIGCONT, при этом из со!
стояния "остановлен" процесс переходит в состояние "готов к запуску", а
для процесса, остановленного в состоянии сна, следующим пунктом на!
значения является продолжение "сна". Описанные возможности полностью
реализованы и в SVR4.
Наконец, процесс выполняет системный вызов exit(2) и заканчивает свое
выполнение. Процесс может быть также завершен вследствие получения
сигнала. В обоих случаях ядро освобождает ресурсы,
процессу, за исключением кода возврата и статистики его выполнения, и
переводит процесс в состояние "зомби". В этом состоянии процесс нахо!
дится до тех пор, пока родительский процесс не выполнит один из сис!
темных вызовов после чего вся информация о процессе будет
уничтожена, а родитель получит код возврата завершившегося процесса.
Принципы управления памятью
Одной из основных функций операционной системы является эффектив!
ное управление памятью. Оперативная память, или основная память, или
память с произвольным доступом (Random Access Memory, RAM) является
достаточно дорогостоящим ресурсом. Время доступа к оперативной памяти
составляет всего несколько циклов процессора, поэтому работа с данными,
находящимся в памяти, обеспечивает максимальную производительность.
К сожалению, данный ресурс, как правило, ограничен. В большей степени
это справедливо для многозадачной операционной системы общего назна!
чения, каковой является UNIX. Поэтому данные, которые не могут быть
размещены в оперативной памяти, располагаются на вторичных устройст!
вах хранения, или во вторичной памяти, роль которой обычно выполняют
дисковые накопители. Время доступа ко вторичной памяти па несколько
порядков превышает время доступа к оперативной памяти и требует
активного содействия операционной системы. Подсистема управления
Существует исключение из этого правила, касающееся процессов, находящихся в состоя!
нии сна для низкоприоритетного события, т. е. события, вероятность наступления кото!
рого относительно мала (например, ввода с клавиатуры, который может и не наступить).
В этом случае процессу сигнала приведет к его пробуждению. Более подроб!
но этот случай рассмотрен в разделе "Сигналы" этой главы.
www.books-shop.com
Глава 3. процессами
памятью UNIX отвечает за справедливое и эффективное распределение
разделяемого ресурса оперативной памяти между процессами и за обмен
данными между оперативной и вторичной памятью. Часть операций про!
изводится аппаратно устройством управления памятью (Memory
Management Unit, MMU) процессора под управлением операционной сис!
темы, чем достигается требуемое быстродействие.
Примитивное управление памятью значительно уменьшает функциональ!
ность операционной системы. Такие системы, как правило, позволяют
загрузить в заранее определенное место в оперативной памяти единствен!
ную задачу и передать ей управление. При этом задача получает в свое
распоряжение все ресурсы компьютера (разделяя их, разумеется, с опера!
ционной системой), а адреса, используемые задачей, являются физически!
ми адресами оперативной памяти. Такой способ запуска и выполнения
одной программы безусловно является наиболее быстрым и включает ми!
нимальные накладные расходы.
Этот подход часто используется в специализированных микропроцессор!
ных системах, однако практически неприменим в операционных системах
общего назначения, какой является UNIX. Можно сформулировать ряд
возможностей, которые должна обеспечивать подсистема управления па!
мятью современной многозадачной операционной системы:
Выполнение задач, размер которых превышает размер оперативной
памяти.
П Выполнение частично загруженных в память задач для минимизации
времени их запуска.
Размещение нескольких задач в памяти одновременно для повыше!
ния эффективности использования процессора.
П Размещение задачи в произвольном месте оперативной памяти.
П Размещение задачи в нескольких различных частях оперативной па!
мяти.
П Совместное использование несколькими задачами одних и тех же
областей памяти. Например, несколько процессов, выполняющих
одну и ту же программу, могут совместно использовать сегмент кода.
Все эти возможности реализованы в современных версиях UNIX с по!
мощью т. н. виртуальной памяти, о которой пойдет речь в следующем
подразделе. Виртуальная память не является "бесплатным приложением",
повышая накладные расходы операционной системы: структуры данных
управления памятью размещаются в оперативной памяти, уменьшая ее
размер; управление виртуальной памятью процесса может требовать ресур!
соемких операций ввода/вывода; для системы со средней загрузкой около
7% процессорного времени приходится на подсистему управления па!
мятью. Поэтому от эффективности реализации и работы этой подсистемы
во многом зависит производительность операционной системы в целом.
www.books-shop.com
Принципы управления
Виртуальная и физическая память
Оперативная память является, пожалуй, одним из наиболее дорогих ком!
понентов компьютерной системы. Ранние системы UNIX имели в своем
распоряжении 64 Кбайт оперативной памяти, и это количество было явно
недостаточным, современные компьютеры обладают гигабайтами опера!
тивной памяти, но и этого уже мало.
Оперативная память может быть представлена в виде последовательности
байтов, каждый из которых имеет свой уникальный адрес, называемый
физическим адресом. Именно эти адреса в конечном счете использует про!
цессор, обмениваясь данными с оперативной памятью. Однако адресное
пространство процесса существенным образом отличается от адресного
пространства физической оперативной памяти. Представим себе, что ад!
ресное пространство процесса непосредственно отображалось бы в опера!
тивную память, другими словами, что адреса, используемые процессом,
являлись бы физическими адресами. При таком подходе на пути создания
многозадачной системы нас ожидал бы ряд непреодолимых препятствий:
Во!первых, трудно себе представить механизм, защищающий адрес!
ное пространство одного процесса, от адресного пространства дру!
гого или, что более важно, от адресного пространства самой опера!
ционной системы. Поскольку каждый процесс работает с физиче!
скими адресами, нет никакой гарантии, что процесс не обратится к
ячейкам памяти, принадлежащим другим процессам или ядру систе!
мы. Последствия такого обращения скорее всего будут весьма пла!
чевными.
Во!вторых, уже на этапе компиляции необходимо было бы преду!
смотреть распределение существующего физического адресного про!
странства. При запуске каждый процесс должен занимать непрерыв!
ную и непересекающуюся область физических адресов.
П В!третьих, подобное распределение памяти между процессами вряд
ли можно назвать оптимальным. Объем физической оперативной
памяти будет существенным образом ограничивать число процессов,
одновременно выполняющихся в системе. Так восемь процессов,
каждый из которых занимает 1 Мбайт памяти, исчерпают 8 Мбайт
оперативной памяти, а операционная система при средней загрузке
насчитывает более 80 процессов!
Все перечисленные проблемы преодолимы с помощью виртуальной памя!
ти. При этом адреса, используемые приложениями и самим ядром, не обя!
заны соответствовать физическим адресам. Виртуальные адреса трансли!
руются или отображаются в физические на аппаратном уровне при актив!
ном участии ядра операционной системы.
Смысл виртуальной памяти заключается в том, что каждый процесс вы!
полняется в собственном виртуальном адресном пространстве. Виртуальное
www.books-shop.com
198 Глава 3. управления процессами
адресное пространство — настоящий рай для процесса. Во!первых, у про!
цесса создается ощущение исключительности — ведь все адресное про!
странство принадлежит только ему. Во!вторых, он больше не ограничен
объемом физической памяти — виртуальная память может значительно
превышать физическую. В результате процессы становятся изолированны!
ми друг от друга и не имеют возможности (даже при желании)
"хозяйничать" в адресном пространстве соседа. Физическая память распре!
деляется максимально эффективно — она не зависит от распределения
виртуальной памяти отдельного процесса.
Очевидно, что для реализации виртуальной памяти необходим управляе!
мый механизм отображения виртуального адреса в физический. В совре!
менных компьютерных системах процесс отображения выполняется на ап!
паратном уровне (с помощью обеспечивая высокую скорость
трансляции. Операционная система осуществляет управление этим про!
цессом.
Современные процессоры, как правило, поддерживают объединение ад!
ресного пространства в области переменного размера — сегменты и облас!
ти фиксированного размера — страницы. При этом для каждого сегмента
или страницы может быть задано собственное отображение виртуальных
адресов в физические.
На рис. 3.4 показана взаимосвязь между виртуальным и физическим ад!
ресным пространством. Виртуальное адресное пространство процесса, как
правило, является последовательным в рамках уже знакомых нам сегмен!
тов — кода, данных, стека и библиотек. Расположение соответствующих
областей физической памяти может иметь характер,
позволяя оптимально распределять память между процессами.
Рис. 3.4. Виртуальная и физическая память
www.books-shop.com
Принципы управления памятью 199
Размер виртуальной памяти может существенно превышать размер физи!
ческой за счет использования вторичной памяти или области свопинга —
как правило, дискового пространства, где могут сохраняться временно не
используемые участки адресного пространства процесса. Например, если
при выполнении процесса происходит обращение к виртуальному адресу,
для которого присутствует соответствующая страница физической памяти,
операция чтения или записи завершится успешно. Если страница в опера!
тивной памяти отсутствует, процессор генерирует аппаратное прерывание,
называемое страничной ошибкой (page fault), в ответ на которое ядро опреде!
ляет положение сохраненного содержимого страницы в области свопинга,
считывает страницу в память, устанавливает параметры отображения вирту!
альных адресов в физические и сообщает процессору о необходимости по!
вторить операцию. Все эти действия невидимы для приложения, которое
работает с виртуальной памятью.
Механизм отображения виртуальных адресов в физические (трансляция
адреса) существенным образом зависит от конкретной аппаратной реали!
зации. Чтобы наше обсуждение не носило слишком абстрактного характе!
ра, в этом разделе рассмотрим механизм отображения виртуальных адресов
в физические в операционной системе SCO UNIX на примере семейства
процессоров Intel. Однако, как и для остальных подсистем UNIX, основ!
ные принципы отличаются мало, и данное изложение поможет читателю
представить механизмы управления памятью и разобраться, при необхо!
димости, в конкретной реализации.
Сегменты
Семейство процессоров Intel позволяет разделить память на несколько
логических частей, называемых сегментами. При этом адресное простран!
ство процесса может быть представлено в виде нескольких логических
сегментов, каждый из которых состоит из непрерывной последовательно!
сти адресов, лежащих в заданном диапазоне. Трансляция адресов, осно!
ванная на сегментации, предусматривает однозначное отображение адре!
сов сегмента в непрерывную последовательность физических адресов. Вир!
туальный адрес при этом состоит из двух частей: селектора сегмента и
смещения относительно начала сегмента. Селектор (точнее, поле селектора
INDEX) указывает на так называемый дескриптор сегмента, содержащий
такие параметры, как его расположение в памяти, размер и права доступа.
Процессор поддерживает косвенную адресацию сегментов через дескрип!
торы сегментов, которые располагаются в специальных таблицах — облас!
тях памяти, на которые указывают предназначенные для этого регистры
процессора. Ядро операционной системы отвечает за заполнение этих таб!
лиц и установку значений регистров. Другими словами, ядро задает ото!
бражение, а процессор выполняет отображение на аппаратном уровне.
Благодаря такой косвенной адресации логические сегменты защищены
друг от друга, что обеспечивает целостность адресного пространства про!
цесса и ядра.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
200 Глава 3. управления процессами
Дескрипторы сегментов расположены в двух системных таблицах — ло!
кальной таблице дескрипторов (Local Descriptor Table — LDT) и глобаль!
ной таблице дескрипторов (Global Descriptor Table — GDT). Как следует
из названия, LDT обеспечивает трансляцию виртуальных адресов сег!
ментов процесса, в то время как GDT обслуживает адресное пространст!
во ядра (например, при обработке системного вызова или прерывания).
Для каждого процесса создается собственная LDT, в то время как GDT
разделяется всеми процессами. Информация о таблице, на которую ука!
зывает селектор, находится в самом селекторе, вид которого представлен
на рис. 3.5.
1 5
INDEX TI RPL
Рис. 3.5. Селектор сегмента
Если бит равен 0, то селектор указывает на GDT, в противном случае
используется LDT. Поле RPL задает уровень привилегий сегмента и явля!
ется одним из механизмов обеспечения защиты сегментов. Например, если
процесс, находясь в режиме задачи, попытается обратиться к сегменту,
принадлежащему ядру, процессор сгенерирует особую ситуацию, в ответ
на это ядро отправит процессу сигнал SIGSEGV.
Каждая запись LDT или GDT является дескриптором сегмента. Определе!
но несколько типов дескрипторов, используемых для сегментов кода, дан!
ных и стека, а также ряд дескрипторов, с помощью которых обеспечивает!
ся многозадачность и передача управления от непривилегированной зада!
чи, например, процесса в режиме задачи, к привилегированной задаче,
например, ядру. Дескрипторы, используемые в последнем случае, называ!
ются шлюзами.
Дескрипторы сегментов (кода, данных, стека) имеют несколько полей:
Базовый адрес В этом поле хранится 32%битный адрес начала сегмента. Процес%
сор добавляет к нему смещение и получает 32%битный линейный
адрес.
Предел Это поле определяет размер сегмента. Если результирующий
линейный адрес выходит за пределы сегмента, процессор гене%
рирует особую ситуацию. Границы сегмента позволяют процес%
сору обнаруживать такие распространенные ошибки, как пере%
полнение стека, неверные указатели, неверные адреса вызовов и
переходов. В случае, когда операционная система считает, что
обращение за пределы сегмента не является ошибкой
(например, при переполнении стека), она может расширить сег%
мент путем выделения дополнительной памяти и запросить вы%
полнение команды вновь.
www.books-shop.com
Принципы управления памятью
Привилегии Это поле, имеющее название Descriptor Privilege Level (DPL), оп%
ределяет уровень привилегий сегмента и используется совмест%
но с полем RPL селектора для разрешения или запрещения дос%
тупа к сегменту. Для получения доступа к сегменту задача долж%
на иметь по крайней мере такой же уровень привилегий, как и
сегмент, т. е. RPL DPL.
Признак присутст% Этот бит обеспечивает один из механизмов реализации вирту%
вия альной памяти. Если бит не установлен, при попытке обращения
к сегменту процессор генерирует особую ситуацию отсутствия
сегмента, позволяя ядру подгрузить сегмент из вторичной памя%
ти и вновь повторить инструкцию, не затрагивая при этом выпол%
нение процесса. Однако в большинстве современных версий
UNIX виртуальная память основана на страничном механизме,
при котором сегмент всегда присутствует в памяти, а обмен ме%
жду оперативной и вторичной памятью происходит на уровне
страниц.
Тип Это поле определяет тип сегмента. Процессор проверяет тип
сегмента на соответствие исполняемой команде. Это, в частно%
сти, не позволяет интерпретировать информацию сегмента дан%
ных как инструкции процессора.
Права доступа Это поле определяет права доступа, ограничивающие множество
операций, которые можно производить с сегментом. Например,
сегмент кода обычно отмечается как исполняемый и читаемый.
Сегменты данных могут иметь право доступа только для чтения,
или для чтения и записи.
Комбинация селектора и смещения образует логический адрес. Блок управ!
ления памятью процессора использует селектор для определения соответст!
вующего ему дескриптора. Складывая базовый адрес сегмента, хранящийся в
дескрипторе, со смещением, процессор создает линейный адрес (рис. 3.6).
Рис. 3.6. Трансляция адреса с использованием механизма сегментации
www.books-shop.com
202 Глава 3. управления процессами
Если страничный механизм не используется, полученный линейный адрес
является физическим, используемым для непосредственного доступа к
оперативной памяти. Однако реализация виртуальной памяти, основанная
только на сегментах, не обладает достаточной гибкостью и не используется
в современных версиях Управление памятью в большинстве систем
основано на страничном механизме. Сегменты используются ядром для
размещения кода, данных и стека процесса, причем каждый из них имеет
нулевой базовый адрес и предел — 3 Гбайт, т. е. всю адресуемую вирту!
альную память за вычетом 1 Гбайт, занимаемых ядром системы. Распреде!
ление виртуального адресного пространства между ядром и процессами
рассмотрено в разделе "Адресное пространство процесса".
Страничный механизм
При реализации виртуальной памяти, основанной только на сегментации,
весь сегмент целиком может либо присутствовать в оперативной памяти,
либо отсутствовать (точнее, находиться во вторичной памяти или в испол!
няемом файле процесса). Поскольку размер сегмента может быть доста!
точно велик, одновременное выполнение нескольких больших процессов
вызовет серьезную конкуренцию за ресурсы памяти, что в свою очередь
приведет к интенсивному обмену данными между оперативной и вторич!
ной памятью. К тому же обмен областями переменного размера, каковыми
являются сегменты, достаточно сложен и, хотя фрагментация памяти при
этом будет невелика, приведет к низкой эффективности ее использования,
оставляя большое количество неиспользуемого пространства.
Страничный механизм обеспечивает гораздо большую гибкость. В этом слу!
чае все виртуальное адресное пространство (4 Гбайт для процессоров Intel)
разделено на блоки одинакового размера, называемые страницами. Боль!
шинство процессоров Intel работает со страницами размером 4 Кбайт. Так
же как и в случае сегментации, страница может либо присутствовать в опе!
ративной памяти, либо находиться в области свопинга или исполняемом
файле процесса. Основное преимущество такой схемы заключается в том,
что система управления памятью оперирует областями достаточно малого
размера для обеспечения эффективного распределения ресурсов памяти ме!
жду процессами. Страничный механизм допускает, чтобы часть сегмента
находилась в оперативной памяти, а часть отсутствовала. Это дает ядру воз!
можность разместить в памяти только те страницы, которые в данное время
используются процессом, тем самым значительно освобождая оперативную
память. Еще одним преимуществом является то, что страницы сегмента мо!
гут располагаться в физической памяти в произвольном месте и порядке,
что позволяет эффективно использовать свободное
Данный подход напоминает схему хранения файлов на диске — каждый файл состоит из
различного числа блоков хранения данных, которые могут располагаться в любых свобод!
ных участках дискового накопителя. Это ведет к значительной фрагментации, но сущест!
венно повышает эффективность использования дискового пространства.
www.books-shop.com
Принципы управления памятью 203
При использовании страничного механизма линейный адрес, полученный
в результате сложения базового адреса сегмента и смещения также являет!
ся логическим адресом, который дополнительно обрабатывается блоком
страничной трансляции процессора. В этом случае линейный адрес рас!
сматривается процессором как состоящий из трех частей, показанных на
рис. 3.7.
Рис. 3.7. Трансляция адреса с использованием страничного механизма
Первое поле адреса, с 22 по 31 бит, указывает на элемент каталога таблиц
страниц (Page Directory Entry, PDE). Каталог таблиц страниц имеет длину,
равную одной странице, и содержит до 1024 указателей на таблицы стра!
ниц (page table). Таким образом, первое поле адресует определенную таб!
лицу страниц. Второе поле, занимающее с 12 по 21 бит, указывает на эле!
мент страниц (Page Table Entry, РТЕ). Таблицы страниц также
имеют длину 4 Кбайт, а элементы таблицы адресуют в совокупности 1024
страниц. Другими словами, второе поле адресует определенную страницу.
Наконец, смещение на странице определяется третьим полем, занимаю!
щим младшие 12 бит линейного адреса. Таким образом, с помощью од!
ного каталога таблиц процесс может адресовать = 4 Гбайт
физической памяти.
На рис. 3.7 показано, как блок страничной адресации процессора транс!
лирует линейный адрес в физический. использует поле PDE
адреса (старшие 10 бит) в качестве индекса в каталоге таблиц.
элемент содержит адрес таблицы страниц. Второе поле линейного адреса,
www.books-shop.com
Глава 3. управления процессами
РТЕ, позволяет процессору выбрать нужный элемент таблицы, адресую!
щий физическую страницу. Складывая адрес начала страницы со смеще!
нием, хранящимся в третьем поле, процессор получает 32!битный физиче!
ский
Каждый элемент таблицы страниц содержит несколько полей (табл. 3.2),
описывающих различные характеристики страницы.
Таблица 3.2. Поля РТЕ
Р Признак присутствия в оперативной памяти. Доступ к странице, отсутст%
вующей в памяти (Р=0) вызывает страничную ошибку, особую ситуацию,
о чем процессор информирует ядро, которое обрабатывает ее соответст%
вующим образом.
Права только на чтение страницы или на чтение и запись
U/S Привилегии доступа. Если U/S = 0, только привилегированные задачи
(ядро) имеют доступ к адресам страницы. В противном случае, доступ к
странице имеют все задачи.
Адрес Физический адрес начала страницы (адрес базы).
Адресное пространство процесса
Адресное пространство ядра обычно совпадает с адресным пространством
выполняющегося в данный момент процесса. В этом случае говорят, что
ядро расположено в том же контексте, что и процесс. Каждый раз, когда
процессу передаются вычислительные ресурсы, система восстанавливает
контекст задачи этого процесса, включающий значения регистров общего
назначения, сегментных регистров, а также указатели на таблицы страниц,
отображающие виртуальную память процесса в режиме задачи. При этом
системный контекст остается неизменным для всех процессов. Вид адрес!
ного пространства процесса представлен на рис. 3.8.
Специальный регистр (CR3 для Intel) указывает на расположение каталога
таблиц страниц в памяти. В SCO UNIX используется только один каталог,
независимо от выполняющегося процесса, таким образом значение реги!
стра CR3 не меняется на протяжении жизни системы. Поскольку ядро
(код и данные) является частью выполняющегося процесса, таблицы стра!
ниц, отображающие старший 1 Гбайт виртуальной памяти, принадлежа!
щей ядру системы, не изменяются при переключении между процессами.
Для отображения ядра используются старшие 256 элементов каталога.
Следует отметить, что большинство современных и, в частности, процессоры
семейства Intel, помещают данные о нескольких последних использовавшихся ими стра!
ницах в сверхоперативный кэш. Только когда процессор не находит требуемой страницы
в этом кэше, он обращается к каталогу и таблицам страниц. Как правило,
ных ссылок попадают в кэш, требуя для трансляции адреса обращения к
памяти, где расположены каталог и таблицы.
www.books-shop.com
Принципы управления памятью 205
• Физическая
Каталог таблиц
страниц
Виртуальное
адресное
пространство
ядра
Виртуальное
адресное
пространство
процесса
га
ОхСООООООО
0x00000000
Рис. 3.8. Адресное пространство в режимах ядра и задачи
При переключении между процессами, однако, изменяется адресное про!
странство режима задачи, что вызывает необходимость изменения остав!
шихся 768 элементов каталога. В совокупности они отображают 3 Гбайт
виртуального адресного пространства процесса в режиме задачи. Таким
образом, при смене процесса адресное пространство нового процесса ста!
новится видимым (отображаемым), в то время как адресное пространство
предыдущего процесса является
Формат виртуальной памяти процесса в режиме задачи зависит, в первую
очередь, от типа исполняемого файла, образом которого является процесс.
На рис. 3.9 изображено расположение различных сегментов процесса в
виртуальной памяти для двух уже рассмотренных нами форматов испол!
няемых файлов — COFF и ELF. Заметим, что независимо от формата ис!
полняемого файла виртуальные адреса процесса не могут выходить за пре!
делы 3 Гбайт.
Для защиты виртуальной памяти процесса от модификации другими про!
цессами прикладные задачи не могут менять заданное отображение. По!
При этом физические страницы, принадлежащие предыдущему процессу, могут по!
прежнему оставаться в однако доступ к ним невозможен отсутствия
новленного отображения. Любой допустимый виртуальный адрес будет отображаться либо
в страницы ядра, либо в страницы нового процесса.
www.books-shop.com
206 Глава 3. управления процессами
скольку ядро системы выполняется на привилегированном уровне, оно
может управлять отображением как собственного адресного пространства,
так и адресного пространства процесса.
COFF ELF
Рис. 3.9. Виртуальная память процесса в режиме задачи
Управление памятью процесса
Можно сказать, что каждый процесс в операционной системе UNIX вы!
полняется на собственной виртуальной вычислительной машине, где все
ресурсы принадлежат исключительно данному процессу. Подсистема
управления памятью обеспечивает такую иллюзию в отношении физиче!
ской памяти.
Как уже говорилось, аппаратная поддержка страничного механизма имеет
существенное значение для реализации виртуальной памяти. Однако при
этом также требуется участие операционной системы. Можно перечислить
ряд операций, за выполнение которых отвечает сама операционная система:
Размещение в памяти каталога страниц и таблиц страниц; инициа!
лизация регистра — указателя на каталог таблиц страниц (для Intel
— CR3) (в системах, использующих несколько каталогов страниц,
каждый процесс хранит в значение этого регистра; в этом слу!
чае инициализацию указателя необходимо проводить при каждом
переключении контекста); инициализация каталога страниц.
www.books-shop.com
Управление памятью процесса 207
Установка отображения путем записи соответствующих значений в
таблицы страниц.
П Обработка страничных ошибок.
П Управление сверхоперативным кэшем.
П Обеспечение обмена страницами между оперативной и вторичной
памятью.
В реализации перечисленных функций существенную роль играют струк!
туры данных, обеспечивающие удобное представление адресного про!
странства процесса для операционной системы. Фактический формат этих
структур существенным образом зависит от аппаратной архитектуры и вер!
сии UNIX, поэтому в следующих разделах для иллюстрации тех или иных
положений также использована операционная система SCO UNIX.
Области
В SCO UNIX адресное пространство процесса разделено на несколько
участков, называемых областями (region). Область представляет собой не!
прерывный участок виртуального адресного пространства процесса, кото!
рый рассматривается ядром системы как отдельный объект, разделяемый
или защищенный от постороннего доступа. Область может использоваться
для хранения данных различных типов, включая код, данные, разделяемую
память, сегменты библиотек и отображаемые в память файлы. Каждая ак!
тивная область представлена соответствующей структурой данных ядра и
служит основой для управления памятью процесса.
Каждая область представлена собственным сегментом памяти. В совокуп!
ности со страничным механизмом организации виртуальной памяти такой
подход предоставляет ядру системы большие возможности по эффектив!
ному управлению виртуальной памятью процесса.
Области могут совместно использоваться несколькими процессами, при
этом ядру нет необходимости создавать дополнительные копии, нужно
лишь задать требуемое отображение (виртуальные адреса области у раз!
личных процессов могут не совпадать). В качестве примеров разделяемых
областей можно привести разделяемую память, разделяемые библиотеки
или отображаемые в память файлы. Часто код программы совместно ис!
пользуется несколькими родственными процессами. Информация о каж!
дой активной области хранится ядром в структуре данных region.
Поскольку одна и та же область может использоваться несколькими про!
цессами, для каждого процесса ядро создает связанный список структур
pregion (per process region), которые в свою очередь адресуют области,
используемые процессом. Указатель на список структур pregion для каж!
дого процесса находится в записи таблицы процессов — структуре
Основные поля структур region и pregion приведены на рис. 3.10.
www.books-shop.com
208 Глава 3. Подсистема управления процессами
Страница физической памяти
Рис. 3.10. Управление адресным пространством процесса в SCO UNIX
Помимо указателей p_next, организующих структуры pregion в виде
связанного списка, и p_reg, обеспечивающих адресацию соответствующей
структуры region, в каждой структуре pregion определен набор флагов
определяющий права доступа к области, режим блокирования в
памяти и т. д. Поле p_type указывает на тип области. Оно может содер!
жать одно из следующих значений:
Значение Описание
РТ UNUSED Область не используется
РТ TEXT Область содержит сегмент кода
РТ DATA Область содержит сегмент данных
РТ STACK Область используется в качестве стека процесса
РТ SHMEM Область используется в качестве разделяемой памяти
Виртуальная память процесса
www.books-shop.com
Управление памятью процесса 209
(продолжение)
Значение Описание
Область содержит код библиотек
PT_LIBDAT Область содержит данные библиотек
PT_SHFIL Область используется для хранения файла, отображенного в память
Наконец, поле задает виртуальный адрес области в адресном
пространстве процесса.
Поля структуры region, приведенные на рис. ЗЛО, имеют следующие зна!
чения. Поле определяет размер области в страницах, из которых
r_nvalid страниц присутствуют в оперативной памяти (см. далее раздел
"Страничное замещение"). Несколько процессов могут ссылаться на одну
и ту же область, поле r_refcnt хранит число таких ссылок. Поле
адресует таблицу страниц Поле адресует файла, где
располагаются данные области (например, для области кода, будет
указывать на inode исполняемого файла).
Фактическую информацию о структурах управления адресным пространст!
вом процесса можно получить с помощью команды В следую!
щем примере таким образом определяется содержимое структур pregion
процесса и характеристики соответствующих областей.
t crash
= namelist = /unix, outfile = stdout
> pregion 101
SLOT PREG REGVA TYPE
FLAGS
101 0x700000
text
rdonly
G
0
1
2
3
4
12
22
23
145
187
REGVA
0x701000
0x80001000
0x80031000
data
stack
rdonly
pr
Как можно увидеть из вывода команды с рассматриваемым
процессом связаны пять областей: сегмент кода, данных и а также
сегменты кода и данных подключенной библиотеки. Столбец опре!
деляет запись таблицы областей, где расположена адресуемая каждой
pregion область region. Заметим, что значение в столбце лишь от!
части соответствует полю p_reg структуры pregion, поскольку последнее
является указателем, а не индексом таблицы. Столбец REGVA содержит
значения виртуальных адресов областей.
Для областей, размер которых превышает 4 одной таблицы страниц недостаточно,
и region хранит элементы каталога таблиц страниц в виде связанного списка.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 3. Подсистема управления процессами
С помощью полученной информации мы можем более детально рассмот!
реть любую из областей процесса. Выведем данные о сегментах кода, дан!
ных и стека:
>region 12 22 23
SLOT PGSZ VALID NONE SOFF KEF NSW BACK TYPE FLAGS
12 1 1 1 0 0 11 0 0 15 5 154 stxt done
22 3 1 0 0 0 1 0 0 238 23 154 priv done
23 2 1 1 0 0 1 0 0 135 24 priv stack
Столбец PGSZ определяет размер области в страницах, а столбец VALID —
число страниц этой области, находящихся в оперативной памяти. Как мож!
но заметить, для сегментов данных и стека страниц недостаточно, поэтому
может возникнуть ситуация, когда процессу потребуется обращение к адре!
су, в настоящее время отсутствующему в памяти. Заметим также, что стол!
бец INOX содержит индексы таблиц inode, указывающие на метаданные
файлов, откуда было загружено содержимое соответствующих сегментов.
Мы можем взглянуть на дополнительные сведения об этом файле:
154
INODE TABLE SIZE = 472
SLOT FS RCNT LINK SIZE MODE FLAGS
154 1,42 2 1562 3 1 123 56 8972 755 0 R130 tx
Из этой таблицы мы можем определить файловую систему, в которой рас!
положен файл (MAJ/MIN), а также номер его дискового inode — INUMB.
В данном случае он равен 1562. Выполнив команду мы узнаем
имя исполняемого файла, соответствующего исследуемому процессу:
$ ncheck 1562
1562
Замещение страниц
Ранние версии UNIX работали на компьютерах PDP!11 с 16!разрядной
архитектурой и адресным пространством 64 Кбайт. Некоторые модифика!
ции позволяли использовать отдельные адресные пространства для кода и
данных, накладывая тем не менее существенные ограничения на размер
адресного пространства процесса. Это привело к разработке различных
схем программных оверлеев (overlay), использовавшихся как для прикладных
задач, так и для ядра операционной системы. Суть этих методов заключа!
ется в том, что в неиспользуемые участки адресного пространства процес!
са записываются другие части программы. Например, после запуска сис!
темы необходимость в функциях начальной инициализации отпадает и
часть памяти, содержащая этот код, может быть использована для хране!
ния других данных или инструкций операционной системы. Не говоря о
значительной сложности такого подхода для разработчиков программного
обеспечения, использование этих методов приводило к низкой переноси!
www.books-shop.com
Управление памятью процесса 211
мости программ, поскольку они в значительной степени зависели от кон!
кретной организации памяти. Порой даже расширение оперативной памя!
ти требовало внесения модификаций в программное обеспечение.
Механизмы управления памятью сводились к использованию свопинга.
Процессы загружались в непрерывные области оперативной памяти цели!
ком, выгружался процесс также целиком. Только небольшое число про!
цессов могло быть одновременно размещено в памяти, и при запуске про!
цесса на выполнение, несколько других процессов необходимо было пере!
местить во вторичную память. Схема управления памятью, основанная на
механизме свопинга, показана на рис.
Рис. Управление памятью, основанное на свопинге
Механизм страничного замещения по требованию был реализован в UNIX
в году на новом компьютере имевшем 32!разрядную ар!
www.books-shop.com
212 Глава 3. управления процессами
4 Гбайт адресуемого пространства и аппаратную поддержку
страничного механизма. Первой системой UNIX, в которой управление
памятью основывалось на страничном замещении по требованию, явилась
версия Уже в середине 80!х годов все основные версии UNIX
обеспечивали страничное замещение в качестве основного механизма, ос!
тавляя свопингу вторую роль.
Как уже говорилось в системах с виртуальной памятью, основанной на
страничном механизме, адресное пространство процесса разделено на по!
следовательные участки равной длины, называемыми страницами. Такая
же организация присуща и физической памяти, и в конечном итоге любое
место физической памяти адресуется номером страницы и смещением в
ней. Деление адресного пространства процесса является логическим, при!
чем логическим последовательным страницам виртуальной памяти при
поддержке операционной системы и аппаратуры (MMU процессора) ста!
вятся в соответствие определенные физические страницы оперативной па!
мяти. Эта операция получила название трансляции адреса.
Однако механизм трансляции адреса является первым условием реализа!
ции виртуальной памяти, позволяя отделить виртуальное адресное про!
странство процесса от физического адресного пространства процессора.
Вторым условием является возможность выполнения процесса, чье адрес!
ное пространство не имеет полного отображения на физическую память.
Чтобы удовлетворить второму условию, каждая страница виртуальной па!
мяти имеет флаг присутствия в оперативной памяти. Если адресуемая
страница отсутствует в памяти, аппаратура генерирует страничную ошиб!
ку, которая обрабатывается операционной системой, в конечном итоге
приводя к размещению этой страницы в памяти. Таким образом, для вы!
полнения процесса является необходимым присутствие в памяти лишь не!
скольких страниц процесса, к которым в данный момент происходит об!
ращение (рис. 3.12).
Вообще говоря, конкретный механизм страничного замещения зависит от
того, как реализованы три основных принципа:
1. При каких условиях система загружает страницы в память, т. н. прин!
цип загрузки (fetch policy).
2. В каких участках памяти система размещает страницы, т. н. принцип
размещения (placement policy).
Каким образом система выбирает страницы, которые требуется осво!
бодить из памяти, когда отсутствуют свободные страницы для разме!
щения (или их число меньше некоторого порогового значения), т. н.
принцип замещения (replacement policy).
Обычно все физические страницы одинаково подходят для размещения, и
принцип размещения не оказывает существенного влияния на работу ме!
ханизма в целом. Таким образом эффективность управления памятью пол!
www.books-shop.com
Управление памятью процесса 213
ностью зависит от двух остальных принципов: загрузки и замещения. В
системах с чистым страничным замещением по требованию в память по!
мещаются только требуемые страницы, а замещение производится, когда
полностью отсутствует свободная оперативная память. Соответственно,
производительность таких систем полностью зависит от реализации прин!
ципа замещения. Однако большинство современных версий UNIX не ис!
пользуют чистого страничного замещения по требованию. Вместо этого
принцип загрузки предполагает размещение сразу нескольких
обращение к которым наиболее вероятно в ближайшее время, а замещение
производится до того, как память будет полностью занята.
Процесс 1 Физическая память
Физическая страница
Виртуальная страница
Процесс 3
Рис. 3.12. Управление памятью, основанное на страничном замещении по требованию
Описанный механизм управления памятью допускает ситуацию, когда
суммарный размер всех выполняющихся в данный момент процессов пре!
вышает размер физической памяти, в которой располагается только часть
страниц процессов. Содержимое остальных страниц хранится вне физиче!
ской памяти и должно быть загружено ядром, если процессу требуется
доступ к этой части адресного пространства. Однако виртуальное адресное
пространство процесса не зависит от фактического расположения физиче!
ских страниц, и его размещение производится ядром при создании про!
цесса или запуске новой программы. Виртуальное адресное пространство
может изменяться в результате динамического размещения памяти (хипа)
или увеличения стека процесса.
Таким образом, сам процесс "видит" только собственное виртуальное ад!
ресное пространство. Однако физические страницы, соответствующие
www.books-shop.com
214 Глава 3. процессами
этому адресному пространству могут в действительности располагаться в
различных местах, как это показано на рис. 3.13.
Рис. 3.13. Возможное местонахождение физических страниц процесса
1. Виртуальный адрес может быть ассоциирован со страницей физиче!
ской памяти. Обращение к виртуальным адресам из диапазона, соот!
ветствующего этой странице, приведет к обращению к соответствую!
щим адресам физической памяти. От операционной системы не требу!
ется дополнительных действий при обращении к такой странице.
2. Страница может быть перемещена в область свопинга, если требуется
освободить память для другого процесса. Обращение к виртуальному
адресу, соответствующему этой странице, приведет к страничной
ошибке, что, в свою очередь, потребует от ядра размещения новой
страницы в памяти, записи ее содержимого из области свопинга и со!
ответствующего изменения карты отображения (записи таблицы стра!
ниц) таким образом, чтобы виртуальный адрес указывал на новую
страницу. Если потребуется опять переместить такую страницу в об!
www.books-shop.com
Управление памятью процесса
свопинга, ядро сделает это только в том случае, если с момента
последней загрузки произошла модификация страницы.
3. Адресуемая страница отсутствует в памяти, но ее содержимое находит!
ся в файле на диске. Типичными примерами такой ситуации могут
служить страницы сегмента кода или области файлов, отображенных в
памяти. к виртуальному адресу, соответствующему этой
странице, приведет к страничной ошибке, что, в свою очередь, потре!
бует от ядра новой страницы в памяти, записи ее
жимого из файла и соответствующего изменения карты отображения
(записи таблицы страниц) таким образом, чтобы виртуальный адрес
указывал на новую страницу.
4. Адресуемая страница отсутствует в памяти и она не ассоциирована ни
с областью свопинга, ни с файлом. Типичным примером такой ситуа!
ции является страница сегмента неинициализированных данных. Об!
ращение к такой странице потребует размещения новой страницы, за!
полненной нулями.
Ядро должно иметь достаточную информацию обо всех страницах, отсутст!
вующих в памяти для того, чтобы при необходимости загрузить их в память.
Для страниц, перемещенных во вторичную память, необходимо знать их
расположение в области свопинга. Ядро должно иметь возможность распо!
знать, что страницу необходимо заполнить нулями или загрузить ее содер!
жимое из файла. В последнем случае ядро должно хранить местонахождение
файла в файловой системе. Таким образом, наряду с картами
необходимыми для трансляции адреса, ядро хранит ряд структур данных для
поиска и загрузки отсутствующих в памяти страниц.
Различные версии UNIX используют разные подходы. Например, в SCO
UNIX для описания страниц используются структуры pfdat и связанные
с ними дескрипторы дисковых блоков. В UNIX для этого исполь!
зуются поля записи таблицы страниц.
Страничное замещение имеет ряд важных преимуществ по сравнению со
свопингом:
Размер программы ограничивается лишь размером виртуальной па!
мяти, который для компьютеров с 32!разрядной архитектурой со!
ставляет 4 Гбайт.
СИ Запуск программы происходит очень быстро, т. к. не требуется за!
гружать в память всю программу целиком.
Значительно большее число программ может быть загружено и вы!
полняться одновременно, т. к. для выполнения каждой из них в ка!
ждый момент времени достаточно всего нескольких страниц.
Перемещение отдельных страниц между оперативной и вторичной
памятью требует значительно меньших затрат, чем перемещение
процесса целиком.
www.books-shop.com
216 Глава 3. управления процессами
Планирование выполнения процессов
Как и оперативная память, процессор является разделяемым ресурсом, ко!
торый должен быть справедливо распределен между конкурирующими
процессами. Планировщик процессов как раз и является той подсистемой
ядра, которая обеспечивает предоставление процессорных ресурсов про!
цессам, выполняющимся в операционной системе. UNIX является систе!
мой разделения времени, это означает, что каждому процессу вычисли!
тельные ресурсы выделяются на ограниченный промежуток времени, по!
сле чего они предоставляются другому процессу и т. д. Максимальный
временной интервал, на который процесс может захватить процессор, на!
зывается временным квантом (time quantum или time slice). Таким образом
создается иллюзия, что процессы выполняются одновременно, хотя в дей!
ствительности в каждый момент времени выполняется только один (на
однопроцессорной системе) процесс.
UNIX является многозадачной системой, а это значит, что одновременно
выполняются несколько приложений. Очевидно, что приложения предъ!
являют различные требования к системе с точки зрения их планирования
и общей производительности. Можно выделить три основных класса при!
ложений:
Интерактивные приложения. К этому классу относятся командные
интерпретаторы, текстовые редакторы и другие программы, непо!
средственно взаимодействующие с пользователем. Такие приложения
большую часть времени обычно проводят в ожидании пользователь!
ского ввода, например, нажатия клавиш клавиатуры или действия
мышью. Однако они должны достаточно быстро обрабатывать такие
действия, обеспечивая комфортное для пользователя время реакции.
Допустимая задержка для таких приложений составляет от 100 до 200
миллисекунд.
Фоновые приложения. К этому классу можно отнести приложения, не
требующие вмешательства пользователя. Примерами таких задач
могут служить компиляция программного обеспечения и сложные
вычислительные программы. Для этих приложений важно миними!
зировать суммарное время выполнения в системе, загруженной дру!
гими процессами, порожденными, в частности, интерактивными за!
дачами. Более того, предпочтительной является ситуация, когда ин!
терактивные приложения не оказывают существенного влияния на
среднюю производительность задач данного класса.
О Приложения реального времени. Хотя система UNIX изначально раз!
рабатывалась как операционная система разделения времени, ряд
приложений требуют дополнительных системных возможностей, в
частности, гарантированного времени совершения той или иной
операции, времени отклика и т. п. Примером могут служить измери!
тельные комплексы или системы управления. Видеоприложения
www.books-shop.com
Планирование выполнения процессов 217
также могут обладать определенными ограничениями на время обра!
ботки кадра изображения.
Планирование процессов построено на определенном наборе правил, ис!
ходя из которых планировщик выбирает, когда и какому процессу предос!
тавить вычислительные ресурсы системы. При этом желательным является
удовлетворение нескольких требований, например, минимальное время
отклика для интерактивных приложений, высокая производительность для
фоновых задач и т. п. Большинство из этих требований не могут быть
полностью удовлетворены одновременно, поэтому в задачу планировщика
процессов входит нахождение "золотой середины", обеспечивающей мак!
симальную эффективность и производительность системы в целом.
В этом разделе мы рассмотрим основные принципы и механизмы плани!
рования в традиционных UNIX!системах. Начнем с обработки прерыва!
ний таймера, поскольку именно здесь инициируются планирова!
ния и ряд других действий, например, отложенные вызовы и
(alarm).
Обработка прерываний таймера
Каждый компьютер имеет аппаратный таймер или системные часы, кото!
рые генерируют аппаратное прерывание через фиксированные интервалы
времени. Временной интервал между соседними прерываниями называется
тиком процессора или просто тиком (CPU tick, clock tick). Как правило,
системный таймер поддерживает несколько значений тиков, но в UNIX
это значение обычно устанавливается равным 10 миллисекундам, хотя это
значение может отличаться для различных версий операционной системы.
Большинство систем хранят это значение в константе HZ, которая опреде!
лена в файле заголовков <param.h>. Например, для тика в 10 миллисекунд
значение HZ устанавливается равным 100.
Обработка прерываний таймера зависит от конкретной аппаратной архи!
тектуры и версии операционной системы. Мы остановимся на принципах
обработки прерываний, общих для большинства систем. Обработчик пре!
рываний ядра вызывается аппаратным прерыванием таймера, приоритет
которого обычно самый высокий. Таким образом, обработка прерывания
должна занимать минимальное количество времени. В общем случае, об!
работчик решает следующие задачи:
Обновление статистики использования процессора для текущего
процесса
П Выполнение ряда функций, связанных с планированием процессов,
например пересчет приоритетов и проверку истечения временного
кванта для процесса
Проверка превышения процессорной квоты для данного процесса и
отправка этому процессу сигнала в случае превышения
www.books-shop.com
Глава 3. управления процессами
П Обновление системного времени (времени дня) и других связанных с
ним таймеров
П Обработка отложенных вызовов
П Обработка (alarm)
П Пробуждение в случае необходимости системных процессов, напри!
мер диспетчера страниц и свопера
Часть задач не требует выполнения на каждом тике. Боль!
шинство систем вводят нотацию главного тика (major tick), который про!
исходит каждые тиков, где зависит от конкретной версии системы.
Определенный набор функций выполняется только на главных тиках. На!
пример, производит пересчет приоритетов каждые 4 тика, a SVR4
обрабатывает и производит пробуждение системных процессов раз
в секунду.
Отложенные вызовы
вызов определяет функцию, вызов которой будет произведен
ядром системы через некоторое время. Например, в SVR4 любая подсис!
тема ядра может зарегистрировать отложенный вызов следующим образом:
int co_ID = arg, long
где f n определяет адрес функции, которую необходимо вызвать, при
этом ей будет передан аргумент arg, а сам вызов будет произведен через
delta ТИКОВ.
Ядро производит вызов f n в системном контексте, таким образом
функция отложенного вызова не должна обращаться к адресному про!
странству текущего процесса (поскольку не имеет к нему отношения), а
также не должна переходить в состояние сна.
Отложенные вызовы применяются для выполнения многих функций, на!
пример:
Выполнение ряда функций планировщика и подсистемы управления
памятью
П Выполнение ряда функций драйверов устройств для событий, веро!
ятность ненаступления которых относительно велика. Примером
может служить модуль протокола TCP, реализующий таким образом
повторную передачу сетевых пакетов по тайм!ауту
Опрос устройств, не поддерживающих прерывания
Заметим, что функции отложенных вызовов выполняются в системном
контексте, а не в контексте прерывания. Вызов этих функций выполняется
не обработчиком прерывания таймера, а отдельным обработчиком отло!
женных вызовов, который запускается после обработки прс!
www.books-shop.com
Планирование выполнения процессов
таймера. При обработке прерывания таймера система проверяет
необходимость запуска тех или иных функций отложенного вызова и уста!
навливает соответствующий флаг для них. В свою очередь обработчик от!
ложенных вызовов проверяет флаги и запускает необходимые в
системном контексте.
Эти функции хранятся в системной таблице отложенных вызовов, органи!
зация которой отличается для различных версий UNIX. Поскольку про!
смотр этой таблицы осуществляется каждый тик при обработке высоко!
приоритетного прерывания, для минимизации влияния этой операции на
функционирование системы в целом, организация этой таблицы должна
обеспечивать быстрый поиск нужных функций. Например, в и
SCO UNIX таблица отложенных вызовов организована в виде списка, от!
сортированного по времени запуска. Каждый элемент хранит разницу ме!
жду временем вызова функции и временем вызова функции предыдущего
элемента таблицы. На каждом тике значение этой величины уменьшается
на единицу для первого элемента таблицы. Когда это значение
равным 0, производится вызов соответствующей функции и запись удаля!
ется. На рис. 3.14 приведена схема организации этой таблицы.
Рис. 3.14. Организация таблицы отложенных вызовов
Процесс может запросить ядро отправить сигнал по прошествии опреде!
ленного интервала времени. Существуют три типа алармов — реального
(real!time), профилирования (profiling) и виртуального
(virtual time). С каждым из этих типов связан таймер интервала
timer, или Значение уменьшается на единицу при каждом
тике. Когда значение itimer достигает нуля, процессу отправляется соот!
сигнал.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
220 Глава 3. управления процессами
Указанные таймеры обладают следующими характеристиками:
ITIMER_REAL Этот таймер используется для отсчета реального времени.
Когда значение таймера становится равным нулю, процессу
отправляется сигнал
ITIMER_PROF Этот таймер уменьшается только когда процесс выполняется в
режиме ядра или задачи. Когда значение таймера становится
равным нулю, процессу отправляется сигнал
Этот таймер уменьшается только когда процесс выполняется в
режиме задачи. Когда значение таймера становится равным
нулю, процессу отправляется сигнал
В версиях BSD UNIX для установки таймеров всех трех типов использует!
ся системный вызов settimer(2), для которого значение таймера устанавли!
вается в Ядро системы преобразует это значение в тики,
на основании которых и производится уменьшение таймера. Напомним,
что тик является максимальным временным разрешением, которое может
обеспечить система. В версиях System V для установки таймера реального
времени используется вызов позволяющий указать интервал в
секундах. UNIX SVR4 позволяет установить таймеры высокого разрешения
с помощью системного вызова для которого время указывается в
микросекундах. С помощью этого вызова также достигается совместимость
с BSD, которая обеспечивается библиотечной функцией Ана!
логично, в BSD UNIX вызов реализован в виде библиотечной
функции.
Не следует, однако, заблуждаться насчет высокого разрешения таймеров
реального времени. На самом деле их точность может быть довольно низ!
кой. Допустим, что значение таймера реального времени, установленного
каким!либо процессом, достигло нуля. При этом ядро отправит этому
процессу сигнал SIGALRM. Однако процесс сможет получить и обработать
этот сигнал, только когда он будет выбран планировщиком и поставлен на
выполнение. В зависимости от приоритета процесса и текущей загрузки
системы это может привести к существенным задержкам и, как следствие,
к неточностям определения временного интервала. Таймеры реального
времени высокого разрешения обладают достаточной точностью лишь для
больших интервалов времени или для высокоприоритетных процессов.
Тем не менее и для таких процессов получение сигнала может быть задер!
жано, если в текущий момент процесс выполняется в режиме ядра и не
может быть приостановлен.
Два других типа таймера обладают более высокой точностью, поскольку не
имеют отношения к реальному течению времени. Однако их точность для
малых временных интервалов может определяться следующим фактором.
системы System V, например SCO UNIX, также имеют в своем распоряжении
этот системный вызов.
www.books-shop.com
Планирование выполнения процессов
При обработке таймера процессу засчитывается тик целиком, даже если,
предположим, процесс выполнялся лишь часть тика. Для временных ин!
тервалов порядка тика это может внести значительную погрешность.
Контекст процесса
Каждый процесс UNIX имеет контекст, под которым понимается вся ин!
формация, требуемая для описания процесса. Эта информация сохраняет!
ся, когда выполнение процесса простанавливается, и восстанавливается,
когда планировщик предоставляет процессу вычислительные ресурсы.
Контекст процесса состоит из нескольких частей:
Адресное пространство процесса в режиме задачи. Сюда входят код,
данные и стек процесса, а также другие области, например, разде!
ляемая память или код и данные динамических библиотек.
Управляющая информация. Ядро использует две основные структуры
данных для управления процессом — и user. Сюда же входят
данные, необходимые для отображения виртуального адресного про!
странства процесса в физическое.
Окружение процесса. Переменные окружения процесса представляют
собой строки пар вида:
которые наследуются дочерним процессом от родительского и обыч!
но хранятся в нижней части стека. Окружение процесса упоминалось
в предыдущих главах, там же были показаны функции, позволяющие
получить или изменить переменные окружения.
Аппаратный контекст. Сюда входят значения общих и ряда систем!
ных регистров процессора. К системным регистрам, в частности, от!
носятся:
• указатель инструкций, содержащий адрес следующей инструк!
ции, которую необходимо выполнить;
• указатель стека, содержащий адрес последнего элемента стека;
• регистры плавающей точки;
• регистры управления памятью, отвечающие за трансляцию вир!
туального адреса процесса в физический.
Переключение между процессами, необходимое для справедливого рас!
пределения вычислительного ресурса, по существу выражается в переклю!
чении контекста, когда контекст выполнявшегося процесса запоминается,
и восстанавливается контекст процесса, выбранного планировщиком. Пе!
реключение контекста является достаточно ресурсоемкой операцией. По!
мимо сохранения состояния регистров процесса, ядро вынуждено выпол!
нить множество других действий. Например, для систем ядру
www.books-shop.com
Глава 3. управления процессами
необходимо очистить кэш данных, инструкций или адресных трансляций,
чтобы предотвратить некорректные обращения нового процесса. Поэтому
запущенный процесс сначала вынужден работать по существу без кэша,
что также сказывается на производительности.
Существуют четыре ситуации, при которых производится переключение
контекста:
1. Текущий процесс переходит в состояние сна, ожидая недоступного ре!
сурса.
2. Текущий процесс завершает свое выполнение.
После пересчета приоритетов в очереди на выполнение находится бо!
лее высокоприоритетный процесс.
4. Происходит пробуждение более высокоприоритетного процесса.
Первые два случая соответствуют добровольному переключению контекста
и действия ядра в этом случае достаточно просты. Ядро вызывает процеду!
ру переключения контекста из функций () или Третий и
четвертый случаи переключения контекста происходят не по воле процес!
са, который в это время выполняется в режиме ядра и поэтому не может
быть немедленно приостановлен. В этой ситуации ядро устанавливает спе!
циальный флаг который указывает, что в очереди находится более
высокоприоритетный процесс, требующий предоставления вычислитель!
ных ресурсов. Перед переходом процесса из режима ядра в режим задачи
ядро проверяет этот флаг и, если он установлен, вызывает функцию пере!
ключения контекста.
Принципы планирования процессов
Традиционные алгоритмы планирования UNIX обеспечивают возможность
одновременного выполнения интерактивных и фоновых приложений. Та!
ким образом, они хорошо подходят для систем общего назначения с не!
сколькими подключенными пользователями, работающими с текстовыми
и графическими редакторами, компилирующими программы и выпол!
вычислительные задачи. Эти алгоритмы обеспечивают
время реакции для интерактивных приложений, следя в то же время, что!
бы фоновым громоздким задачам справедливо предоставлялись ресурсы
системы. Современные системы поддерживают выполнение задач реаль!
ного времени, однако в данном разделе мы остановимся на планировании
системы разделения времени.
Планирование процессов в UNIX основано на приоритете процесса. Пла!
нировщик всегда выбирает процесс с наивысшим приоритетом. Приоритет
процесса не является фиксированным и динамически изменяется систе!
мой в зависимости от использования вычислительных ресурсов, времени
ожидания запуска и текущего состояния процесса. Если процесс готов к
www.books-shop.com
Планирование выполнения процессов
запуску и имеет наивысший приоритет, планировщик приостановит
полнение текущего процесса (с более низким приоритетом), даже если
последний не "выработал" свой временной квант.
Традиционно ядро UNIX является "непрерываемым" Это
означает, что процесс, находящийся в режиме ядра (в результате систем!
ного вызова или прерывания) и выполняющий системные инструкции,
может быть прерван системой, а вычислительные ресурсы переданы друго!
му, более высокоприоритетному процессу. В этом состоянии выполняю!
щийся процесс может освободить процессор "по собственному
в результате недоступности какого!либо ресурса перейдя в состояние сна.
В противном случае система может прервать выполнение процесса только
при переходе из режима ядра в режим задачи. Такой подход значительно
упрощает решение задач синхронизации и поддержания целостности
структур данных ядра.
Каждый процесс имеет два атрибута приоритета: на
основании которого происходит планирование, и заказанный
ный приоритет, называемый nice number (или просто nice), который зада!
ется при порождении процесса и влияет на текущий приоритет.
Текущий приоритет варьируется в диапазоне от 0 (низкий приоритет) до
127 (наивысший приоритет). Процессы, в режиме задачи,
имеют более низкий приоритет, чем в режиме ядра. Для режима задачи
приоритет меняется в диапазоне для режима ядра — (систем!
ный диапазон).
Процессы, приоритеты которых лежат в диапазоне являются
процессами с фиксированным приоритетом, не изменяемым операцион!
ной системой, и предназначены для поддержки приложений реального
Процессу, ожидающему недоступного в данный момент ресурса, система
определяет значение выбираемое ядром из диапазона сис!
темных приоритетов и связанное с событием, вызвавшее это состояние.
В табл. 3.3 приведены значения приоритетов сна для систем UNIX
и SCO UNIX 5.0). Заметим, что направление роста значений
приоритета для этих систем различно — в BSD UNIX большему значению
соответствует более низкий приоритет.
Схема нумерации приоритетов различна для различных версий UNIX.
более высокому значению текущего приоритета может соответствовать
тический приоритет планирования. между приоритетами режима ядра и задачи
также зависит от версии. Здесь мы привели в SCO UNIX, кото!
рой большему значению высокий
www.books-shop.com
224 Глава 3. управления процессами
Таблица 3.3. Системные приоритеты сна
Ожидание загрузки в память сегмен%
(свопинг/страничное замещение)
Ожидание индексного дескриптора
Ожидание
Ожидание буфера
Ожидание терминального ввода
Ожидание терминального вывода
Ожидание завершения выполнения
Ожидание события — низкоприоритетное со%
стояние сна
Приоритет
4.3BSD UNIX
0
10
20
30
40
Приоритет
SCO UNIX
95
88
81
80
75
74
73
66
Когда процесс пробуждается, ядро устанавливает значение текущего при!
оритета процесса равным приоритету сна. Поскольку приоритет такого
процесса находится в системном диапазоне и выше, чем приоритет режи!
ма задачи, вероятность предоставления процессу вычислительных ресурсов
весьма велика. Такой подход позволяет, в частности, быстро завершить
системный вызов, выполнение которого, в свою очередь, может блокиро!
вать некоторые системные ресурсы.
После завершения системного вызова перед возвращением в режим задачи
ядро восстанавливает приоритет режима задачи, сохраненный перед вы!
полнением системного вызова. Это может привести к понижению приори!
тета, что, в свою очередь, вызовет переключение контекста.
Текущий приоритет процесса в режиме задачи зависит от двух
факторов: значения nice number и степени использования вычислительных
ресурсов
p_priuser a*p_nice
где — постоянная составляющая, зависящая от параметра
Задача планировщика разделения времени — справедливо распределить
вычислительный ресурс между конкурирующими процессами. Для приня!
тия решения о выборе следующего запускаемого процесса планировщику
необходима информация об использовании процессора. Эта составляющая
Мы специально не выделили явно параметр nice по следующей причине. Традиционно,
большему значению параметра nice соответствует меньший это уже обсужда!
лось в главе 1. В данном обсуждении выбрана схема, при которой большему значению
р_сри соответствует больший приоритет. Поэтому в простейшем случае коэффициент а
является отрицательным, a p_nice равно значению параметра nice (nice number).
www.books-shop.com
Планирование выполнения процессов 225
приоритета уменьшается обработчиком прерываний таймера каждый тик.
Таким образом, пока процесс выполняется в режиме задачи, его текущий
приоритет линейно уменьшается.
Каждую секунду ядро пересчитывает текущие приоритеты процессов, го!
товых к запуску (приоритеты которых меньше 65), последовательно увели!
чивая Это перемещает процессы в более приоритетные очереди и по!
вышает вероятность их последующего запуска.
Например, UNIX версии SVR3, использует следующую формулу:
p_cpu
Эта простая схема проявляет недостаток нивелирования приоритетов при
повышении загрузки системы. Это происходит потому, что в этом случае
каждый процесс получает незначительный объем вычислительных ресур!
сов и следовательно имеет малую составляющую которая еще более
уменьшается благодаря формуле пересчета р_сри. В результате степень
использования процессора перестает оказывать заметное влияние на при!
оритет, и низкоприоритетные процессы (т. е. процессы с высоким nice
number) практически "отлучаются" от вычислительных ресурсов системы.
В 4.3BSD UNIX для пересчета используется другая формула:
=
Здесь параметр load равен среднему числу процессов, находившихся в
очереди на выполнение за последнюю секунду, и характеризует среднюю
загрузку системы за этот период времени. Этот алгоритм позволяет час!
тично избавиться от недостатка планирования SVR3, поскольку при зна!
чительной загрузке системы уменьшение р_сри при пересчете будет про!
исходить медленнее.
Описанные алгоритмы планирования позволяют учесть интересы низко!
приоритетных процессов, т. к. в результате длительного ожидания очереди
на запуск приоритет таких процессов увеличивается, соответственно уве!
личивается и вероятность запуска. Представленные алгоритмы также обес!
печивают более вероятный выбор планировщиком интерактивных процес!
сов по отношению к вычислительным (фоновым). Такие задачи, как ко!
мандный интерпретатор или редактор, большую часть времени проводят в
ожидании ввода, имея, таким образом, высокий приоритет (приоритет
сна). При наступлении ожидаемого события (например, пользователь осу!
ществил ввод данных) им сразу же предоставляются вычислительные ре!
сурсы. Фоновые процессы, потребляющие значительные ресурсы процес!
сора, имеют высокую составляющую и, как следствие, более низкий
приоритет.
Ядро последовательно уменьшает отрицательную компоненту времени использования
процессора.
www.books-shop.com
Глава 3. управления процессами
Как правило, очередь на выполнение не одна. Например, SCO UNIX име!
ет 127 очередей — по одной на каждый приоритет. BSD UNIX использует
32 очереди, каждая из которых обслуживает диапазон приоритетов, на!
пример и т. д. При выборе следующего процесса на выполнение
из одной очереди, т. е. из нескольких процессов с одинаковым текущим
приоритетом, используется механизм кругового чередования (round
Этот механизм запускается ядром через каждый временной квант для наи!
более приоритетной очереди. Однако если в системе появляется готовый к
запуску процесс с более высоким приоритетом, чем текущий, он будет за!
пущен, не дожидаясь прошествия временного кванта. С другой стороны,
если все процессы, готовые к запуску, находятся в низкоприоритетных по
отношению к текущему процессу очередях, последний будет продолжать
выполняться и в течение следующего временного кванта.
Создание процесса
Как уже обсуждалось, в UNIX проведена четкая грань между программой и
процессом. Каждый процесс в конкретный момент времени выполняет ин!
струкции некоторой программы, которая может быть одной и той же для
нескольких Примером может служить командный интерпре!
татор, с которым одновременно работают несколько пользователей, таким
образом инструкции программы shell выполняют несколько различных
процессов. Такие процессы могут совместно использовать один сегмент
кода в памяти, но в остальном они являются изолированными друг от
друга и имеют собственные сегменты данных и стека.
В любой момент процесс может запустить другую программу и начать вы!
полнять ее инструкции; такую операцию он может сделать несколько раз.
В операционной системе UNIX имеются отдельные системные вызовы для
создания (порождения) процесса, и для запуска новой программы. Сис!
темный создает новый процесс, который является точной ко!
пией родителя. После возвращения из системного вызова оба процесса
выполняют инструкции одной и той же программы и имеют одинаковые
сегменты данных и стека.
не менее между родительским и дочерним процессом имеется ряд
различий:
Дочернему процессу присваивается уникальный идентификатор PID,
отличный от родительского.
Round robin означает петицию, подписи под которой располагаются по кругу —
чтобы нельзя было определить, кто подписался первым. Отсюда и схемы выбора
процессов.
здесь идет о в в ядра вы!
полняет инструкции ядра системы.
www.books-shop.com
Создание процесса
Соответственно и идентификатор родительского процесса для
родителя и потомка различны.
О Дочерний процесс получает собственную копию и, в частно!
сти, собственные файловые дескрипторы, хотя он разделяет те же
записи файловой таблицы.
Для дочернего процесса очищаются все ожидающие доставки сигналы.
Временная статистика выполнения процесса в режиме ядра и задачи
для дочернего процесса обнуляется.
Блокировки памяти и записей, установленные родительским процес!
сом, потомком не наследуются.
Более подробно наследуемые характеристики представлены в табл. 3.4.
Таблица 3.4, Наследование установок при создании процесса и запуске программы
Атрибут
Сегмент кода (text)
Сегмент данных (data)
Окружение
Аргументы
Идентификатор пользова%
теля UID
Идентификатор группы GID
Эффективный идентифика%
тор пользователя EUID
Эффективный идентифика%
тор группы EGID
процесса (PID)
ID группы процессов
ID родительского процесса
(PPID)
Приоритет nice number
Права доступа к создавае%
мому файлу
Ограничение на размер
файла
Сигналы, обрабатываемые
по умолчанию
Игнорируемые сигналы
Наследование по% Сохранение при запус%
программы
Да, разделяемый
Да, копируется при
записи (copy%on%write)
Да
Да
Да
Да
Да
Да
Нет
Да
Нет
Да
Да
Да
Да
Да
Нет
Нет
Возможно
Возможно
Да
Да
Да
(Нет, при вызове
Да
(Нет, при вызове
Да
Да
Да
Да
Да
Да
Да
Да
www.books-shop.com
228 Глава 3. управления процессами
Таблица 3.4 (продолжение)
Атрибут Наследование по[ Сохранение при
томком ке программы
Перехватываемые сигналы Да Нет
Файловые дескрипторы Да Да, если для файлового де%
скриптора не установлен
флаг FD_CLOEXEC (например,
с помощью
Файловые указатели Да, разделяемые Да, если для файлового де%
скриптора не установлен
флаг FD_CLOEXEC (например,
с помощью
В общем случае выполняет следующие действия:
П Резервирует место в области свопинга для сегмента данных и стека
процесса.
П Размещает новую запись в таблице процессов и присваивает
процессу уникальный идентификатор PID.
П Инициализирует структуру (поля структуры подробно
рассматривались в разделе "Структуры данных процесса").
П Размещает карты отображения, необходимые для трансляции адреса.
Размещает процесса и копирует ее содержимое с родитель!
ского.
П Создает соответствующие области процесса, часть из которых совпа!
дает с родительскими.
Инициализирует аппаратный контекст процесса, копируя его с ро!
дительского.
Устанавливает в ноль возвращаемое дочернему процессу вызовом
fork(2) значение.
П Устанавливает возвращаемое родительскому процессу вызовом
fork(2) значение равным PID потомка.
П Помечает процесс готовым к запуску и помещает его в очередь на
выполнение.
Системный вызов fork(2) в итоге создает для дочернего процесса отдель!
ную копию адресного пространства родителя. Во многих случаях, вскоре
после этого, дочерний процесс делает системный вызов ехес(2) для запуска
новой программы, при этом существующее адресное пространство унич!
тожается и создается новое. Таким образом создание фактической копии
адресного пространства процесса, т. е. выделение оперативной памяти и
создание соответствующих карт отображения, является неоправданным.
www.books-shop.com
Создание процесса 229
Для решения данной проблемы используются два подхода. Первый из них,
предложенный в UNIX System V, называется "копирование при записи"
или COW). Суть этого подхода заключается в том, что сег!
менты данных и стека родительского процесса помечаются доступными
только для чтения, а дочерний процесс, хотя и получает собственные кар!
ты отображения, разделяет эти сегменты с родительским. Другими слова!
ми, сразу после создания процесса и родитель и потомок адресуют одни и
те же страницы физической памяти. Если какой!либо из двух процессов
попытается модифицировать данные или стек, возникнет страничная
ошибка, поскольку страница открыта только для чтения, а не для записи.
При этом будет запущен обработчик ошибки ядра, который создаст для
процесса копию этой страницы, доступную для записи. Таким образом,
фактическому копированию подлежат только модифицируемые страницы,
а не все адресное пространство процесса. Если дочерний процесс делает
системный вызов ехес(2) или вообще завершает свое выполнение, права
доступа к страницам родителя, имеющим флаг COW, возвращаются к их
прежним значениям (т. е. до создания дочернего процесса), а флаг COW
очищается.
Другой подход используется в BSD UNIX. В этой версии системы был пред!
ложен новый системный вызов — vfork(2). Использование этого вызова име!
ет смысл, когда дочерний процесс сразу же выполняет вызов ехес(2) и за!
пускает новую программу. При вызове vfork(2) родительский процесс пре!
доставляет свое адресное пространство дочернему и переходит в состояние
сна, пока последний не вернет его обратно. Далее дочерний процесс выпол!
няется в адресном пространстве родителя, пока не делает вызов ехес(2) или
exit(2), после чего ядро возвращает адресное пространство родителю и про!
буждает его. С помощью vfork(2) можно добиться максимального быстродей!
ствия, т. к. в этом случае мы полностью избегаем копирования, даже для
карт отображения. Вместо этого адресное пространство родительского про!
цесса предоставляется потомку передачей нескольких аппаратных регистров,
отвечающих за трансляцию адресов. Однако vfork(2) таит в себе потенциаль!
ную опасность, поскольку позволяет одному процессу использовать и даже
модифицировать адресное пространство другого.
Для управления памятью процесса ядру необходимо соответствующим об!
разом задать области. При этом структуры pregion дочернего процесса,
соответствующие разделяемым областям, указывают на те же структуры
region, что и для родителя. Для областей, совместное использование ко!
торых недопустимо, ядро размещает отдельные структуры region для до!
чернего процесса (изначально копируя их содержимое с родительского) и
устанавливает соответствующие указатели. На рис. 3.15 представлена схема
этих операций. Заметим, что совместная работа и дублирование областей
являются отдельным механизмом, не связанным с рассмотренными выше
подходами, для совместного использования адресного пространства, на!
пример COW. Так, после создания отдельной копии облас!
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
230 Глава 3, управления процессами
ти она по!прежнему будет адресовать те же страницы памяти, что и соот!
ветствующая область родителя.
Рис. 3.15. Создание областей нового процесса
Запуск новой программы
Запуск новой программы осуществляется с помощью системного вызова
Напомним, что при этом создается не новый процесс, а новое ад!
ресное пространство процесса, которое загружается содержимым новой
программы. Если процесс был создан вызовом старое адресное
пространство возвращается родителю, в противном случае оно просто
уничтожается. После возврата из вызова ехес(2) процесс продолжает вы!
полнение кода новой программы.
Операционная система UNIX обычно поддерживает несколько форматов
исполняемых файлов. Старейший из них — в разделе "Форматы ис!
полняемых файлов" главы 2 также были рассмотрены форматы COFF и
ELF. В любом случае исполняемый файл содержит заголовок, позволяю!
щий ядру правильно разместить адресное пространство процесса и загру!
в него соответствующие фрагменты исполняемого файла.
www.books-shop.com
Запуск новой программы
Перечислим ряд действий, которые выполняет ехес(2) для запуска новой
программы:
Производит трансляцию имени файла. В результате возвращается
индексный дескриптор, с помощью которого осуществляется доступ
к файлу. При этом проверяются права доступа.
Считывает заголовок файла и проверяет, является ли файл исполняе!
мым. Вызов ехес(2) также распознает скрипты, о которых говорилось
в главе 1. При этом он анализирует первую строку скрипта, которая
обычно имеет вид В этом случае ехес(2) запускает
программу, указанную передавая ей в качестве аргумента
имя скрипта. Если исполняемый файл (т. е. файл с установленным
атрибутом х) не является бинарным и не содержит в первой строке
названия интерпретатора, ехес(2) запускает интерпретатор по умол!
чанию или как предписывает стан!
дарт XPG4), передавая ему содержимое файла в качестве ввода.
Если исполняемый файл имеет атрибуты SUID или SGID, ехес(2)
соответствующим образом изменяет эффективные идентификаторы
и для этого
Сохраняет аргументы вызова ехес(2) и переменные окружения в ад!
ресном пространстве ядра, поскольку адресное пространство процес!
са будет уничтожено.
Резервирует место в области свопинга для сегмента данных и стека.
Освобождает старые области процесса и соответствующие области
свопинга. Если процесс был создан вызовом vfork(2), старое адресное
пространство возвращается родителю.
Размещает и инициализирует карты отображения для новых сегмен!
тов кода, данных и стека. Если сегмент кода является активным, на!
пример, какой!либо процесс уже выполняет эту программу, данная
область используется совместно. В противном случае область запол!
няется содержимым соответствующего раздела исполняемого файла
или инициализируется нулями для неинициализированных данных.
Поскольку управление памятью процесса построено на механизме
страничного по требованию, копирование происходит
постранично и только тогда, когда процесс обращается к страницам,
отсутствующим в памяти.
Копирует сохраненные аргументы и переменные окружения в новый
стек процесса.
Устанавливает обработку всех сигналов на умалчиваемые значения,
поскольку процесс теперь не имеет требуемых обработчиков. Установ!
ки для игнорируемых и заблокированных сигналов не изменяются.
Напомним, что этом случае EUID и EGID не наследуются от родительского процесса, а
присваиваются равными идентификаторам и GID исполняемого файла.
www.books-shop.com
232 Глава 3. управления процессами
Инициализирует аппаратный контекст процесса. В частности, после
этого указатель инструкций адресует точку входа новой программы.
В случае, когда программа использует динамические библиотеки, соответ!
ствующий раздел исполняемого файла (для файла формата ELF данный
раздел имеет тип INTERP) содержит имя редактора связей динамической
библиотеки. В этом случае редактор связей должен быть запущен до нача!
ла выполнения основной программы для связывания с программами тре!
буемых динамических библиотек. Таким образом точка входа в программу
устанавливается на точку входа в редактор связей. После завершения своей
работы редактор связей, в свою очередь, запускает программу самостоя!
тельно, анализируя заголовок исполняемого файла. Стадии запуска новой
программы проиллюстрированы на рис. 3.16.
Рис. 3.16. Запуск новой программы: а) Адресное пространство процесса до вызова
б) Уничтожение старого адресного пространства; в) Новое адресное простран%
ство процесса; г) Новое адресное пространство процесса при использовании динами%
ческих библиотек
www.books-shop.com
Выполнение режиме 233
Выполнение в режиме ядра
Существуют всего три события, при которых выполнение процесса пере!
ходит в режим ядра — аппаратные прерывания, особые ситуации и сис!
темные вызовы. Во всех случаях ядро UNIX получает управление и вызы!
вает соответствующую системную процедуру для обработки события. Пе!
ред вызовом ядро сохраняет состояние прерванного процесса в системном
стеке. После завершения обработки, состояние процесса восстанавливает!
ся и процесс возвращается в исходный режим выполнения. Чаще всего это
режим задачи, но если, например, прерывание возникло, когда процесс
уже находился в режиме ядра, после обработки события он останется в
этом режиме.
Отметим существенную разницу между прерываниями и особыми ситуа!
циями. Аппаратные прерывания генерируются периферийными устройст!
вами при наступлении определенных событий (например, завершение
дисковой операции ввода/вывода или поступление данных на последова!
тельный порт) и имеют асинхронный характер, поскольку невозможно
точно сказать, в какой момент наступит то или иное прерывание. Более
того, эти прерывания, как правило, не связаны с текущим процессом, а
вызваны внешними событиями. Именно поэтому, обработка прерываний
происходит в системном контексте, при этом недопустим доступ к адрес!
ному пространству процесса, например, к его u!area. По этой же причине,
обработка прерываний не должна блокироваться, поскольку это вызовет
блокирование выполнения независимого процесса.
Напротив, особые ситуации вызваны самим процессом, и связаны с вы!
полнением тех или иных инструкций, например, деление на ноль или об!
ращение к несуществующей странице памяти. Таким образом, обработка
особых ситуаций производится в контексте процесса, при этом может ис!
пользоваться его адресное пространство, а сам процесс — при необходи!
мости блокироваться (перемещаться в состояние сна).
Системные вызовы позволяют процессам воспользоваться базовыми услу!
гами ядра. Интерфейс системных вызовов определяет ограниченный набор
точек входа в ядро системы, обращение к которым изменяет режим вы!
полнения процесса и позволяет выполнять привилегированные инструк!
ции ядра. Стандартная библиотека С, позволяющая использовать систем!
ные функции как обычные процедуры, на самом деле содержит заглушки,
обеспечивающие фактическую реализацию вызова соответствующей точки
входа ядра. Эта реализация существенным образом зависит от аппаратной
архитектуры системы. Например, для систем на базе процессоров Intel ис!
пользуются шлюзы (gate). Имеются два типа шлюзов: шлюзы ловушек (trap
gate) и шлюзы вызовов (call gate). Для осуществления вызова через шлюз
ловушки процесс выполняет команду прерывания, а при работе
шлюз вызова — команду межсегментного вызова.
www.books-shop.com
234 Глава 3. процессами
Выполнение системного вызова происходит в режиме ядра, но в контексте
процесса, сделавшего системный вызов. Таким образом, открыт доступ к
адресному пространству процесса и используется стек ядра процесса.
Сон и пробуждение
Процесс обычно переводится в состояние сна при обработке системной
функции. Если для завершения обработки запроса требуется недоступный
ресурс, процесс снимается с процессора и переводится в состояние сна.
Недоступность ресурса может быть связана с запуском операции вво!
да/вывода с диска, ожиданием выделения (освобождения) буфера, ожида!
нием ввода или вывода на терминал или ожиданием завершения дочернего
процесса. К недоступным ресурсам можно также отнести в
памяти страницу, к виртуальному адресу которой обратился процесс. В
любом случае процесс переходит в состояние сна до наступления события,
делающего ресурс доступным. Во время сна процесс не потребляет вычис!
лительные ресурсы системы. При этом выполняется переключение кон!
текста на другой, высокоприоритетный процесс для выполнения. Таким
образом, процесс, ожидающий ввода с клавиатуры, не занимает процес!
сор, циклически опрашивая терминальную линию, а процесс, считываю!
щий данные с диска, не блокирует выполнение других задач.
Состояние сна — это логическое состояние процесса, при этом он не пе!
ремещается физически в памяти. Переход в состояние сна в первую оче!
редь определяется занесением в системную таблицу процессов соответст!
вующего флага состояния и события, пробуждающего процесс.
События возвещают о доступности того или иного ресурса. Как правило
события связаны с работой периферийных устройств, таких как диск, тер!
минал и принтер, поэтому об их наступлении сигнализируют соответст!
вующие аппаратные прерывания. Наступления одного и того же события
может ожидать несколько процессов. Поскольку переход из состояния в
состояние акт скорее логический, то и пробуждаются все эти процессы
одновременно. Однако это не означает, что какой!либо один из них сразу
начнет выполняться. Это лишь приводит к тому, что их состояние меняет!
ся от "сна" к "готов к выполнению", и они помещаются в очередь на за!
пуск. Задачу выбора процесса для запуска затем решает планировщик про!
цессов.
События, в ожидании которых "засыпают" процессы, не являются равно!
ценными.
Во!первых, они различаются по вероятности наступления. Например со!
бытие, связанное с завершением операции ввода с диска или освобожде!
нием буфера, имеет высокую вероятность. Как правило, подобные опера!
ции имеют конечное время выполнения, в противном случае система ока!
www.books-shop.com
Завершение выполнения процесса 235
залась бы заблокированной. С другой стороны, вероятность наступления
события, связанного с вводом с терминала, может быть весьма низкой.
Пользователь может надолго оставить терминал, не завершив сеанса рабо!
ты с системой. В длительном ожидании события нет ничего опасного —
процесс не занимает ресурсы процессора, однако без специальных мер
выключение терминала приведет к блокировке этого устройства. Для того
чтобы избежать ситуации, должна существовать возможность
вывести процесс из состояния сна, несмотря на отсутствие ожидаемого
события. В этом случае используется стандартное решение — отправление
процессу сигнала. В противоположность этому, отправление сигнала про!
цессу, ожидающему операции ввода с диска, может привести к ухудшению
производительности системы. Поэтому все события и связанные с ними
ресурсы разделяются на две категории по вероятности их наступления: на
допускающие прерывание сигналом и на не допускающие таковых.
Во!вторых, процессы, разбуженные событием, должны иметь различную
вероятность запуска. Это, в первую очередь, связано с тем, что несколько
ресурсов могут отображаться на одно событие. Например, процесс А, ожи!
дающий завершения операции ввода с диска, и процесс В, ожидающий
освобождения буфера ввода, будут связаны с одним и тем же событием.
Они оба окажутся "разбуженными" и затем "готовыми к запуску" после за!
вершения этой операции. Если процесс В будет запущен первым, он все
равно не сможет выполняться, так как буфер не освобожден процессом А.
Даже в случае, когда процессы связаны с различными событиями,
необходимо отдавать предпочтение процессу с более ценным ресурсом.
Например, освобождение буфера ввода безусловно предпочтительнее за!
вершения ввода с терминала.
Поскольку планировщик принимает решение о запуске процесса, основы!
ваясь на приоритетах, единственным способом установить "справедливый"
порядок запуска процессов является присвоение определенного приорите!
та каждому событию. Приоритет процесса и его влияние на планирование
достаточно подробно обсуждались в разделе "Контекст процесса".
Завершение выполнения процесса
Процесс завершает свое выполнение с помощью функции exit Эта
функция может быть вызвана системным вызовом а если заверше!
ние процесса вызвано получением сигнала, функцию вызывает
само ядро. Функция exit выполняет следующие действия:
Отключает все сигналы.
Закрывает все открытые файлы.
Сохраняет статистику ресурсов и
код возврата в записи таблицы процессов.
www.books-shop.com
236 Глава 3. управления процессами
Изменяет состояние процесса на "зомби".
Делает процесс родительским для всех потомков данного
процесса.
П Освобождает адресное пространство процесса, u!area, карты отобра!
жения и области свопинга, связанные с процессом.
П Отправляет сигнал родительскому процессу, уведомляя его
о "смерти" потомка.
П Пробуждает родительский процесс, если тот ожидает завершения по!
томка.
П Запускает функцию переключения контекста, в результате чего вы!
сокоприоритетный процесс получает доступ к вычислительным ре!
сурсам.
После завершения выполнения функции exit процесс находится в со!
стоянии "зомби". При этом от процесса остается запись в таблице
процессов, содержащая статистику использования вычислительных ресур!
сов и код возврата. Эта информация может потребоваться родительскому
процессу, поэтому освобождение структуры производит родитель с
помощью системного вызова возвращающего статистику и код воз!
врата потомка. Если родительский процесс заканчивает свое выполнение
раньше потомка, "родительские права" переходят к процессу В
этом случае после смерти потомка делает системный вызов
и освобождает структуру
Другая ситуация возникает, если потомок заканчивает свое выполнение
раньше родителя, а родительский процесс не производит вызова В
этом случае структура потомка не освобождается и процесс продол!
жает находиться в состоянии "зомби" до перезапуска операционной систе!
мы. Хотя такой процесс (которого, вообще говоря, не существует) не по!
требляет ресурсов системы, он занимает место в таблице процессов, тем
самым уменьшая максимальное число активных задач.
Сигналы
В некотором смысле сигналы обеспечивают простейшую форму межпро!
цессного взаимодействия, позволяя уведомлять процесс или группу про!
цессов о наступлении некоторого события. Мы уже рассмотрели в преды!
дущих главах сигналы с точки зрения пользователя и программиста. Те!
перь мы остановимся на обслуживании сигналов операционной системой.
Группы и сеансы
Группы процессов и сеансы уже обсуждались в главе 2. Такое представле!
ние набора процессов используется в UNIX для управления доступом к
www.books-shop.com
Сигналы 237
терминалу и поддержки пользовательских сеансов работы в системе. Пере!
числим еще раз наиболее важные понятия, связанные с группами и сеан!
сами.
Группа процессов. Каждый процесс принадлежит определенной груп!
пе процессов. Каждая группа имеет уникальный идентификатор.
Группа может иметь в своем составе лидера группы — процесс, чей
идентификатор PID равен идентификатору группы. Обычно процесс
наследует группу от родителя, но может покинуть ее и организовать
собственную группу.
Управляющий терминал. Процесс может быть связан с терминалом,
который называется управляющим. Все процессы группы имеют
один и тот же управляющий терминал.
Специальный файл устройства /dev/tty. Этот файл связан с управ!
ляющим терминалом процесса. Драйвер для этого псевдоустройства
по существу перенаправляет запросы на фактический терминальный
драйвер, который может быть различным для различных процессов.
Например, два процесса, принадлежащие различным сеансам, от!
крывая файл /dev/tty, получат доступ к различным терминалам.
Управление сигналами
Сигналы обеспечивают механизм вызова определенной процедуры при
наступлении некоторого события. Каждое событие имеет свой идентифи!
катор и символьную константу. Некоторые из этих событий имеют асин!
хронный характер, например, когда пользователь нажимает клавишу <Del>
или <Ctrl>+<C> для завершения выполнения процесса, другие являются
уведомлением об ошибках и особых ситуациях, например, при попытке
доступа к недопустимому адресу или вызовы недопустимой инструкции.
Различные события, соответствующие тем или иным сигналам, подробно
рассматривались в главе 2.
Говоря о сигналах необходимо различать две фазы этого механизма — ге!
нерация или отправление сигнала и его доставка и обработка. Сигнал от!
правляется, когда происходит определенное событие, о наступлении кото!
рого должен быть уведомлен процесс. Сигнал считается
когда процесс, которому был отправлен сигнал, получает его и выполняет
его обработку. В промежутке между этими двумя моментами сигнал ожи!
дает
Отправление сигнала
Ядро генерирует и отправляет процессу сигнал в ответ на ряд событий,
которые могут быть вызваны самим процессом, другим процессом, преры!
ванием или какими!либо внешними событиями. Можно выделить основ!
ные причины отправки сигнала:
www.books-shop.com
238 Глава 3. управления процессами
Особые ситуации
Терминальные
прерывания
Другие процессы
Управление
заданиями
Квоты
Уведомления
Когда выполнение процесса вызывает особую
ситуацию, например, деление на ноль, процесс
получает соответствующий сигнал.
Нажатие некоторых клавиш терминала, напри!
мер, <Ctrl>+<C> или <Ctrl>+<\>, вызы!
вает отправление сигнала текущему процессу,
связанному с терминалом.
Процесс может отправить сигнал другому про!
цессу или группе процессов с помощью систем!
ного вызова kill(2). В этом случае сигналы яв!
ляются элементарной формой межпроцессного
взаимодействия.
Командные интерпретаторы, поддерживающие
систему управления заданиями, используют
сигналы для манипулирования фоновым и те!
кущими задачами. Когда процесс, выполняю!
щийся в фоновом режиме делает попытку чте!
ния или записи на терминал, ему отправляется
сигнал останова. Когда дочерний процесс за!
вершает свою работу, родитель уведомляется об
этом также с помощью сигнала.
Когда процесс превышает выделенную ему кво!
ту вычислительных ресурсов или ресурсов фай!
ловой системы, ему отправляется соответст!
вующий сигнал.
Процесс может запросить уведомление о насту!
плении тех или иных событий, например, го!
товности устройства и т. д. Такое уведомление
отправляется процессу в виде сигнала.
Если процесс установил таймер, ему будет от!
правлен сигнал, когда значение таймера станет
равным нулю.
Доставка и обработка сигнала
Для каждого сигнала в системе определена обработка по умолчанию, ко!
торую выполняет ядро, если процесс не указал другого действия. В общем
случае существуют пять возможных действий: завершить выполнение про!
цесса (с созданием образа core и без), игнорировать сигнал, остановить
процесс и продолжить процесс (справедливо для остановленного процесса,
для остальных сигнал игнорируется), наиболее употребительным из кото!
рых является первое.
www.books-shop.com
Сигналы 239
Как уже обсуждалось в главе 2, процесс может изменить действие по
умолчанию, либо зарегистрировав собственный обработчик сигнала, либо
указав, что сигнал следует игнорировать. Процесс также может заблокиро!
вать сигнал, отложив на некоторое время его обработку. Это возможно не
для всех сигналов. Например, для сигналов и SIGSTOP единст!
венным действием является действие по умолчанию, эти сигналы нельзя
ни перехватить, ни заблокировать, ни игнорировать. Для ряда сигналов,
преимущественно связанных с аппаратными ошибками и особыми ситуа!
циями, обработка, отличная от умалчиваемой, не рекомендуется, так как
может привести к непредсказуемым (для процесса) результатам.
Следует заметить, что любая обработка сигнала, в том числе обработка по
умолчанию, подразумевает, что процесс выполняется. На системах с высо!
кой загрузкой это может привести к существенным задержкам между от!
правлением и доставкой сигнала, т. к. процесс не получит сигнал, пока не
будет выбран планировщиком, и ему не будут предоставлены вычисли!
тельные ресурсы. Этот вопрос был затронут при разговоре о точности тай!
меров, которые может использовать процесс.
Доставка сигнала происходит после того, как ядро от имени процесса вы!
зывает системную процедуру которая проверяет, существуют ли
ожидающие доставки сигналы, адресованные данному процессу. Функция
issig вызывается ядром в трех случаях:
1. Непосредственно перед возвращением из режима ядра в режим задачи
после обработки системного вызова или прерывания.
2. Непосредственно перед переходом процесса в состояние сна с приори!
тетом, допускающим прерывание сигналом.
3. Сразу же после пробуждения после сна с приоритетом, допускающим
прерывание сигналом.
Если процедура () обнаруживает ожидающие доставки сигналы, яд!
ро вызывает функцию доставки сигнала, которая выполняет действия по
умолчанию или вызывает специальную функцию запускаю!
щую обработчик сигнала, зарегистрированный процессом. Функция
возвращает процесс в режим задачи, передает управление об!
работчику сигнала, а затем восстанавливает контекст процесса для про!
должения прерванного сигналом выполнения.
Рассмотрим типичные ситуации, связанные с отправлением и доставкой
сигналов. Допустим, пользователь, работая за терминалом, нажимает кла!
прерывания (<Del> или <Ctrl>+<C> для большинства систем). На!
жатие любой клавиши вызывает аппаратное прерывание (например, пре!
рывание от последовательного порта), а драйвер терминала при обработке
этого прерывания определяет, что была нажата специальная клавиша, ге!
нерирующая сигнал, и отправляет текущему процессу, связанному с тер!
миналом, сигнал SIGINT. Когда процесс будет выбран планировщиком и
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
240 Глава 3. процессами
запущен на выполнение, при переходе в режим задачи он обнаружит по!
ступление сигнала и обработает его. Если же в момент генерации сигнала
терминальным драйвером процесс, которому был адресован сигнал, уже
выполнялся (т. е. был прерван обработчиком терминального прерывания),
он также обработает сигнал при возврате в режим задачи после обработки
прерывания.
Работа с сигналами, связанными с особыми ситуациями, незначительно
отличается от вышеописанной. Особая ситуация возникает при выполне!
нии процессом определенной инструкции, вызывающей в системе ошибку
(например, деление на ноль, обращение к недопустимой области памяти,
недопустимая инструкция или вызов и т. д.). Если такое происходит, вы!
зывается системный обработчик особой ситуации, и процесс переходит в
режим ядра, почти так же, как и при обработке любого другого прерыва!
ния. Обработчик отправляет процессу соответствующий сигнал, который
доставляется, когда выполнение возвращается в режим задачи.
При обсуждении состояния сна процесса мы выделили две категории со!
бытий, вызывающих состояние сна процесса: допускающие прерывание
сигналом и не допускающие такого прерывания. В последнем случае сиг!
нал будет терпеливо ожидать нормального пробуждения процесса, напри!
мер, после завершения операции дискового ввода/вывода.
В первом случае, доставка сигнала будет проверена ядром непосредственно
перед переходом процесса в состояние сна. Если такой сигнал поступил,
будет вызван обработчик сигнала, а системный вызов, который выполнял!
ся процессом, будет аварийно с ошибкой EINTR. Если генерация
сигнала произошла в течение сна процесса, ядро будет вынуждено разбу!
дить его и снять прерванный системный вызов (ошибка EINTR). После
пробуждения процесса либо вследствие получения сигнала, либо из!за на!
ступления ожидаемого события, ядром будет вызвана функция
которая обнаружит поступление сигнала и вызовет соответствующую
Взаимодействие между процессами
Как уже обсуждалось, в UNIX процессы выполняются в собственном ад!
ресном пространстве и по существу изолированы друг от друга. Тем самым
сведены к минимуму возможности влияния процессов друг на друга, что
является необходимым в многозадачных операционных системах. Однако
В BSD UNIX были введено понятие перезапускаемых системных вызовов. Суть этого меха!
низма заключается в том, что прерванный сигналом системный вызов автоматически по!
вторяется после обработки сигнала, аварийного завершения с ошибкой EINTR. До!
пускается отключение этой возможности для конкретных сигналов.
www.books-shop.com
процессами
от одиночного изолированного процесса мало пользы. Сама концепция
UNIX заключается в модульности, т. е. основана на взаимодействии между
отдельными процессами.
Для реализации взаимодействия требуется:
обеспечить средства взаимодействия между процессами
и одновременно
П исключить нежелательное влияние одного процесса на другой.
Взаимодействие между процессами необходимо для решения следующих
задач:
Передача данных. Один процесс передает данные другому процессу,
при этом их объем может варьироваться от десятков байтов до не!
скольких мегабайтов.
П Совместное использование данных. Вместо копирования информации
от одного процесса к другому, процессы могут совместно использо!
вать одну копию данных, причем изменения, сделанные одним про!
цессом, будут сразу же заметны для другого. Количество взаимодей!
ствующих процессов может быть больше двух. При совместном ис!
пользовании ресурсов процессам может понадобиться некоторый
протокол взаимодействия для сохранения целостности данных и ис!
ключения конфликтов при доступе к ним.
О Извещения. Процесс может известить другой процесс или группу
процессов о наступлении некоторого события. Это может понадо!
биться, например, для синхронизации выполнения нескольких про!
цессов.
Очевидно, что решать данную задачу средствами самих процессов неэффек!
тивно, а в рамках многозадачной системы — опасно и потому невозможно.
Таким образом, сама операционная система должна обеспечить механизмы
межпроцессного взаимодействия Communication,
К средствам межпроцессного взаимодействия, присутствующим во всех
версиях UNIX, можно отнести:
П сигналы
П каналы
FIFO (именованные каналы)
П сообщения (очереди сообщений)
П семафоры
П разделяемую память
Последние три типа IPC обычно обобщенно называют System V
Во многих версиях UNIX есть еще одно средство IPC — впервые
предложенные в BSD UNIX (им посвящен отдельный раздел главы).
www.books-shop.com
242 Глава 3. управления процессами
Сигналы изначально были предложены как средство уведомления об
ошибках, но могут использоваться и для элементарного например, для
синхронизации процессов или для передачи простейших команд от одного
процесса к Однако использование сигналов в качестве средства
ограничено из!за того, что сигналы очень ресурсоемки. Отправка сиг!
нала требует выполнения системного вызова, а его доставка — прерывания
процесса!получателя и интенсивных операций со стеком процесса для вы!
зова функции обработки и продолжения его нормального выполнения.
При этом сигналы слабо информативны и их число весьма ограничено.
Поэтому сразу переходим к следующему механизму — каналам.
Каналы
Вспомните синтаксис организации программных каналов при работе в ко!
мандной строке shell:
cat myfile ]
При этом (стандартный) вывод программы которая выводит содер!
жимое файла myfile, передается на (стандартный) ввод программы
которая, в свою очередь подсчитывает количество строк, слов и символов.
В результате мы получим что!то вроде:
12 45 260
что будет означать количество строк, слов и символов в файле myfile.
Таким образом, два процесса обменялись данными. При этом использо!
вался программный канал, обеспечивающий однонаправленную передачу
данных между двумя задачами.
Для создания канала используется системный вызов
который возвращает два файловых дескриптора — [0] для записи в
канал и [1] для чтения из канала. Теперь, если один процесс за!
писывает данные в другой сможет получить эти данные из
fildes Вопрос только в том, как другой процесс сможет получить сам
файловый дескриптор [ 1 ] ?
Вспомним наследуемые атрибуты при создании процесса. Дочерний про!
цесс наследует и разделяет все назначенные файловые дескрипторы роди!
тельского. То есть доступ к дескрипторам fildes канала может получить
сам процесс, pipe(2), и его дочерние процессы. В этом
Например, для системы (DNS) таким образом используется сиг!
нал по существу являющийся командой обновления базы данных.
www.books-shop.com
процессами 243
чается серьезный недостаток каналов, поскольку они могут быть исполь!
зованы для передачи данных только между родственными процессами.
Каналы не могут использоваться в качестве средства межпроцессного
взаимодействия между независимыми процессами.
Хотя в приведенном примере может показаться, что процессы и
независимы, на самом деле оба этих процесса создаются процессом
shell и являются родственными.
Рис. 3.17. Создание канала между задачами cat(1) и
FIFO
Название каналов FIFO происходит от выражения First In First Out (пер!
вый вошел — первый вышел). FIFO очень похожи на каналы, поскольку
являются однонаправленным средством передачи данных, причем чтение
данных происходит в порядке их записи. Однако в отличие от программ!
ных каналов, FIFO имеют имена, которые позволяют независимым про!
цессам получить к этим объектам доступ. Поэтому иногда FIFO также на!
зывают именованными каналами. FIFO являются средством UNIX System V
и не используются в BSD. Впервые FIFO были представлены в System III,
однако они до сих пор не документированы и поэтому мало используются.
FIFO является отдельным типом файла в файловой системе UNIX
покажет символ р в первой позиции, см. раздел "Файлы и файловая систе!
ма UNIX" главы 1). Для создания FIFO используется системный вызов
int int mode, int
где pathname — имя файла в файловой системе (имя FIFO),
mode — флаги владения, прав доступа и т. д. (см. поле mode файла),
dev — при создании FIFO игнорируется.
www.books-shop.com
244 Глава 3. процессами
FIFO может быть создан и из командной строки shell:
$ name p
После создания FIFO может быть открыт на запись и чтение, причем за!
пись и чтение могут происходить в разных независимых процессах.
Каналы FIFO и обычные каналы работают по следующим правилам:
1. При чтении меньшего числа байтов, чем находится в канале или
FIFO, возвращается требуемое число байтов, остаток сохраняется для
последующих чтений.
2. При чтении большего числа байтов, чем находится в канале или FIFO,
возвращается доступное число байтов. Процесс, читающий из канала,
должен соответствующим образом обработать ситуацию, когда прочи!
тано меньше, чем заказано.
3. Если канал пуст и ни один процесс не открыл его на запись, при чте!
нии из канала будет получено 0 байтов. Если один или более процес!
сов открыли канал для записи, вызов будет заблокирован до
появления данных (если для канала или FIFO не установлен флаг от!
сутствия блокирования O_NDELAY).
4. Запись числа байтов, меньшего емкости канала или FIFO, гарантиро!
ванно атомарно. Это означает, что в случае, когда несколько процес!
сов одновременно записывают в канал, порции данных от этих про!
цессов не перемешиваются.
5. При записи большего числа байтов, чем это позволяет канал или
FIFO, вызов блокируется до освобождения требуемого места.
При этом атомарность операции не гарантируется. Если процесс пы!
тается записать данные в канал, не открытый ни одним процессом на
чтение, процессу генерируется сигнал SIGPIPE, а вызов воз!
вращает 0 с установкой ошибки (если процесс не уста!
новил обработки сигнала SIGPIPE, производится обработка по умол!
чанию — процесс завершается).
В качестве примера приведем простейший пример приложения клиент!
сервер, использующего FIFO для обмена данными. Следуя традиции, кли!
ент посылает серверу сообщение "Здравствуй, а сервер выводит это
сообщение на терминал.
Сервер:
<sys/stat.h>
FIFO
#define 80
( )
{
www.books-shop.com
процессами 245
char /*буфер для чтения данных из
/*Создадим специальный файл FIFO с открытыми для всех правами
доступа на чтение и
if ( S_IFIFO I 0666, 0)<0){
создать }
/*Получим доступ к
if ( ( = open(FIFO, <
открыть }
/*Прочитаем сообщение и выведем его на
while ( (n = read(readfd, buff, > 0)
if buff, n) != n) {
printf }
/*3акроем FIFO, удаление FIFO — дело
close
exit (0)
Клиент:
об имени
FIFO
{
int writefd, n;
/*Получим доступ к
if ( (writefd = open(FIFO, <
открыть }
/*Передадим сообщение серверу
if "Здравствуй, 18) != 18)
}
/*3акроем
/*Удалим
if <
удалить }
exit (0)
Идентификаторы и имена в
Как было показано, отсутствие имен у каналов делает их недоступными
для независимых процессов. Этот недостаток устранен у FIFO, которые
имеют имена. Другие средства межпроцессного взаимодействия, являю!
щиеся более сложными, требуют дополнительных соглашений по именам
www.books-shop.com
246 3. управления процессами
и идентификаторам. Множество возможных имен объектов конкретного
типа межпроцессного взаимодействия называется пространством имен
(name space). Имена являются важным компонентом системы межпро!
взаимодействия для всех объектов, кроме каналов, поскольку по!
зволяют различным процессам получить доступ к общему объекту. Так,
именем FIFO является имя файла именованного канала. Используя услов!
ленное имя созданного FIFO два процесса могут обращаться к этому объ!
екту для обмена данными.
Для таких объектов IPC, как очереди сообщений, семафоры и разделяемая
память, процесс назначения имени является более сложным, чем просто
указание имени файла. Имя для этих объектов называется ключом (key) и
генерируется функцией ftok(3C) из двух компонентов — имени файла и
идентификатора проекта:
ftok (char char
В качестве filename можно использовать имя некоторого файла, извест!
ное взаимодействующим процессам. Например, это может быть имя про!
граммы!сервера. Важно, чтобы этот файл существовал на момент создания
ключа. Также нежелательно использовать имя файла, который создается и
удаляется в процессе работы распределенного приложения, поскольку при
генерации ключа используется номер файла. Вновь созданный файл
может иметь другой inode и впоследствии процесс, желающий иметь дос!
туп к объекту, получит неверный ключ.
Пространство имен позволяет создавать и совместно использовать не!
родственным процессам. Однако для ссылок на уже созданные объекты
используются идентификаторы, точно так же, как файловый дескриптор
используется для работы с файлом, открытым по имени.
Каждое из перечисленных IPC имеет свой уникальный дескриптор
(идентификатор), используемый ОС (ядром) для работы с объектом. Уни!
кальность дескриптора обеспечивается уникальностью дескриптора для
каждого из типов объектов (очереди сообщений, семафоры и разделяемая
память), т. е. какая!либо очередь сообщений может иметь тот же числен!
ный идентификатор, что и разделяемая область памяти (хотя любые две
очереди сообщений должны иметь различные идентификаторы).
Таблица 3.5. Идентификация объектов IPC
Объект IPC
Канал
FIFO
Очередь сообщений
Пространство имен
—
Имя файла
Ключ
Дескриптор
Файловый дескриптор
Файловый дескриптор
Идентификатор
www.books-shop.com
процессами 247
Таблица 3.5
Объект IPC
Семафор
Разделяемая память
Пространство имен
Ключ
Ключ
Дескриптор
Идентификатор
Идентификатор
Работа с объектами IPC System V во многом сходна. Для создания или по!
лучения доступа к объекту используются соответствующие системные вы!
зовы get: для очереди сообщений, для семафора и
для разделяемой памяти. Все эти вызовы возвращают дескриптор
объекта в случае успеха и !1 в случае неудачи. Отметим, что функции get
позволяют процессу получить ссылку на объект, которой по существу яв!
ляется возвращаемый дескриптор, но не позволяют производить конкрет!
ные операции над объектом (помещать или получать сообщения из
ди сообщений, устанавливать семафор или записывать данные в разделяе!
мую память. Все функции get в качестве аргументов используют ключ key
и флажки создания объекта ipcflag. Остальные аргументы зависят от
конкретного типа объекта. Переменная ipcflag определяет права
к объекту PERM, а также указывает, создается ли новый объект или требу!
ется доступ к Последнее определяется комбинацией (или
отсутствием) флажков и
Права доступа к объекту указываются набором флажков доступа, подобно
тому, как это делается для файлов:
Значение PERM (в
восьмеричном виде)
0400
0200
0040
0020
0004
0002
Аналог прав
доступа для
файлов
r %%%%%%%
%w
Разрешено
Чтение для владельца%пользователя
Запись для владельца%пользователя
Чтение для владельца%группы
Запись для владельца%группы
Чтение для всех остальных
Запись для всех остальных
Комбинацией флажков можно добиться различных результатов:
Значение аргу[
мента ipcflag
Результат действия функции
Объект существует Объект не существует
Возвращает дескриптор Ошибка: отсутствие объекта (ENOENT)
Возвращает дескриптор Создает объект с соответствующими
PERM правами доступа
PERM I IPC_CREAT Ошибка: уже суще! Создает объект с соответствующими
! доступа
PERM IPC
www.books-shop.com
248 Глава 3. Подсистема управления процессами
Работа с объектами System V во многом похожа на работу с файлами в
UNIX. Одним из различий является то, что файловые дескрипторы имеют
значимость в контексте процесса, в то время как значимость дескрипторов
объектов IPC распространяется на всю систему. Так файловый дескриптор
3 одного процесса в общем случае никак не связан с дескриптором 3 дру!
гого неродственного процесса (т. е. эти дескрипторы ссылаются на раз!
личные файлы). Иначе обстоит дело с дескрипторами объектов IPC. Все
процессы, использующие, скажем, одну очередь сообщений, получат оди!
наковые дескрипторы этого объекта.
Для каждого из объектов IPC ядро поддерживает соответствующую струк!
туру данных, отличную для каждого типа объекта (очереди сообще!
ний, семафора или разделяемой памяти). Общей у этих данных является
структура описывающая права доступа к объекту, подобно то!
му, как это делается для файлов. Основными полями этой структуры яв!
ляются:
Идентификатор владельца%пользователя объекта
Идентификатор владельца%группы объекта
UID создателя объекта
cgid создателя объекта
Права доступа на чтение и запись для всех классов доступа (9 битов)
Ключ объекта
Права доступа (как и для файлов) определяют возможные операции, кото!
рые может выполнять над объектом конкретный процесс (получение дос!
тупа к существующему объекту, чтение, запись и удаление).
Заметим, что система не удаляет созданные объекты IPC даже тогда, когда
ни один процесс не пользуется ими. Удаление созданных объектов являет!
ся обязанностью процессов, которым для этого предоставляются соответ!
ствующие функции управления semctl(2), С помощью
этих функций процесс может получить и установить ряд полей внутренних
структур, поддерживаемых системой для объектов а также удалить
созданные объекты. Безусловно, как и во многих других случаях использо!
вания объектов IPC процессы предварительно должны "договориться", ка!
кой процесс и когда удалит объект. Чаще всего, таким процессом является
сервер.
Сообщения
Как уже обсуждалось, очереди сообщений являются составной частью
UNIX System V, они обслуживаются операционной системой, размещают!
ся в адресном пространстве ядра и являются разделяемым системным ре!
сурсом. Каждая очередь сообщений имеет свой уникальный идентифика!
тор. Процессы могут записывать и считывать сообщения из различных
очередей. Процесс, пославший сообщение в очередь, может не ожидать
www.books-shop.com
процессами 249
чтения этого сообщения каким!либо другим процессом. Он может закон!
чить свое выполнение, оставив в очереди сообщение, которое будет про!
читано другим процессом позже.
Данная возможность позволяет процессам обмениваться структурирован!
ными данными, имеющими следующие атрибуты:
Тип сообщения (позволяет мультиплексировать сообщения в одной
очереди)
Длина данных сообщения в байтах (может быть нулевой)
Собственно данные (если длина ненулевая, могут быть структуриро!
ванными)
Очередь сообщений хранится в виде внутреннего однонаправленного свя!
занного списка в адресном пространстве ядра. Для каждой очереди ядро
создает заголовок очереди где содержится информация о пра!
вах доступа к очереди ее текущем состоянии (msg_cbytes —
число байтов и — число сообщений в очереди), а также указате!
ли на первое и последнее сообщения, хранящие!
ся в виде связанного списка (рис. 3.18). Каждый элемент этого списка яв!
ляется отдельным сообщением.
С о о б щ е н и я
Рис. 3.18. Структура очереди сообщений
Для создания новой очереди сообщений или для доступа к существующей
используется системный вызов
#include
<sys/ipc.h>
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
250 3. управления процессами
#include
int key_t key, int
Функция возвращает дескриптор объекта!очереди, либо !1 в случае ошибки.
Подобно файловому дескриптору, этот идентификатор используется процес!
сом для работы с очередью сообщений. В частности, процесс может:
Помещать в очередь сообщения с помощью функции
Получать сообщения определенного типа из очереди с помощью
функции
Управлять сообщениями с помощью функции
Перечисленные системные вызовы манипулирования сообщениями имеют
следующий вид:
<sys/ipc.h>
ttinclude <sys/msg.h>
int const void
msgsz, int
int msqid, void *msgp,
msgsz, long int
Здесь является дескриптором объекта, полученного в результате вы!
зова Параметр указывает на буфер, содержащий тип сооб!
щения и его данные, размер которого равен msgsz байт. Буфер имеет сле!
дующие поля:
long тип сообщения
char данные сообщения
Аргумент msgtyp указывает на тип сообщения и используется для их вы!
борочного получения. Если msgtyp равен 0, функция получит
первое сообщение из очереди. Если величина msgtyp выше 0, будет полу!
чено первое сообщение указанного типа. Если msgtyp меньше 0, функция
получит сообщение с минимальным значением типа, меньше или
равного абсолютному значению msgtyp.
Очереди сообщений обладают весьма полезным свойством — в одной оче!
реди можно мультиплексировать сообщения от различных процессов. Для
демультиплексирования используется атрибут msgtype, на основании ко!
торого любой процесс может фильтровать сообщения с помощью функции
как это было показано выше.
Рассмотрим типичную ситуацию взаимодействия процессов, когда сервер!
ный процесс обменивается данными с несколькими клиентами. Свойство
мультиплексирования позволяет использовать для такого обмена одну оче!
редь сообщений. Для этого сообщениям, направляемым от любого из кли!
ентов серверу, будем присваивать значение типа, скажем, равным 1. Если
www.books-shop.com
между процессами 251
в теле сообщения клиент каким!либо образом идентифицирует себя
(например, передает свой PID), то сервер сможет передать сообщение
конкретному клиенту, присваивая тип сообщения равным этому иденти!
фикатору.
Поскольку функция msgrcv(2) позволяет принимать сообщения определен!
ного типа (типов), сервер будет принимать сообщения с типом 1, а клиен!
ты — сообщения с типами, равными идентификаторам их процессов. Схе!
ма такого взаимодействия представлена на рис. 3.19.
Очередь
сообщений
г
Рис. 3.19. сообщений в одной очереди
Атрибут также можно использовать для изменения порядка из!
влечения сообщений из очереди. Стандартный порядок получения сооб!
щений аналогичен принципу FIFO — сообщения получаются в порядке их
записи. Однако используя тип, например, для назначения приоритета со!
общений, этот порядок легко изменить.
Пример приложения "Здравствуй, использующего сообщения:
Файл описания mesg.h
MAXBUFF 80
PERM
структуру нашего Она может отличаться
структуры msgbuf, но должна содержать поле В данном случае
структура сообщения состоит из буфера
struct our msgbuf {
mtype;
www.books-shop.com
252 Глава 3. управления процессами
char
} Message;
Сервер:
ttinclude <sys/ipc.h>
ttinclude
ttinclude
{
нашего сообщения (может отличаться от структуры
Message message;
key_t key;
msgid, length,
if ( (key = <
получить )
/*Тип принимаемых
очередь
if ( (msgid PERM | <
создать }
n =
сообщение поступило, выведем его содержимое на
if (n > 0) {
if n) != n) {
}
}
else { чтения }
/*Удалить очередь поручим
exit
Клиент:
ttinclude
ttinclude <sys/ipc.h>
ttinclude
ttinclude "mesg.h"
main
{
нашего сообщения (может отличаться от структуры
Message message;
key_t
int msgid, length;
/*Тип посылаемого сообщения, может использоваться для
=
www.books-shop.com
процессами 253
if ( (key = <
получить exit(l); }
доступ к очереди сообщений, очередь уже должна быть создана
if ( = <
получить доступ к
}
строку в
if ( (length =
"Здравствуй, <
копирования в }
if (void *) length, 0)
записи сообщения в
}
очередь
if 0) <
удаления }
}
Семафоры
Для синхронизации процессов, а точнее, для синхронизации доступа не!
скольких процессов к разделяемым ресурсам, используются семафоры. Яв!
ляясь одной из форм IPC, семафоры не предназначены для обмена боль!
шими объемами данных, как в случае FIFO или очередей сообщений.
Вместо этого, они выполняют функцию, полностью соответствующую сво!
ему названию — разрешать или запрещать процессу использование того
или иного разделяемого ресурса.
Применение семафоров поясним на простом примере. Допустим, имеется
некий разделяемый ресурс (например, файл). Необходимо блокировать
доступ к ресурсу для других процессов, когда некий процесс производит
операцию над ресурсом (например, записывает в файл). Для этого свяжем
с данным ресурсом некую целочисленную величину — счетчик, доступный
для всех процессов. Примем, что значение 1 счетчика означает доступ!
ность ресурса, 0 — его недоступность. Тогда перед началом работы с ре!
сурсом процесс должен проверить значение счетчика. Если оно равно 0 —
ресурс занят и операция недопустима — процессу остается ждать. Если
значение счетчика равно 1 — можно работать с ресурсом. Для этого, пре!
жде всего, необходимо заблокировать ресурс, т. е. изменить значение счет!
чика на 0. После выполнения операции для освобождения ресурса значе!
ние счетчика необходимо изменить на 1. В приведенном примере счетчик
играет роль семафора.
Для нормальной работы необходимо обеспечить выполнение следующих
условий:
www.books-shop.com
254 Глава 3. управления процессами
1. Значение семафора должно быть доступно различным процессам. По!
этому семафор находится не в адресном пространстве процесса, а в
адресном пространстве ядра.
2. Операция проверки и изменения значения семафора должна быть реа!
лизована в виде одной атомарной по отношению к другим процессам
(т. е. непрерываемой другими процессами) операции. В противном
случае возможна ситуация, когда после проверки значения семафора
выполнение процесса будет прервано другим процессом, который в
свою очередь проверит семафор и изменит его значение. Единствен!
ным способом гарантировать атомарность критических участков опе!
раций является выполнение этих операций в режиме ядра (см. режи!
мы выполнения процесса).
Таким образом семафоры являются системным ресурсом, действия над
которым производятся через интерфейс системных вызовов.
Семафоры в System V обладают следующими характеристиками:
Семафор представляет собой не один счетчик, а группу, состоящую
из нескольких счетчиков, объединенных общими признаками (на!
пример, дескриптором объекта, правами доступа и т. д.).
Каждое из этих чисел может принимать любое неотрицательное значе!
ние в пределах, определенных системой (а не только значения 0 и 1).
Для каждой группы семафоров (в дальнейшем мы будем называть группу
просто семафором) ядро поддерживает структуру данных вклю!
чающую следующие поля:
struct Описание прав доступа
struct Указатель на первый элемент массива семафоров
sem_nsems Число семафоров в группе
Время последней операции
Время последнего изменения
Значение конкретного семафора из набора хранится во внутренней струк!
туре sem:
ushort semval Значение семафора
sempid Идентификатор процесса, выполнившего послед!
нюю операцию над семафором
ushort Число процессов, ожидающих увеличения значе!
ния семафора
ushort Число процессов, ожидающих обнуления сема!
фора
Помимо собственно значения семафора, в структуре sem хранится иден!
тификатор процесса, вызвавшего последнюю операцию над семафором,
число процессов, ожидающих увеличения значения семафора, и число
www.books-shop.com
Взаимодействие процессами 255
процессов, ожидающих, когда значение семафора станет равным нулю.
Эта информация позволяет ядру производить операции над семафорами,
которые мы обсудим несколько позже.
Для получения доступа к семафору (и для его создания, если он не суще!
ствует) используется системный вызов
ttinclude
#include <sys/ipc.h>
ttinclude <sys/sem.h>
int key, int int
В случае успешного завершения операции функция возвращает дескрип!
тор объекта, в случае 1. Аргумент задает число семафо!
ров в группе. В случае, когда мы не создаем, а лишь получаем доступ к
существующему семафору, этот аргумент игнорируется. Аргумент semflag
определяет права доступа к семафору и флажки для его создания
(IPC_CREAT, IPC_EXCL).
После получения дескриптора объекта процесс может производить опера!
ции над семафором, подобно тому, как после получения файлового деск!
риптора процесс может читать и записывать данные в файл. Для этого ис!
пользуется системный вызов
ttinclude
ttinclude
ttinclude
int semop(int struct size_t
В качестве второго аргумента функции передается указатель на структуру
данных, определяющую операции, которые требуется произвести над се!
мафором с дескриптором semid. Операций может быть несколько, и их
число указывается в последнем аргументе nops. Важно, что ядро обеспе!
чивает атомарность выполнения критических участков операций
(например, проверка значения — изменение значения) по отношению к
другим процессам.
Каждый элемент набора операций имеет вид:
struct sembuf {
short sem /*номер семафора в
short
short sem
UNIX допускает три возможные операции над семафором, определяемые
полем semop:
1. Если величина semop положительна, то текущее значение семафора
увеличивается на эту величину.
www.books-shop.com
256 Глава 3. управления процессами
2. Если значение semop равно нулю, процесс ожидает, пока семафор не
обнулится.
Если величина semop отрицательна, процесс ожидает, пока значение
семафора не станет большим или равным абсолютной величине
semop. Затем абсолютная величина semop вычитается из значения се!
мафора.
Можно заметить, что первая операция изменяет значение семафора
(безусловное выполнение), вторая операция только проверяет его значение
выполнение), а третья — проверяет, а затем изменяет значение
семафора (условное выполнение).
При работе с семафорами взаимодействующие процессы должны догово!
риться об их использовании и кооперативно проводить операции над се!
мафорами. Операционная система не накладывает ограничений на исполь!
зование семафоров. В частности, процессы вольны решать, какое значение
семафора является разрешающим, на какую величину изменяется значение
семафора и т. п.
Таким образом, при работе с семафорами процессы используют различные
комбинации из трех операций, определенных системой, по!своему трактуя
значения семафоров.
В качестве примера рассмотрим два случая использования бинарного сема!
фора (т. е. значения которого могут принимать только 0 и 1). В первом
примере значение 0 является разрешающим, а 1 запирает некоторый разде!
ляемый ресурс (файл, разделяемая память и т. п.), ассоциированный с се!
мафором. Определим операции, запирающие ресурс и освобождающие его:
static struct = {
О, О, О, обнуления
О, 1, 0 /*затем увеличить значение семафора на
static struct sembuf sop unlock [1] = {
0, 0 значение
Итак, для запирания ресурса процесс вызов:
обеспечивающий атомарное выполнение двух
Ядро обеспечивает атомарное выполнение не всего набора операций в целом, а лишь кри!
тических участков. Так, например, в процессе ожидания освобождения ресурса (ожидание
нулевого значения семафора) выполнение процесса будет (и должно быть) прервано про!
цессом, который освободит ресурс (т. е. установит значение семафора равным 1). Ожида!
ние семафора соответствует "сна" процесса, допускающим выполнение других
процессов в системе. В противном случае, процесс, ожидающий ресурс, остался бы забло!
кированным навсегда.
www.books-shop.com
процессами 257
1. Ожидание доступности ресурса. В случае, если ресурс уже занят
(значение семафора равно 1), выполнение процесса будет приостанов!
лено до освобождения ресурса (значение семафора равно 0).
2. Запирание ресурса. Значение семафора устанавливается равным
Для освобождения ресурса процесс должен произвести вызов:
который уменьшит текущее значение семафора (равное 1) на и оно ста!
нет равным 0, что соответствует освобождению ресурса. Если какой!либо
из процессов ожидает ресурса (т. е. произвел вызов операции sop_lock),
он будет "разбужен" системой, и сможет в свою очередь запереть ресурс и
работать с ним.
Во втором примере изменим трактовку значений семафора: значению 1
семафора соответствует доступность некоторого ассоциированного с сема!
фором ресурса, а нулевому значению — недоступность. В этом случае
содержание операций несколько изменится.
static struct = {
О, 1, 0, разрешающего сигнала (1),
затем обнулить
static struct sembuf sop_unlock [1] = {
О, 1, 0 значение семафора на
Процесс запирает ресурс вызовом:
1);
а освобождает:
Во втором случае операции получились проще (по крайней мере их код
стал компактнее), однако этот подход имеет потенциальную опасность:
при создании семафора, его значения устанавливаются равными 0, и во
втором случае он сразу же запирает ресурс. Для преодоления данной си!
туации процесс, первым создавший семафор, должен вызвать операцию
однако в этом случае процесс инициализации семафора пе!
рестанет быть атомарным и может быть прерван другим процессом, кото!
рый, в свою очередь, изменит значение семафора. В итоге, значение сема!
фора станет равным 2, что повредит нормальной работе с разделяемым
ресурсом.
Можно предложить следующее решение данной проблемы:
семафор, если он уже существует возвращает
ошибку, поскольку указан флаг
if ( (semid = semget. ( key, perms IPC_CREAT I )
< 0)
www.books-shop.com
258 Глава 3. /правления процессами
if (errno = EEXIST)
{
ошибка вызвана существованием
if ( = key, perms ) ) < 0)
не хватает системных
}
else не хватает системных
семафор создан нами,
else
Разделяемая память
Интенсивный обмен данными между процессами с использованием рас!
смотренных механизмов межпроцессного взаимодействия (каналы, FIFO,
очереди сообщений) может вызвать падение производительности системы.
Это, в первую очередь, связано с тем, что данные, передаваемые с помо!
щью этих объектов, копируются из буфера передающего процесса в буфер
ядра и затем в буфер принимающего процесса. Механизм разделяемой па!
мяти позволяет избавиться от накладных расходов передачи данных через
ядро, предоставляя двум или более процессам возможность непосредст!
венного получения доступа к одной области памяти для обмена данными.
Безусловно, процессы должны предварительно "договориться" о правилах
использования разделяемой памяти. Например, пока один из процессов
производит запись данных в разделяемую память, другие процессы долж!
ны воздержаться от работы с ней. К счастью, задача кооперативного ис!
пользования разделяемой памяти, заключающаяся в синхронизации вы!
полнения процессов, легко решается с помощью семафоров.
Примерный сценарий работы с разделяемой памятью выглядит следую!
щим образом:
1. Сервер получает доступ к разделяемой памяти, используя семафор.
2. Сервер производит запись данных в разделяемую память.
После завершения записи сервер освобождает разделяемую память с
помощью семафора.
4. Клиент получает доступ к разделяемой памяти, запирая ресурс с по!
мощью семафора.
5. Клиент производит чтение данных из разделяемой памяти и освобож!
дает ее, используя семафор.
Для каждой области разделяемой памяти, ядро поддерживает структуру
данных основными полями которой являются:
struct shm_perm Права доступа, владельца и создателя области (см.
описание выше)
shm_segsz Размер выделяемой памяти
www.books-shop.com
Взаимодействие процессами 259
ushort Число использующих разделяемую па%
мять
Время последнего присоединения к разделяемой
памяти
Время последнего отключения от разделяемой
памяти
Время последнего изменения
Для создания или для доступа к уже существующей разделяемой памяти
используется системный вызов
<sys/ipc.h>
int key, size, int
Функция возвращает дескриптор разделяемой памяти в случае успеха, и !1 в
случае неудачи. Аргумент size определяет размер создаваемой области па!
мяти в байтах. аргумента shmflag задают права доступа к объекту
и специальные флаги и Заметим, что вызов
лишь создает или обеспечивает доступ к разделяемой памяти, но не позво!
ляет работать с ней. Для работы с разделяемой памятью (чтение и запись)
необходимо сначала присоединить (attach) область вызовом
ttinclude <sys/ipc.h>
ttinclude <sys/shm.h>
char shmid, char int
Вызов возвращает адрес начала области в пространстве
процесса размером заданным предшествующем вызовом В
этом адресном пространстве взаимодействующие процессы могут разме!
щать требуемые структуры данных для обмена информацией. Правила по!
лучения этого адреса следующие:
1. Если аргумент нулевой, то система самостоятельно выбирает
адрес.
2. Если аргумент shmaddr отличен от нуля, значение возвращаемого ад!
реса зависит от наличия флажка SHM RND в аргументе
• Если флажок SHM RND не установлен, система присоединяет
разделяемую к указанному shmaddr адресу.
• Если флажок SHM_RND установлен, система присоединяет разде!
ляемую память к адресу, полученному округлением в меньшую
сторону shmaddr до некоторой определенной величины SHMLBA.
По умолчанию разделяемая память присоединяется с правами на чтение и
запись. Эти права можно изменить, указав флажок в аргумен!
те shmflag.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
260 Глава 3. управления процессами
Таким образом, несколько процессов могут отображать область разделяе!
мой памяти в различные участки собственного виртуального адресного
пространства, как это показано на рис. 3.20.
3.20. Совместное использование разделяемой памяти
Окончив работу с разделяемой памятью, процесс отключает (detach) об!
ласть вызовом
<sys/ipc.h>
int
При работе с разделяемой памятью необходимо синхронизировать выпол!
нение взаимодействующих процессов: когда один из процессов записывает
данные в разделяемую память, остальные процессы ожидают завершения
операции. Обычно синхронизация обеспечивается с помощью семафоров,
назначение и число которых определяется конкретным использованием
разделяемой памяти.
Можно привести примерную схему обмена данными между двумя процес!
сами (клиентом и сервером) с использованием разделяемой памяти. Для
синхронизации процессов использована группа из двух семафоров. Пер!
вый семафор служит для блокирования доступа к разделяемой памяти, его
разрешающий сигнал — 0, а 1 является запрещающим сигналом. Второй
семафор служит для сигнализации серверу о том, что клиент начал работу.
Необходимость применения второго семафора обусловлена следующими
обстоятельствами: начальное состояние семафора, синхронизирующего
работу с памятью, является открытым (0), и вызов сервером операции
заблокирует обращение к памяти для клиента. Таким образом,
www.books-shop.com
Взаимодействие
сервер должен вызвать операцию только после того, как разде!
ляемую память заблокирует клиент. второго семафора заклю!
чается в уведомлении сервера, что клиент начал работу, заблокировал раз!
деляемую память и начал записывать данные в эту область. Теперь, при
вызове сервером операции mem_lock его выполнение будет приостановле!
но до освобождения памяти клиентом, который делает это после оконча!
ния записи строки "Здравствуй,
ttdefine 80
ttdefine PERM 0666
/*Структура данных в разделяемой
typedef struct
int segment;
char
} Message;
/*0жидание начала выполнения
static struct [1 ] = {
1, 1, 0
сервера о том, что клиент начал
static struct sembuf = {
1, 1, 0
/*Блокирование разделяемой
static struct sembuf = {
О, О, О,
0 }
/*0свобождение
static struct sembuf {
О, 1, 0
Сервер:
<sys/ipc.h>
<sys/sem.h>
<sys/shm.h>
"shmem.h"
{
Message
key_t key;
int shmid, semid;
/*Получим Один и тот же ключ можно использовать как для
семафора, так и для разделяемой
www.books-shop.com
262 Глава 3. процессами
if ( (key = <
printf получить }
область разделяемой
if ( (Message.) ,
PERM | < 0)
{
создать область }
if ( (msgptr (Message 0, <
}
группу из двух
Первый семафор — для синхронизации работы с
Второй семафор — для синхронизации выполнения
if ( = 2, PERM | <
создать }
пока клиент начнет работу и заблокирует разделяемую
if 1) <
выполнить }
/*Ждем, пока клиент закончит запись в разделяемую память и
освободит ее. После этого заблокируем
if 2) <
printf ( "Невозможно }
сообщение на
/*0свободим разделяемую
if 1) <
выполнить }
/*0тключимся от
if <
}
остальную работу по удалению объектов сделает
exit (0)
}
Клиент:
ttinclude
ttinclude <sys/ipc.h>
#include
#include
{
Message *msgptr;
www.books-shop.com
key_t key;
semid;
Один и тот же ключ можно использовать как для
семафора, так и для разделяемой
if ( (key <
получить }
/*Получим доступ к разделяемой
if ( (shmid = <
}
if ( = (Message *) 0, <
}
доступ к
if ( (semid = 2, <
}
/*3аблокируем разделяемую
if (semop (semid, , 2) <
выполнить }
сервер о начале
if 1) <
выполнить }
/*3апишем в разделяемую память
"Здравствуй,
/*0свободим разделяемую
if 1) <
выполнить }
/*Ждем, пока сервер в свою очередь не освободит разделяемую
память
if 2) <
выполнить }
от
if <
}
/*Удалим созданные объекты
if IPC_RMID, 0) <
удалить )
if (semid, 0, < 0) {
удалить }
www.books-shop.com
264 Глава 3. Подсистема управления процессами
Межпроцессное взаимодействие в BSD UNIX.
Разработчики системы межпроцессного взаимодействия BSD UNIX руко!
водствовались рядом соображений:
Во!первых, взаимодействие между процессами должно быть унифицирова!
но, независимо от того, выполняются ли они на одном компьютере или на
разных хостах сети. Наиболее оптимальная реализация межпроцессного
взаимодействия, удовлетворяющего этому требованию, должна иметь мо!
дульную структуру и базироваться на общей подсистеме поддержки сети
UNIX. При этом могут быть использованы различные схемы адресации объ!
ектов, их расположение, протоколы передачи данных и т. д. В этой связи
было введено понятие коммуникационный домен (communication domain),
описывающее набор обозначенных характеристик взаимодействия.
Для обозначения коммуникационного узла, обеспечивающего прием и
передачу данных для объекта (процесса), был предложен специальный
объект — (socket). Сокеты создаются в рамках определенного ком!
муникационного домена, подобно тому как файлы создаются в рамках
файловой системы. Сокеты имеют соответствующий интерфейс доступа в
файловой системе UNIX, и так же как обычные файлы, адресуются неко!
торым целым числом — дескриптором. Однако в отличие от обычных
файлов, представляют собой виртуальный объект, который сущест!
вует, пока на него ссылается хотя бы один из процессов.
Во!вторых, коммуникационные характеристики взаимодействия должны
быть доступны процессам в некоторой унифицированной форме. Другими
словами, приложение должно иметь возможность затребовать определен!
ный тип связи, например, основанный на виртуальном канале (virtual
circuit) или датаграммах (datagram), причем эти типы должны быть согла!
сованы для всех коммуникационных доменов. Все сокеты условно можно
разделить на несколько типов, в зависимости от предоставляемых комму!
никационных характеристик. Полный набор этих характеристик включает:
Упорядоченную доставку данных
Отсутствие дублирования данных
О Надежную доставку данных
Сохранение границ сообщений
О Поддержку передачи экстренных сообщений
установление соединения
Например, каналы, рассмотренные ранее, обеспечивают только первые
три характеристики. При этом данные имеют вид сплошного потока, вы!
членение сообщений из которого должно при необходимости быть обеспе!
чено взаимодействующими приложениями.
Поддержка передачи экстренных сообщений предполагает возможность
доставки данных вне нормального потока. Как правило, это сообщения,
www.books-shop.com
процессами 265
связанные с некоторыми срочными событиями, требующими немедленной
реакции.
Взаимодействие с предварительным установлением соединения предпола!
гает создание виртуального канала между источником и получателем дан!
ных. Это избавляет от необходимости идентифицировать передающую
сторону в каждом пакете данных. Идентификация происходит на началь!
ном этапе установления связи и затем сохраняется для всех пакетов, при!
надлежащих данному виртуальному каналу.
В BSD UNIX реализованы следующие основные типы сокетов:
(datagram socket), через который осуществляется
теоретически ненадежная, несвязная передача пакетов.
Сокет потока (stream socket), через который осуществляется надеж!
ная передача потока байтов без сохранения границ сообщений. Этот
тип сокетов поддерживает передачу экстренных данных.
Сокет пакетов (packet socket), через который осуществляется надеж!
ная последовательная передача данных без дублирования с предвари!
тельным установлением связи. При этом сохраняются границы со!
общений.
Сокет низкого уровня (raw socket), через который осуществляется не!
посредственный доступ к коммуникационному протоколу.
Наконец, для того чтобы независимые процессы имели возможность взаи!
модействовать друг с другом, для сокетов должно быть определено про!
странство имен. Имя сокета имеет смысл только в рамках коммуникаци!
онного домена, в котором он создан. Если для System V используются
ключи, то имена сокетов представлены адресами.
Программный интерфейс сокетов
Итак, являются коммуникационным интерфейсом взаимодействую!
щих процессов. Конкретный характер взаимодействия зависит от типа ис!
пользуемых сокетов, а коммуникационный домен, в рамках которого создан
сокет, определяет базовые свойства этого взаимодействия. В табл. 3.6 приве!
дены типы сокетов и их названия.
Таблица 3.6. Типы сокетов в системе BSD UNIX
Название Тип
Сокет датаграмм
Сокет потока
SOCK_SEQPACKET Сокет пакетов
Сокет низкого уровня
www.books-shop.com
266 Глава 3. процессами
Для создания сокета процесс должен указать тип и коммуникаци!
онный домен, в рамках которого будет использоваться сокет. Поскольку
коммуникационный домен может поддерживать использование нескольких
протоколов, процесс может также указать конкретный коммуникационный
протокол для взаимодействия. Если таковой не указан, система выберет
наиболее подходящий из списка протоколов, доступных для данного ком!
муникационного домена. Если же в рамках указанного домена создание
сокета данного типа невозможно, т. е. отсутствует соответствующий ком!
муникационный протокол, запрос процесса завершится неудачно.
Для создания сокета используется системный вызов имеющий
следующий вид:
int domain, int type,
Здесь аргумент domain определяет коммуникационный домен, type — тип
сокета, a protocol — используемый протокол (может быть не указан, т. е.
приравнен 0). В случае успеха системный вызов возвращает положитель!
ное целое число, аналогичное файловому дескриптору, которое служит для
адресации данного сокета в последующих вызовах.
По существу коммуникационный домен определяет семейство протоколов
(protocol family), допустимых в рамках данного домена. Возможные значе!
ния аргумента domain включают:
Домен локального межпроцессного взаимодействия в пределах
единой операционной системы UNIX. Внутренние протоколы.
Домен взаимодействия процессов удаленных систем. Протоколы
Internet (TCP/IP).
Домен взаимодействия процессов удаленных систем. Протоколы
Xerox NS.
Поскольку домен и семейство протоколов определяют адресное простран!
ство взаимодействия (допустимые адреса и их формат), то в названиях до!
менов присутствует префикс AF (от address family — семейство адресов).
Допустимыми также являются названия с префиксом PF (protocol family)
PF UNIX, PF И Т. Д.
Поскольку являются частью BSD в системах этой ветви
функции, связанные с этими объектами, в частности socket(2) и рассмотренные ниже,
представляют собой системные вызовы. В UNIX ветви System V интерфейс сокетов сохра!
нен для совместимости, но имеет совершенно отличную от принятой в BSD архитектуру
(основанную на подсистеме STREAMS). Поэтому все его функции являются библиотеч!
ными и описываются, соответственно в разделе 3 электронного справочника. Однако, ос!
тавляя пальму первенства в этом вопросе за BSD UNIX, в этом разделе будем считать эти
функции системными вызовами и связывать с ними раздел 2 справочника
www.books-shop.com
Взаимодействие между процессами 267
Заметим, что домен может не поддерживать определенные типы
Для сравнения в табл. 3.7 приведены два основных коммуникационных
домена — внутренний домен UNIX, предназначенный для взаимодействия
процессов одной операционной системы, и домен TCP/IP, используемый
в сетевых распределенных приложениях.
Таблица 3.7. Поддержка различных типов сокетов в доменах
Домен: AF UNIX
Тип сокета
SOCK STREAM
SOCK
SOCK SEQPACKET
SOCK RAW
Да
Да
Нет
Нет
Да
Да
Нет
Да
Также допустимы не все комбинации типа сокета и используемого комму!
никационного протокола (если таковой явно указан в запросе). Так для
домена AF_INET возможны следующие комбинации:
Сокет Протокол
SOCK_STREAM (TCP)
(UDP)
(IP)
Указанные протоколы принадлежат семейству сетевых протоколов TCP/IP
и будут подробно рассмотрены в главе 6.
Создание сокета не означает создания коммуникационного узла. Для одно!
значной идентификации сокета его необходимо позиционировать в про!
странстве имен данного коммуникационного домена. В общем случае каж!
дый коммуникационный канал определяется двумя узлами — источником и
получателем данных, и может быть охарактеризован пятью параметрами:
1. Коммуникационным протоколом
2. Локальным адресом
3. Локальным процессом
4. Удаленным адресом
5. Удаленным процессом
Как правило, адрес определяет операционную систему (или хост сети), а
процесс — конкретное приложение, получающее или передающее данные.
Однако конкретные значения и формат этих параметров определяются
коммуникационным доменом.
www.books-shop.com
268 Глава 3. управления процессами
Поскольку при создании сокета указывается только один параметр —
коммуникационный протокол, прежде чем передача данных между взаи!
модействующими процессами станет возможной необходимо указать четы!
ре дополнительных параметра для коммуникационного канала. Очевидно,
что взаимодействующие стороны должны делать это согласованно, исполь!
зуя либо заранее определенные адреса, либо договариваясь о них в про!
цессе установления связи. Процедура установки этих параметров сущест!
венным образом зависит и от типа создаваемого канала, определяемого
типом используемого сокета и коммуникационного протокола.
Иллюстрация взаимодействия между процессами при виртуальном комму!
никационном канале с предварительным установлением связи приведена
на рис. 3.21, а взаимодействие, основанное на датаграммах без установле!
ния связи показано на рис. 3.22.
Рис. 3.21. Взаимодействие между процессами при создании виртуального канала (с
предварительным установлением соединения)
www.books-shop.com
между процессами 269
Рис. 3.22. Взаимодействие между процессами, основанное на датаграммах (без
предварительного установления соединения)
Как видно из рисунков, фактической передаче данных предшествует началь!
ная фаза связывания (binding) сокета, когда устанавливается дополнительная
информация, необходимая для определения коммуникационного узла. Связы!
вание может быть осуществлено с помощью системного вызова
int bind(int sockfd, struct sockaddr *localaddr, int
Здесь sockfd является дескриптором сокета, полученным при его созда!
нии; аргумент определяет локальный адрес, с которым необхо!
димо связать сокет; параметр addrlen определяет размер адреса. Заметим,
что речь идет о связывании с локальным адресом, в общем случае опреде!
ляющим два параметра коммуникационного канала (коммуникационный
узел): локальный адрес и локальный процесс.
Как уже обсуждалось, адрес сокета зависит от коммуникационного доме!
на, в рамках которого он определен. В общем случае адрес определяется
следующим образом (в файле <sys/socket.h>):
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
270 Глава 3. управления процессами
struct {
char
Поле sa_family определяет коммуникационный домен (семейство прото!
колов), a .— содержит собственно адрес, формат которого опреде!
лен для каждого домена.
Например, для внутреннего домена UNIX адрес выглядит следующим об!
разом (определен в
struct sockaddr_un {
short /* */
char
Поскольку в данном домене взаимодействующие процессы выполняются
под управлением одной операционной системы на одном и том же хосте,
коммуникационный узел может быть однозначно определен одним пара!
метром — локальным процессом. В качестве адреса в домене UNIX ис!
пользуются имена файлов.
В отличие от локального межпроцессного взаимодействия, для сетевого
обмена данными необходимо указание как локального процесса, так и
хоста, на котором выполняется данный процесс. Для домена Internet (се!
мейство протоколов TCP/IP) используется следующий формат адреса
(определен в файле <netinet/in.h>):
struct {
short /* ==AF_INET */
struct in_addr
char
Адреса этого домена (IP!адреса) будут рассмотрены подробнее в главе 6.
Пока лишь заметим, что адрес хоста представляет собой 32!разрядное це!
лое число sin_addr, а процесс (приложение) адресуется 16!разрядным
номером порта sin_port.
На рис. 3.23 показаны рассмотренные форматы адресов сокетов.
Итак, связывание необходимо для присвоения сокету локального адреса и,
таким образом, для определения коммуникационного узла. Можно выде!
лить три случая использования для этого функции
1. Сервер регистрирует свой адрес. Этот адрес должен быть заранее из!
вестен клиентам, желающим "общаться" с сервером. Связывание необ!
ходимо, прежде чем сервер будет готов к приему запросов от клиентов.
2. При взаимодействии без предварительного установления связи и соз!
дания виртуального канала клиент также должен предварительно за!
www.books-shop.com
3.
регистрировать свой адрес. Этот адрес должен быть уникальным в
рамках коммуникационного домена. В случае домена UNIX об этом
должно позаботиться само приложение. Этот адрес не должен быть за!
ранее известен серверу, поскольку запрос всегда инициирует клиент,
автоматически передавая вместе с ним свой адрес. Полученный адрес
удаленного узла затем используется сервером для мультиплексирова!
ния сообщений, отправляемым различным клиентам.
Даже в случае взаимодействия с использованием виртуального канала
клиент может пожелать зарегистрировать собственный адрес, не по!
лагаясь при этом на систему.
UNIX домен
un
Internet домен
sockaddr in
AF_UNIX
Имя файла до 10
port
IP%адрес
He используется
т
2 байта
1s
2 байта
86
)йта
айт
Рис. 3.23. Адреса сокетов
Назначение адреса для клиента также можно выполнить с помощью сис!
темного вызова устанавливающего связь с сервером и автомати!
чески связывающего сокет клиента с локальным коммуникационным уз!
лом. Вызов имеет вид:
ttinclude
ttinclude
int sockfd, struct sockaddr *servaddr, int
Характер этого вызова предполагает создание виртуального канала и, та!
ким образом, используется для предварительного установления связи меж!
ду коммуникационными узлами. В этом случае клиенту нет необходимости
www.books-shop.com
272 Глава 3. управления процессами
явно связывать с помощью системного вызова Локальный
узел коммуникационного канала указывается дескриптором сокета
sockfd, для которого система автоматически выбирает приемлемые значе!
ния локального адреса и процесса. Удаленный узел определяется аргумен!
том servaddr, который указывает на адрес сервера, a addrlen задает его
длину.
Вызов может также применяться и клиентами, использующими
без создания виртуального канала. В этом случае
не вызывает фактического соединения с сервером, а является
удобным способом сохранения параметров адресата (сервера), которому
будут направляться При этом клиент будет избавлен от необ!
ходимости указывать адрес сервера при каждом отправлении данных.
Следующие два вызова используются сервером только при взаимодейст!
вии, основанном на предварительном создании виртуального канала меж!
ду сервером и клиентом.
Системный вызов listen(2) информирует систему, что сервер готов прини!
мать запросы. Он имеет следующий вид:
int (int sockfd, int
Здесь параметр sockfd определяет сокет, который будет использоваться
для получения запросов. Предполагается, что сокет был предварительно
связан с известным адресом. Параметр backlog указывает максимальное
число запросов на установление связи, которые могут ожидать обработки
Фактическую обработку запроса клиента на установление связи произво!
дит системный вызов
int sockfd, struct sockaddr
int
Вызов accept(2) извлекает первый запрос из очереди и создает новый со!
кет, характеристики которого не отличаются от сокета sockfd, и таким
Если в момент получения запроса на установление связи очередь ожидающих запросов
достигла своего максимального значения, вызов клиента завершится с ошибкой
для UNIX (AF_UNIX). Для других доменов результат зависит от то!
го, поддерживает ли протокол повторную передачу запроса. Например, протокол TCP
(домен AF_INET) будет передавать повторные запросы, пока число запросов в очереди не
уменьшится, либо не произойдет тайм!аут, определенный для протокола. В последнем
случае вызов клиента завершится с ошибкой
www.books-shop.com
между процессами 273
образом завершает создание виртуального канала со стороны сервера. Од!
новременно accept(2) возвращает параметры удаленного коммуникацион!
ного узла — адрес клиента clntaddr и его размер Новый сокет
используется для обслуживания созданного виртуального канала, а полу!
ченный адрес клиента исключает анонимность последнего. Дальнейший
типичный сценарий взаимодействия имеет вид:
= Создать сокет
. . Связать его с известным локальным
адресом
Организовать очередь запросов
for ( ; ) {
newsockfd = Получить запрос
if () 0) { Породить дочерний процесс
close (sockfd) Дочерний процесс
exit (0)
}
else
close (newsockfd) Родительский процесс
}
В этом сценарии, в то время как дочерний процесс обеспечивает фактиче!
ский обмен данными с клиентом, родительский процесс продолжает
"прослушивать" поступающие запросы, порождая для каждого из них от!
дельный процесс!обработчик. Очередь позволяет буферизировать запросы
на время, пока сервер завершает вызов accept(2) и затем создает дочерний
процесс. Заметим, что новый сокет newsockfd, полученный в результате
вызова accept(2), адресует полностью определенный коммуникационный
канал: протокол и полные адреса обоих узлов — клиента и сервера. На!
против, для сокета sockfd определена только локальная часть канала. Это
позволяет серверу продолжать использовать sockfd для "прослушивания"
последующих запросов.
Наконец, если для сокетов потока при приеме и передаче данных могут
быть использованы стандартные вызовы read(2) и то дата!
грамм должны пользоваться специальными системными вызовами (эти
вызовы также доступны для сокетов других типов):
ftinclude
int send(int s, const char int int
int s, const char int len, int flags,
const struct sockaddr int
int s, char *buf, int len, int flags);
int recvfrom(int s, char int len, int flags,
struct sockaddr int
www.books-shop.com
274 Глава 3. управления процессами
Функции и используются для передачи данных удаленно!
му узлу, а функции recv(2) и — для их приема. Основным раз!
личием между ними является то, что функции и recv(2) могут быть
использованы только для "подсоединенного" сокета, т. е. после вызова
Все эти вызовы используют в качестве первого аргумента дескриптор соке!
та, через который производится обмен данными. Аргумент msg содержит
сообщение длиной которое должно быть передано по адресу toaddr,
длина которого составляет байтов. Для функции использует!
ся адрес получателя, установленный предшествовавшим вызовом
Аргумент buf представляет собой буфер, в который копируются
полученные данные.
Параметр может принимать следующие значения:
Передать или принять экстренные данные вместо обычных
Просмотреть данные, не удаляя их из системного буфера (последую%
щие операции чтения получат те же данные)
Пример использования сокетов
В заключение приведем пример использования сокетов для организации
межпроцессного взаимодействия. Поскольку в данном разделе не затрагива!
ются сетевые вопросы, то и которые будут использованы в приме!
ре, принадлежат домену UNIX. Как и в предыдущих примерах, функцио!
нальность нашей распределенной системы не отличается разнообразием:
клиент посылает серверу сообщение "Здравствуй, а сервер отправ!
ляет его обратно клиенту, который после получения выводит сообщение
на экран.
В примере использованы сокеты датаграмм, которые в домене UNIX прак!
тически не отличаются от сокетов потока. В качестве адреса сервера пред!
лагается имя файла (мы полагаем, что в системе запущен
только один сервер из данного каталога). Предполагается, что клиенты
заранее знают этот адрес. Сервер связывает созданный сокет с этим ло!
кальным адресом и таким образом регистрируется в системе. Начиная с
этого момента он готов к получению и обработке сообщений. Сервер на!
чинает бесконечный цикл, ожидая сообщений от клиентов, блокируясь на
вызове При получении сообщения сервер отправляет его об!
ратно, вызывая
Сервер:
<sys/un.h>
MAXBUF 256
char
www.books-shop.com
между процессами 275
struct
int sockfd;
int saddrlen, caddrlen, n;
/* Создадим сокет*/
if = < 0} {
создать }
/* Свяжем сокет с известным локальным адресом. Поскольку адрес в
домене UNIX представляет собой имя файла, который будет создан
системным вызовом сначала удалим файл с этим именем в
случае, если он сохранился от предыдущего запуска сервера */
=
.
saddrlen = +
if (struct sockaddr
saddrlen) < 0)
{
связывания сокета с
exit
}
/* Теперь запустим бесконечный цикл чтения сообщений от клиентов
и отправления их обратно */
=
) {
caddrlen =
n = buf, MAXBUF, 0,
(struct sockaddr
if ( n < 0) {
/* Благодаря вызову recvfrom мы знаем адрес клиента, от
которого получено Используем этот адрес для передачи
сообщения обратно
if buf, n, 0,
(struct sockaddr caddrlen) != n) {
}
}
Клиент создает сокет датаграмм и связывает его со своим уникальным ад!
ресом. Уникальность адреса определяется уникальностью имени файла.
Поскольку одновременно могут работать несколько клиентов, возникает
задача выполнения условия уникальности. Для этого мы используем функ!
цию позволяющую по заданному шаблону и
на основании идентификатора текущего процесса получить уникальное
имя, заменяя соответствующим образом символы Связывание сокета
позволяет при отправлении сообщения неявно указать его "адрес отправи!
теля", так что серверу не составляет труда отправить сообщение обратно.
www.books-shop.com
276 Глава 3. Подсистема управления процессами
Клиент:
ttinclude
<sys/un.h>
char = "Здравствуй,
ttdefine 256
char
{
struct sockaddr_un serv_addr,
int sockfd;
int saddrlen, caddrlen,
/* Установим адрес сервера, с которым мы будем обмениваться
Для этого заполним структуру данных которую
будем использовать при отправлении данных серверу с помощью
вызова Значение адреса известно по предварительной
договоренности */
=
saddrlen = +
Создадим датаграмм */
if = < 0) {
создать }
Необходимо связать сокет с некоторым локальным адресом, чтобы
сервер имел возможность возвратить посланное Этот ад
рес должен быть уникальным в пределах коммуникационного домена
т. е. данной операционной системы. Для обеспечения этого условия,
воспользуемся функцией которая возвращает уникальное
имя, основанное на представленном шаблоне и идентификаторе нашего
процесса
. =
caddrlen = +
if (struct sockaddr
caddrlen) < 0)
{
связывания
}
/* Итак, отправляем сакраментальное приветствие */
msglen =
if msg, msglen, 0,
(struct sockaddr saddrlen) != msglen)
{
передачи
www.books-shop.com
процессами 277
/* Прочитаем
i f = buf, MAXBUF, О, NULL, < 0)
{
printf получения сообщения
И выведем его на экран
/* Уберем за собой */
exit (0)
}
Сравнение различных систем межпроцессного взаимодействия
Заканчивая разговор о межпроцессном взаимодействии в UNIX, приведем
сводную сравнительную таблицу рассмотренных систем.
Простран%
ство имен
Объект
Создание
объекта
Связывание
Передача
данных
Уничтоже%
ние
Каналы
—
Системный
канал
write
close
FIFO
Имя файла
Именован%
ный
write
close
Сообще%
ния
Ключ
Очередь
сообщений
msgget
msgsnd
Разделя%
емая па%
мять
Ключ
Разделяемая
область па%
мяти
Непосред%
ственный до%
ступ
(домен
UNIX)
Имя файла
Коммуника%
ционный узел
connect
write
sendto
close
Если говорить о производительности то наиболее быстрым способом
передачи данных между неродственными процессами является разделяемая
память. Разделяемая память является частью адресного пространства для
каждого из взаимодействующих процессов, поэтому чтение и запись в эту
область неотличимы, например, от чтения и записи в область собственных
данных процесса. Однако при использовании разделяемой памяти необхо!
www.books-shop.com
278 Глава 3. управления процессами
димо обеспечить синхронизацию процессов. При использовании семафо!
ров, необходимо иметь в виду следующие обстоятельства:
Применение семафоров может увеличить число процессов в очереди
на выполнение, поскольку несколько процессов, ожидающих разре!
шающего сигнала семафора, будут одновременно разбужены и пере!
ведены в очередь на выполнение.
Применение семафоров увеличивает число переключений контекста,
что, в свою очередь, увеличивает нагрузку на систему.
В то же время, использование семафоров является наиболее стан!
дартным (POSIX. хотя и неэффективным способом обеспечения
синхронизации.
Очереди сообщений предназначены для обмена короткими (обычно менее
1 Кбайт) структурами данных. Если объем данных превышает эту величи!
ну, использование сообщений может значительно увеличить число сис!
темных вызовов и уменьшить производительность операционной системы.
Интенсивность межпроцессного взаимодействия в системе можно опреде!
лить с помощью команды !т. Вывод команды показывает число ис!
пользования объектов IPC в секунду:
17
17
17
17
17
17
53 sema/s
0.20 20.00
0.60 12.20
08 2.20 10.40
13 0.80 25.10
18 0.00 15.60
Average 0.76 16.66
Заключение
В этой главе начато обсуждение внутренней архитектуры ядра UNIX, ко!
торое будет продолжено в следующих главах. Поскольку процессы являют!
ся движущей силой операционной системы, мы начали обсуждение имен!
но с этого вопроса. Действительно, не считая нескольких системных про!
цессов, являющихся частью ядра и выполняющих узкосистемные функ!
ции, основная работа операционной системы происходит по запросам и в
контексте прикладных процессов.
В главе обсуждается, каким образом прикладной процесс взаимодействует
с ядром операционной системы, как происходит справедливое распределе!
ние системных ресурсов между задачами, и тем самым обеспечивается
многозадачность UNIX. Также рассматриваются принципы организации
виртуальной памяти, когда каждый процесс имеет независимое адресное
пространство, размер которого в ряде случаев значительно превышает объ!
ем оперативной памяти компьютера. Наконец, здесь представлены струк!
туры данных ядра, связанные с управлением процессами и памятью.
www.books-shop.com
Файловая
БОЛЬШИНСТВО данных в операционной системе UNIX хранится в файлах,
организованных в виде дерева и расположенных на некотором носителе
данных. Обычно это локальный (т. е. расположенный на том же компью!
тере, что и сама операционная система) жесткий диск, хотя специальный
тип файловой системы — NFS (Network File System) обеспечивает хране!
ние файлов на удаленном компьютере. Файловая система также может
располагаться на CD!ROM, дискетах и других типах носителей, однако
для простоты изложения сначала мы рассмотрим традиционную файловую
систему UNIX, расположенную на обычном жестком диске компьютера.
Исконной файловой системой UNIX System V является s5fs. Файловая
система, разработанная в Беркли, FFS, появилась позже, в версии
UNIX. По сравнению с s5fs она обладает лучшей производительностью,
функциональностью и надежностью. Файловые системы современных вер!
сий UNIX имеют весьма сложную архитектуру, различную для разных вер!
сий. Несмотря на это все они используют базовые идеи, заложенные
работчиками UNIX в AT&T и Калифорнийском университете в Беркли.
Поэтому мы проиллюстрируем основные принципы организации файло!
вой системы UNIX на примере базовых систем System V (s5fs) и BSD
(FFS), которые, кстати, и сегодня поддерживаются в большинстве версий
UNIX.
Когда появилась файловая система FFS, архитектура UNIX поддерживала
работу только с одним типом файловой системы. Таким образом, создате!
ли различных версий операционной системы UNIX вынуждены были вы!
бирать одну файловую систему из нескольких возможных. Это неудобство
было преодолено введением независимой или виртуальной файловой систе!
мы — архитектуры, позволяющей обеспечивать работу с несколькими
"физическими" файловыми системами различных типов. В этой главе мы
рассмотрим реализацию виртуальной файловой системы, разработанную
фирмой Sun Microsystems. Данная архитектура является стандартом для
SVR4, однако и другие версии UNIX используют подобные подходы. В
качестве примера можно привести независимую файловую систему SCO
UNIX.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
280 Глава 4. Файловая
Далее мы рассмотрим схему доступа прикладных процессов к файлам —
всю цепочку структур данных от файловых дескрипторов процесса до фак!
тических дисковых данных, которую операционная система создает в ре!
зультате открытия процессом файла и которая затем используется для об!
мена данными.
В заключение мы рассмотрим буферный кэш — подсистему, которая по!
зволяет значительно увеличить производительность работы с дисковыми
данными.
Базовая файловая система System V
Каждый жесткий диск состоит из одной или нескольких логических час!
тей, называемых разделами (partitions). Расположение и размер раздела оп!
ределяются при форматировании диска. В UNIX разделы выступают в ка!
честве независимых устройств, доступ к которым осуществляется как к
различным носителям данных.
Например, диск может состоять из четырех разделов, каждый из которых
содержит свою файловую систему. Заметим, что в разделе может распола!
гаться только одна файловая система, которая не может занимать несколь!
ко разделов. В другой конфигурации диск может состоять только из од!
ного раздела, позволяя создание весьма емких файловых систем.
Файловая система s5fs занимает раздел диска и состоит из трех основных
компонентов, как показано на рис.
Рис. 4.1. Структура файловой системы s5fs
www.books-shop.com
файловая система V
Суперблок Содержит общую информацию о файловой
системе, например, об ее архитектуре, общем числе блоков и ин!
дексных дескрипторов, или метаданных
П Массив индексных Содержит метаданные всех
файлов файловой системы. Индексный дескриптор содержит статус!
ную информацию о файле и указывает на расположение данных
этого файла. Ядро обращается к inode по индексу в массиве ilist.
Один inode является корневым (root) inode файловой системы, через
него обеспечивается доступ к структуре каталогов и файлов после
монтирования файловой системы. Размер массива ilist является фик!
сированным и задается при создании файловой системы. Таким об!
разом, файловая система s5fs имеет ограничение по числу файлов,
которые могут храниться в ней, независимо от размера этих файлов.
П Блоки хранения данных. Данные обычных файлов и каталогов хранят!
ся в блоках. Обработка файла осуществляется через inode, содержа!
щего ссылки на блоки данных. Блоки хранения данных занимают
большую часть дискового раздела, и их число определяет макси!
мальный суммарный объем файлов данной файловой системы. Раз!
мер блока кратен 512 байтам, например файловая система SCO
UNIX использует размер блока в 1 Кбайт (отсюда и название).
Рассмотрим подробнее каждый из перечисленных компонентов.
Суперблок
Суперблок содержит информацию, необходимую для монтирования и
управления работой файловой системы в целом (например, для размеще!
ния новых файлов). В каждой файловой системе существует только один
суперблок, который располагается в начале раздела. Суперблок считывает!
ся в память при монтировании файловой системы и находится там до ее
отключения (размонтирования).
Суперблок содержит следующую информацию:
П Тип системы (s_type)
П Размер файловой системы в логических блоках, включая сам супер!
блок, ilist и блоки хранения данных
П Размер массива индексных дескрипторов (s_isize)
П Число свободных блоков, доступных для размещения
П Число свободных inode, доступных для размещения
П Флаги (флаг модификации флаг режима монтирования
П Размер логического блока (512, 1024, 2048)
П Список номеров свободных inode
П Список адресов свободных блоков
www.books-shop.com
282 Глава 4. Файловая
Поскольку число свободных inode и блоков хранения данных может быть
значительным, хранение двух последних списков целиком в суперблоке
непрактично. Например, для индексных дескрипторов хранится только
часть списка. Когда число свободных inode в этом списке приближается к
О, ядро просматривает и вновь формирует список свободных inode.
Для этого ядро анализирует поле индексного дескриптора, кото!
рое равно 0 у свободных inode.
К сожалению, такой подход неприменим в отношении свободных блоков
хранения данных, поскольку по содержимому блока нельзя определить,
свободен он или нет. Поэтому необходимо хранить список адресов сво!
бодных блоков целиком. Список адресов свободных блоков может зани!
мать несколько блоков хранения данных, но суперблок содержит только
один блок этого списка. Первый элемент этого блока указывает на блок,
хранящий продолжение списка и т. д., как это показано на рис.
свободных блоков для размещения файла производится с конца
списка суперблока. Когда в списке остается единственный элемент, ядро
интерпретирует его как указатель на блок, содержащий продолжение спи!
ска. В этом случае содержимое этого блока считывается в суперблок и блок
становится свободным. Такой подход позволяет использовать дисковое про!
странство под списки, пропорциональное свободному месту в файловой
системе. Другими словами, когда свободного места практически не остается,
список адресов свободных блоков целиком помещается в суперблоке.
Индексные дескрипторы
Индексный дескриптор, или inode, содержит информацию о файле, необ!
ходимую для обработки данных, т. е. метаданные файла. Каждый файл ас!
социирован с одним inode, хотя может иметь несколько имен в файловой
системе, каждое из которых указывает на один и тот же inode.
Индексный дескриптор не содержит:
имени файла, которое содержится в блоках хранения данных каталога;
содержимого файла, которое размещено в блоках хранения данных.
При открытии файла ядро помещает копию дискового inode в память в
таблицу in!core inode, которая содержит несколько дополнительных полей.
Структура дискового inode (struct dinode) приведена на рис. 4.2. Ос!
новные поля дискового inode следующие:
Тип файла, дополнительные атрибуты выполнения и права
доступа.
Число ссылок на файл, т. е. количество которые имеет
файл в файловой системе.
Идентификаторы владельца%пользователя и владельца%
группы.
www.books-shop.com
файловая система V 283
di_size
di_mtime
di_ctime
di addr[13]
Размер файла в байтах. Для специальных файлов это поле
содержит старший и младший номера устройства.
Время последнего доступа к файлу.
Время последней модификации.
Время последней модификации inode (кроме модификации
полей di_atime, di_mtime).
Массив адресов дисковых блоков хранения данных.
Рис. 4.2. Структура дискового inode
Поле хранит несколько атрибутов файла: тип файла (IFREG для
обычных файлов, каталогов, IFBLK или IFCHR для специальных
файлов блочных и символьных устройств соответственно); права доступа к
файлу для трех классов пользователей и дополнительные атрибуты выпол!
нения SGID и sticky bit), значения этих атрибутов были подробно
рассмотрены в главе 1.
www.books-shop.com
284 Глава 4.
Заметим, что в индексном дескрипторе отсутствует информация о времени
создания файла. Вместо этого inode хранит три значения времени: время
последнего доступа время последней модификации содержи!
мого файла и время последней модификации метаданных
файла В последнем случае не учитываются модификации по!
лей di_atime и di_mtime. Таким образом, di_ctime изменяется, когда
изменяется размер файла, владелец, группа, или число связей.
Индексный дескриптор содержит информацию о расположении данных
файла. Поскольку дисковые блоки хранения данных файла в общем случае
располагаются не последовательно, inode должен хранить физические ад!
реса всех блоков, принадлежащих данному В индексном дескрип!
торе эта информация хранится в виде массива, каждый элемент которого
содержит физический адрес дискового блока, а индексом массива является
номер логического блока файла. Массив имеет фиксированный размер и
состоит из 13 элементов. При этом первые 10 элементов адресуют непо!
средственно блоки хранения данных файла. Одиннадцатый элемент адре!
сует блок, в свою очередь содержащий адреса блоков хранения данных.
Двенадцатый элемент указывает на дисковый блок, также хранящий адре!
са блоков, каждый из который адресует блок хранения данных файла.
И, наконец, тринадцатый элемент используется для тройной косвенной
адресации, когда для нахождения адреса блока хранения данных файла
используются три дополнительных блока.
Такой подход позволяет при относительно небольшом фиксированном
размере индексного дескриптора поддерживать работу с файлами, размер
которых может изменяться от нескольких байтов до десятка мегабайтов.
Для относительно небольших файлов (до 10 Кбайт при размере блока 1024
байтов) используется прямая индексация, обеспечивающая максимальную
производительность. Для файлов, размер которых не превышает 266 Кбайт
(10 Кбайт + 256x1024), достаточно простой косвенной адресации. Нако!
нец, при использовании тройной косвенной адресации можно обеспечить
доступ к 16777216 блокам (256x256x256).
Файлы в UNIX могут содержать так называемые дыры. Например, процесс
может создать пустой файл, с помощью системного вызова lseek(2) сме!
Размещение данных файла в произвольно расположенных дисковых блоках позволяет
эффективно использовать дисковое пространство, поскольку ядро может использовать
любой свободный дисковый блок для размещения данных. Однако в файловой системе
s5fs блок может использоваться только одним файлом, поэтому последний блок файла ис!
пользуется, как правило, не полностью. тому же такой подход с течением времени при!
водит к увеличению фрагментации системы, когда данные файла оказываются произволь!
но разбросанными по диску, что, в свою очередь, увеличивает время доступа к файлу и
уменьшает производительность обмена данными. Единственным способом уменьшения
фрагментации файловой системы является создание полной резервной копии на другом
носителе (или в другой файловой и При этом запись
файлов будет производиться последовательно без фрагментации.
www.books-shop.com
Базовая система System V 285
стить файловый указатель относительно начала файла и записать данные.
При этом между началом файла и началом записанных данных образуется
дыра — незаполненная область. При чтении этой области процесс получит
обнуленные байты. Поскольку логические блоки, соответствующие дыре,
не содержат данные, не имеет смысла размещать для них дисковые блоки.
В этом случае соответствующие элементы массива адресов inode содержат
нулевой указатель. Когда процесс производит чтение такого блока, ядро
возвращает последовательность нулей. Дисковые блоки размещаются толь!
ко при записи в соответствующие логические блоки
Имена файлов
Как мы уже видели, ни метаданные, ни тем более блоки хранения данных,
не содержат имени файла. Имя файла хранится в файлах специального
типа — каталогах. Такой подход позволяет любому файлу, т. е. фактиче!
ским данным, иметь теоретически неограниченное число имен (названий),
в файловой системе. При этом несколько имен файлов будут соответство!
вать одним и тем же метаданным и данным и являться жесткими связями.
Каталог файловой системы s5fs представляет собой таблицу, каждый эле!
мент которой имеет фиксированный размер в 16 байтов: 2 байта хранят
номер индексного дескриптора файла, а 14 байтов — его имя. Это накла!
дывает ограничение на число inode, которое не может превышать 65 535.
Также ограничена и длина имени файла: его максимальный размер — 14
символов. Структура каталога приведена на рис. 4.3.
Первые два элемента каталога адресуют сам каталог (текущий каталог) под
именем и родительский каталог под именем
При удалении имени файла из каталога (например, с помощью команды
номер inode соответствующего элемента устанавливается равным 0.
Ядро обычно не удаляет такие свободные элементы, поэтому размер ката!
лога не уменьшается даже при удалении файлов. Это является потенци!
альной проблемой для каталогов, в которые временно было помещено
большое количество файлов. После удаления большинства из них размер
каталога останется достаточно большим, поскольку записи удаленных
файлов будут по!прежнему существовать.
Отсутствие размещенных дисковых блоков для части файла может привести к
ным результатам. Например, операция записи в "дыру" может закончиться неудачей из!за
нехватки дискового пространства. При копировании файла с дырой, копия будет за!
нимать больше фактического места на диске, чем оригинал. Это связано с тем, что при
копировании производится чтение содержимого оригинала, а затем — запись в другой
файл. Это, в частности может привести к тому, что резервная копия файловой системы не
сможет быть обратно распакована, поскольку неразмещенных блоков хра!
нить законные нулевые байты соответственно, занимать больше места.
www.books-shop.com
286 Глава 4. Файловая подсистема
Иллюстрацию этого явления в SCO UNIX можно привести, применив ко!
манду обеспечивающую вывод неинтерпретированного содержи!
мого файла дамп).
Можно заметить, что имен файлов, расположенных во второй части вывода
команды на самом деле не существует — об этом свидетельствуют
нулевые значения номеров это же подтверждает вывод команды
$ а
bin
News
mail
Массив индексных дескрипторов
Рис. 4.3. Каталог файловой системы s5fs
www.books-shop.com
Базовая система System V 287
Недостатки и ограничения
Файловая систем s5fs привлекательна благодаря своей простоте. Однако
обратной стороной медали является низкая надежность и производитель!
ность.
С точки зрения надежности слабым местом этой файловой системы явля!
ется суперблок. Суперблок несет основную информацию о файловой сис!
теме в целом, и при его повреждении файловая система не может исполь!
зоваться. Поскольку в файловой системе s5fs суперблок хранится в единст!
венном варианте, вероятность возникновения ошибок достаточно велика.
Относительно низкая производительность связана с размещением компо!
нентов файловой системы на диске. Метаданные файлов располагаются в
начале файловой системы, а далее следуют блоки хранения данных. При
работе с файлом, происходит обращение как к его метаданным, так и к
дисковым блокам, содержащим его данные. Поскольку эти структуры дан!
ных могут быть значительно разнесены в дисковом пространстве, необхо!
димость постоянного перемещения головки диска увеличивает время дос!
тупа и, как следствие, уменьшает производительность файловой системы в
целом. К этому же эффекту приводит фрагментация файловой системы,
поскольку отдельные блоки файла оказываются разбросанными по всему
разделу диска.
Использование дискового пространства также не оптимально. Для увели!
чения производительности файловой системы более предпочтительным
является использование блоков больших размеров. Это позволяет считы!
вать большее количество данных за одну операцию ввода/вывода. Так, на!
пример, в UNIX SVR2 размер блока составлял 512 байтов, а в SVR3 — уже
1024 байтов. Однако поскольку блок может использоваться только одним
файлом, увеличение размера блока приводит к увеличению неиспользуе!
мого дискового пространства за счет частичного заполнения последнего
блока файла. В среднем для каждого файла теряется половина блока.
Массив имеет фиксированный размер, задаваемый при создании
файловой системы. Этот размер накладывает ограничение на максималь!
ное число файлов, которые могут существовать в файловой системе. Рас!
положение границы между метаданными файлов и их данными (блоками
хранения данных) может оказаться неоптимальным, приводящим либо к
нехватке inode, если файловая система хранит файлы небольшого размера,
либо к нехватке дисковых блоков для хранения файлов большого размера.
Поскольку динамически изменить эту границу невозможно, всегда оста!
нется неиспользованное дисковое пространство либо в массиве inode, либо
в блоках хранения данных.
Наконец, ограничения, накладываемые на длину имени файла (14 симво!
лов) и общее максимальное число inode также являются слишком
жесткими.
www.books-shop.com
288 Глава 4.
Все эти недостатки привели к разработке новой архитектуры файловой
системы, которая появилась в версии 4.2BSD UNIX под названием
Berkeley Fast File System, или FSS.
Файловая система BSD UNIX
В версии 4.3BSD UNIX были внесены существенные улучшения в архи!
тектуру файловой системы, повышающие как ее производительность, так
и надежность. Новая файловая система получила название Berkeley Fast
File System (FFS).
Файловая система FFS, обладая полной функциональностью системы s5fs,
использует те же структуры данных ядра. Основные изменения затронули
расположение файловой системы на диске, дисковые структуры данных и
алгоритмы размещения свободных блоков.
Как и в случае файловой системы s5fs, суперблок содержит общее описа!
ние файловой системы и располагается в начале раздела. Однако в супер!
блоке не хранятся данные о свободном пространстве файловой системы,
такие как массив свободных блоков и Поэтому данные суперблока
остаются неизменными на протяжении всего времени существования фай!
ловой системы. Поскольку данные суперблока жизненно важны для рабо!
ты всей файловой системы, он дублируется для повышения надежности.
Организация файловой системы предусматривает логическое деление дис!
кового раздела на одну или несколько групп цилиндров (cylinder group).
Группа цилиндров представляет собой несколько последовательных диско!
вых цилиндров. Каждая группа цилиндров содержит управляющую ин!
формацию, включающую резервную копию суперблока, массив inode, дан!
ные о свободных блоках и итоговую информацию об использовании дис!
ковых блоков в группе (рис. 4.4).
Рис. 4.4. Структура файловой системы FFS
www.books-shop.com
Файловая система BSD UNIX 289
Для каждой группы цилиндров при создании файловой системы выделяет!
ся место под определенное количество При этом обычно на каждые
2 Кбайт блоков хранения данных создается один inode. Поскольку разме!
ры группы цилиндров и массива inode фиксированы, в файловой системе
BSD UNIX присутствуют ограничения, аналогичные s5fs.
Идея такой структуры файловой системы заключается в создании класте!
ров inode, распределенных по всему разделу, вместо того, чтобы группиро!
вать все inode в начале. Тем самым уменьшается время доступа к данным
конкретного файла, поскольку блоки данных располагаются ближе к адре!
сующем их inode. Такой подход также повышает надежность файловой
системы, уменьшая вероятность потери всех индексных дескрипторов в
результате сбоя.
Управляющая информация располагается с различным смещением от на!
чала группы цилиндров. В противном случае, например, при размещении
в начале группы цилиндров, информация всех групп оказалась бы физиче!
ски расположенной на одной пластине диска и могла бы быть уничтожена
при выходе из строя этой пластины. Это смещение выбирается равным
одному сектору относительно предыдущей группы, таким образом для со!
седних групп управляющая информация начинается на различных пласти!
нах диска. В этом случае потеря одного сектора, цилиндра или пластины
не приведет к потере всех копий суперблоков.
Производительность файловой системы существенным образом зависит от
размера блока хранения данных. Чем больше размер блока, тем большее
количество данных может быть прочитано без поиска и перемещения дис!
ковой головки. Файловая система FFS поддерживает размер блока до 64
Кбайт. Проблема заключается в том, что типичная файловая система
UNIX состоит из значительного числа файлов небольшого размера. Это
приводит к тому, что частично занятые блоки используются неэффектив!
но, что может привести к потере до 60% полезной емкости диска.
Этот недостаток был преодолен с помощью возможности фрагментации
блока. Каждый блок может быть разбит на два, четыре или восемь фраг!
ментов. В то время как блок является единицей передачи данных в опера!
циях ввода/вывода, фрагмент определяет адресуемую единицу хранения
данных на диске. Таким образом был найден компромисс между произво!
дительностью ввода/вывода и эффективностью хранения данных. Размер
фрагмента задается при создании файловой системы, его максимальное
значение определяется размером блока (0,5 размера блока), а минималь!
ный — физическими ограничениями дискового устройства, а именно: ми!
нимальной единицей адресации диска — сектором.
Информация о свободном пространстве в группе хранится не в виде спи!
ска свободных блоков, а в виде битовой карты блоков. Карта блоков, свя!
занная с определенной группой цилиндров, описывает свободное про!
странство в фрагментах, для определения того, свободен данный блок или
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
290 Глава 4. Файловая
нет, ядро анализирует биты фрагментов, составляющих блок. На рис. 4.5
приведен пример карты свободных блоков и соответствия между битами
карты, фрагментами и блоками группы цилиндров.
Рис. 4.5. Карта свободных блоков
Существенные изменения затронули алгоритмы размещения свободных
блоков и влияющие на расположение файлов на диске. В файловой
системе s5fs используются весьма примитивные правила размещения. Сво!
бодные блоки и inode просто выбираются из конца соответствующего спи!
ска, что со временем приводит, как уже обсуждалось, к значительному
разбросу данных файла по разделу диска.
В отличие от s5fs, файловая система FFS при размещении блоков исполь!
зует стратегию, направленную на увеличение производительности. Неко!
торые из принципов приведены ниже:
Файл по возможности размещается в блоках хранения данных, при!
надлежащих одной группе цилиндров, где расположены его мета!
данные. Поскольку многие операции файловой системы включают
работу, связанную как с метаданными, так и с данными файла, это
правило уменьшает время совершения таких операций.
Все файлы каталога по возможности размещаются в одной группе
цилиндров. Поскольку многие команды работают с несколькими
www.books-shop.com
Файловая система BSD UNIX
файлами одного и того же каталога, данный подход увеличивает ско!
рость последовательного доступа к этим файлам.
Каждый новый каталог по возможности помещается в группу
линдров, от группы родительского каталога. Таким обра!
зом достигается равномерное распределение данных по диску.
Последовательные блоки размещаются исходя из оптимизации фи!
зического доступа. Дело в том, что существует определенный проме!
жуток времени между моментом завершения чтения блока и началом
чтения следующего. За это время диск успеет совершить оборот на
некоторый угол. Таким образом, следующий блок должен по воз!
можности располагаться с пропуском нескольких секторов. В этом
случае при чтении последовательных блоков не потребуется совер!
шать "холостые" обороты диска.
Таким образом, правила размещения свободных блоков, с одной стороны,
направлены на уменьшение времени перемещения головки диска, т. е. на
локализацию данных в одной цилиндров, а с другой — на
мерное распределение данных по диску. От разумного баланса между эти!
ми двумя механизмами зависит, в конечном итоге, производительность
файловой системы. Например в предельном варианте, когда все данные
локализованы в одной большой группе цилиндров, мы получаем типичную
файловую систему s5fs.
Описанная архитектура является весьма эффективной с точки зрения на!
дежности и производительности. К сожалению, эти параметры файловой
системы FSS начинают значительно ухудшаться по мере уменьшения
бодного места. В этом случае системе не удается следовать вышеприведен!
ным правилам и размещение блоков далеко от оптимального. Практика
показывает, что FSS имеет удовлетворительные характеристики при нали!
чии более 10% свободного места.
Каталоги
Структура каталога файловой системы FFS была изменена для поддержки
длинных имен файлов (до 255 символов). Вместо записей фиксированной
длины запись каталога FFS представлена структурой, имеющей следующие
поля:
Номер inode (индекс в массив
Длина записи
Длина имени файла
[ ] Имя файла
Имя файла имеет переменную длину, дополненную нулями до
границы. При удалении имени файла принадлежавшая ему запись присое!
диняется к предыдущей, и значение поля d reclen увеличивается на со!
www.books-shop.com
292 Глава 4.
ответствующую величину. Удаление первой записи выражается в присвое!
нии нулевого значения полю d_ino. Структура каталога файловой систе!
мы FFS приведена на рис. 4.6.
Рис. 4.6. Каталог файловой системы FFS
Архитектура виртуальной файловой системы
Как было показано, различные типы файловых систем существенно отли!
чаются по внутренней архитектуре. В то же время современные версии
UNIX обеспечивают одновременную работу с несколькими типами файло!
вых систем. Среди них можно выделить локальные файловые системы
различной архитектуры, удаленные и даже отличные от файловой системы
UNIX, например DOS. Такое сосуществование обеспечивается путем раз!
деления каждой файловой системы на зависимый и независимый от
www.books-shop.com
Архитектура виртуальной файловой системы 293
зации уровни, последний из которых является общим и представляет для
остальных подсистем ядра некоторую абстрактную файловую систему. Не!
зависимый уровень также называется виртуальной файловой системой
(рис. 4.7). При этом дополнительные файловые системы различных типов
могут быть встроены в ядро UNIX подобно тому, как это происходит с
драйверами устройств.
Дисковые носители Монитор Принтер
4.7. Архитектура виртуальной файловой системы
Сеть
Виртуальные индексные дескрипторы
Дисковый файл обычно имеет связанную с структуру данных, назы!
ваемую метаданными или inode, где хранятся основные характеристики
данного файла и с помощью которой обеспечивается доступ к его данным.
Одним из исключений из этого правила является файловая система DOS,
в которой структуры файла и его метаданных существенно отличаются от
принятых в Тем не менее виртуальная файловая система основана
на представлении метаданных файла в виде, сходном с традиционной се!
мантикой UNIX. Интерфейсом работы с файлами является (от
virtual inode — виртуальный индексный дескриптор).
www.books-shop.com
294 Глава 4. Файловая
Первоначально этот интерфейс был разработан в 1984 году фирмой
Sun Microsystems для обеспечения требуемой унификации работы с файло!
выми системами различных типов, в частности, с NFS и (FFS). Сего!
дня виртуальная файловая система является стандартом в SVR4, хотя ряд
других версий UNIX также реализуют подобную архитектуру (например,
независимая файловая система SCO UNIX).
Метаданные всех активных файлов (файлов, на которые ссылаются один
или более процессов) представлены в памяти в виде in!core inode, в каче!
стве которых в виртуальной файловой системе выступают Структура
данных vnode одинакова для всех файлов, независимо от типа реальной
файловой системы, где фактически располагается файл. Данные vnode со!
держат информацию, необходимую для работы виртуальной файловой сис!
темы, а также неизменные характеристики файла, например, такие как
тип файла.
Основные поля vnode приведены в табл.
Таблица 4.1. Поля vnode
Поле Описание
u short lag Флаги vnode
u short v count Число ссылок на vnode
struct filock filocks Блокировки файла
struct vfs Указатель на подключенную файловую
систему, если vnode является точкой
монтирования
struct vfs *v_vfsp Указатель на файловую систему, в кото%
рой находится файл
enum vtype v_type Тип vnode: обычный файл, каталог, спе%
циальный файл устройства, символиче%
ская связь, сокет
caddr t v data Указатель на данные, относящиеся к ре%
альной файловой системе
struct op Операции vnode
Каждый vnode содержит число ссылок v_count, которое увеличивается
при открытии процессом файла и уменьшается при его закрытии. Когда
число ссылок становится равным нулю, вызывается операция
которая сообщает реальной файловой системе, что на
vnode никто больше не ссылается. После этого файловая система может
освободить vnode (и, например, соответствующий ему inode) или помес!
тить его в кэш для дальнейшего использования.
Поле указывает на файловую систему (структуру vfs, о которой
мы поговорим в следующем разделе), в которой расположен файл,
www.books-shop.com
виртуальной файловой системы 295
ванный данным Если является точкой монтирования, то поле
указывает на подключенную файловую систему,
"перекрывающую" данный vnode.
Поле v_data указывает на данные, относящиеся к конкретной
реальной файловой системы. Например, для дисковой файловой системы
указывает на запись в таблице in!core inode.
Набор операций над vnode указан полем v_op. В терминах объектно!
ориентированного программирования этот набор представляет собой вир!
туальные методы класса vnode. Он является своего рода шлюзом к реаль!
ной файловой системе, позволяя предоставить общий интерфейс вирту!
альной файловой системы и в то же время обеспечить специфические реа!
лизации функций работы с файлами, необходимые для различных типов
файловых систем. Некоторые операции, большинство из которых уже зна!
комы читателю по системным вызовам, приведены в табл. 4.2.
Таблица 4.2. Операции с vnode виртуальной файловой системы
() Открыть vnode. Если операция предусматривает соз%
дание клона (размножение), то в результате будет
размещен новый vnode. Обычно операции такого
типа характерны для специальных файлов устройств.
close) Закрыть vnode.
( read) ( ) Чтение данных файла, адресованного vnode.
Запись в файл, адресованный vnode.
int Задание управляющей команды.
int Получить атрибуты vnode: тип права доступа,
владелец%пользователь, владелец%группа, идентифи%
катор файловой системы, номер связей,
размер файла, оптимальный размер блока для опе%
раций время последнего доступа,
время последней модификации, время последней
модификации vnode, число занимаемых блоков.
int Установить атрибуты vnode. Могут быть изменены
GID, размер файла и времена доступа и моди%
фикации.
Проверить права доступа к файлу, адресованному
vnode. При этом производится отображение между
атрибутами доступа файлов UNIX и атрибутами ре%
альной файловой системы (например, DOS).
Произвести трансляцию имени файла в соответст%
вующий ему vnode.
Создать новый файл и соответствующий ему vnode.
Удалить файла в указанном vnode каталоге.
www.books-shop.com
296 Глава 4. Файловая
Таблица 4.2 (продолжение)
int
int
int
int
int
int
int
int
_link) ()
readlink)
()
inactive)
Создать жесткую связь между именем файла и vnode.
Создать новый каталог в указанном vnode каталоге.
Удалить каталог.
Считать записи каталога, адресованного vnode.
Создать символическую связь между новым именем
и именем файла, расположенном в указанном vnode
каталоге.
Чтение файла — символической связи.
Синхронизировать содержимое файла — записать
все данные.
Разрешить удаление vnode, т. к. число ссылок на vnode
из виртуальной файловой системы стало равным нулю.
Взаимосвязь между независимыми дескрипторами (vnode) и зависимыми
от реализации метаданными файла показана на рис. 4.8.
Рис. 4.8. Метаданные файла виртуальной файловой системы
Монтирование файловой системы
Прежде чем может состояться работа с файлами, соответствующая файло!
вая система должна быть встроена в существующее иерархическое дерево.
www.books-shop.com
Архитектура виртуальной файловой системы 297
Только после этого ядро сможет выполнять файловые операции, такие как
создание, открытие, чтение или запись в файл. Эта операция встраивания
получила название подключения или монтирования файловой системы.
Каждая подключенная файловая система представлена на независимом
уровне в виде структуры vf s , аналоге записи таблицы монтирования дис!
ковой файловой системы. Структуры v f s всех подключенных файловых
систем организованы в виде односвязного списка, в совокупности обеспе!
чивая информацию, необходимую для обслуживания всего иерархического
дерева, а также информацию о реальной файловой системе, которые не
изменяются на протяжении работы. Первой записью списка всегда являет!
ся корневая файловая система. В дальнейшем, список мы будем назы!
вать устоявшимся термином — таблица монтирования. Поля структуры
приведены в табл. 4.3.
Таблица 4.3. Поля структуры vfs
struct vfs next Следующая файловая система в списке
монтирования.
struct vfsops Операции файловой системы.
struct vnodecovered vnode, перекрываемый файловой сис%
темой.
int Флаги: только для чтения, запрещен бит
SUID т. д.
int vfs bsize Размер блока файловой системы.
t vfs data Указатель на специфические данные,
относящиеся к реальной файловой сис%
теме.
Поле содержит указатель на данные реальной файловой систе!
мы. Например, для дисковой файловой системы s5fs, это поле указывает
на суперблок, размещенный в памяти.
Поле vfs_op указывает на операции файловой системы, которые в терми!
нах объектно!ориентированного подхода могут быть названы виртуальными
методами объекта vf s . Возможные операции файловой системы приведены
в табл. 4.4. Поскольку они существенным образом зависят от архитектуры и
конкретной реализации, поля заполняются указателями на соответ!
ствующие функции реальной файловой системы при ее монтировании.
Таблица 4.4. Операции файловой системы
mount) Подключает файловую систему. Обычно операция
включает размещение суперблока в памяти и ини%
циализацию записи в таблице монтирования.
int Отключает файловую систему. Операция включает
актуализацию данных файловой системы на нако%
пителе (например, синхронизацию дискового су%
перблока и его образа в памяти).
www.books-shop.com
298 Глава 4. Файловая
Таблица 4.4 (продолжение)
int
int
int
int
(*vfs
(*vfs
()
Возвращает корневой vnode файловой системы.
Возвращает общую информацию о файловой систе%
ме, в частности: размер блока хранения данных, чис%
ло свободных inode.
Актуализирует все данные файловой
системы.
Возвращает файловый идентификатор (fid — file Iden%
tifier), однозначно адресующий файл в данной фай%
ловой системе. В качестве fid может, например, вы%
ступать номер inode реальной файловой системы.
Возвращает указатель на vnode для файла данной
файловой системы, адресованного fid.
Для инициализации и монтирования реальной файловой системы UNIX
хранит коммутатор файловых систем (File System Switch), адресующий
процедурный интерфейс для каждого типа файловой системы, поддержи!
ваемой ядром. UNIX System V этого использует глобальную таблицу,
каждый элемент которой соответствует определенному типу реальной
файловой системы, например s5fs, или nfs. Элемент этой таблицы
vf ssw имеет поля, указанные в табл. 4.5.
Таблица 4.5. Коммутатор файловых систем
char
int
struct vfsops
long
name
init) ()
*vsw vfsops
vsw flag
Имя типа файловой системы
Адрес процедуры инициализации
Указатель на вектор операций файловой
Флаги
системы
Взаимодействие структур виртуальной файловой системы показано на
рис. 4.9.
Монтирование файловой системы производится системным вызовом
В качестве аргументов передаются тип монтируемой файловой
системы, имя каталога, к которому подключается файловая система (точка
монтирования), флаги (например, доступ к файловой системе только для
чтения) и дополнительные данные, конкретный вид и содержимое кото!
рых зависят от реализации реальной файловой системы. При этом произ!
водится поиск vnode, соответствующего файлу — точке монтирования
(операция () или () трансляции имени), и проверяется, что
файл является каталогом и не используется в настоящее время для монти!
рования других файловых систем.
Затем происходит поиск элемента коммутатора файловых систем
соответствующего типу монтируемой файловой системы. Если такой эле!
www.books-shop.com
Архитектура файловой системы 299
мент найден, вызывается операция инициализации, адресованная полем
. При этом выполняется размещение специфических для дан!
ного типа файловой системы данных, после чего ядро размещает структуру
v f s и помещает ее в связанный список подключенных файловых систем,
как это показано на рис. 4.11. Поле указывает на
точки монтирования. Это поле устанавливается нулевым для корне!
вой (root) файловой системы, элемент v f s которой всегда расположен
первым в списке подключенных файловых систем. Поле адресует
вектор операций, определенный для данного типа файловой системы. На!
конец, указатель на данный элемент vf s сохраняется в поле
виртуального индексного дескриптора каталога —
ки монтирования.
Рис. 4.9. Структуры данных виртуальной файловой системы
После этого вызывается операция соответствующая данно!
му типу файловой системы. Конкретные действия определяются реализа!
цией файловой системы и могут существенно различаться. Например,
операция монтирования локальной файловой системы предусматривает
считывание в память метаданных системы, таких как суперблок, в то вре!
мя как монтирование удаленной NFS файловой системы включает переда!
чу сетевого запроса файловому серверу. Однако монтирование предусмат!
ривает выполнение и ряда общих операций, включающих:
проверку соответствующих прав на выполнение монтирования;
размещение и инициализацию специфических для файловой систе!
мы данного типа данных, сохранение адреса этих данных в поле
data элемента v f s ;
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
300 Глава 4.
размещение для корневого каталога подключаемой файловой
системы, доступ к которому осуществляется с помощью операции
.
После подключения файловая система может быть адресована по имени
точки монтирования. В частности, при отключении файловой системы с
помощью системного вызова в качестве аргумента ему передает!
ся имя точки монтирования. Адресация с помощью специального файла
устройства, как это происходило раньше, нарушает унифицированный вид
виртуальной файловой системы, так как некоторые типы вообще не имеют
такого устройства (например, NFS).
Определение корневого vnode для подключенной файловой системы про!
изводится с помощью операции Заметим, что в некоторых
реализациях независимой файловой системы (например, в SCO UNIX, хо!
тя там используется другая терминология) одно из полей записи таблицы
монтирования явно указывало на корневой vnode. Подход, предложенный
фирмой Sun Microsystems, позволяет не хранить корневой vnode постоян!
но, размещая его только при необходимости работы с файловой системой.
Это минимизирует ресурсы, занимаемые подключенными файловыми сис!
темами, которые продолжительное время не используются.
На рис. 4.10 приведен вид логического файлового дерева до и после
монтирования файловой системы А к каталогу На рис.
приведен вид виртуальной файловой системы после этой операции мон!
тирования.
Исследовать описанные структуры данных можно с помощью утилиты
Для этого применяются команды vfs и отображающие со!
держимое соответствующих структур данных. Приведем пример такого ис!
следования файлового дерева операционной системы Solaris 2.5:
crash
= = = stdout
>
/ on /dev/dsk/cOt3dOsO read/write on Tue Feb 25 15:29:11 1997
/usr/local on /dev/dsk/cOtOdOsO read/write on Tue 25 1997
/tmp on swap read/write on Tue Feb 25 1997
/dev/fd on fd read/write/setuid on Tue Feb 25 1997
/proc on /proc read/write/setuid on Tue Feb 25 15:29:11 1997
on /dev/dsk/cOt6dO on Mar 25 15:29:43 1997
>
FSTYP BSZ PDATA FLAGS
ufs 8192 800018 0 f5b79b78 0 notr
ufs 8192 32,0 800000 f5c29adO f5c28c88 0 notr
4096 0,0 0 0 notr
fd 1024 158,0 2780000 f5c4f5d8 О О
proc 1024 156,0 2700000 0 283920
hsfs 2048 f5f20698 f5b60d98 0 rd
www.books-shop.com
Архитектура виртуальной файловой системы 301
Рис. 4.10. Монтирование файловой системы А к корневой файловой системе
www.books-shop.com
302 Глава 4. Файловая
Рис. Схема монтирования файловых систем различных типов
Мы распечатали список подключенных файловых систем (команда
и элементы vfs таблицы монтирования. Рассмотрим подробнее
vnode точки монтирования файловой системы раздела
> vnode f5c29adO
VFSMNTED VFSP VTYPE RDEV VDATA VFILOCKS
2 f5c25c60 f0286570 0 d  f5c29ac8 0
Удостоверимся, что поле (VFSMNTED) адресует элемент
vf s подключенной файловой системы, а поле v_fsp (VFSP) указывает на
элемент корневой файловой системы.
> vfs f5c25c60
FSTYP BSZ PDATA FLAGS
8192 32,0
> vfs f0286570
FSTYP BSZ MAJ/MIN
ufs 8192 32,24
800000 f5c29adO 0
FSID VNCOVERED PDATA BCOUNT FLAGS
800018 0 f5b79b78 0 notr
Наконец, посмотрим на содержимое inode файловой системы ufs, адресо!
ванного полем (VDATA) виртуального индексного дескриптора:
> ui f5c29ac8
UFS INODE TABLE SIZE = 1671
SLOT MAJ/MIN LINK SIZE MODE FLAGS
32,24 7552 2 2 0 0 512 rf
www.books-shop.com
Архитектура виртуальной файловой системы 303
Полученная информация показывает, что запись таблицы ufs адресу!
ет дисковый индексный дескриптор с номером 7552 Для того
чтобы узнать имя файла, используем команду
> i 7552
7552
Трансляция имен
Прикладные процессы, запрашивая услуги файловой системы, обычно
имеют дело с именем файла или файловым дескриптором, полученным в
результате определенных системных вызовов. Однако ядро системы для
обеспечения работы с файлами использует не имена, а индексные деск!
рипторы. Таким образом, необходима трансляция имени файла, переда!
ваемого, например, в качестве аргумента системному вызову в но!
мер соответствующего
В табл. 4.6 приведены системные вызовы, для выполнения которых требу!
ется трансляция имени файла.
Таблица 4.6. Системные вызовы, требующие трансляции имени
ехес(2) Запустить программу на выполнение
Изменить владельца%пользователя
chgrp(2) Изменить владельца%группу
Изменить права доступа
Получить метаданные файла
Удалить каталог
mkdir(2) Создать каталог
mknod(2) Создать специальный файл устройства
Открыть файл
link(2) Создать жесткую связь
Говоря формально, полное имя файла представляет собой последователь!
ность слов, разделенных символом '/'. Каждый компонент имени, кроме
последнего, является именем каталога. Последний компонент определяет
собственно имя файла. При этом полное имя может быть абсолютным или
относительным. Если полное имя начинается с символа '/', представляю!
щего корневой каталог общего логического дерева файловой системы, то
оно является абсолютным, однозначно определяющим файл из любого
места файловой системы. В противном случае, имя является относитель!
ным и адресует файл относительно текущего каталога. Примером относи!
тельного имени может служить а абсолютное имя этого
файла — Как следует из этих рассуждений, два ка!
www.books-shop.com
304 Глава 4. Файловая
играют ключевую роль при трансляции имени: корневой каталог и
текущий каталог. Каждый процесс адресует эти каталоги двумя полями
структуры u_area:
struct Указатель текущего каталога
struct vnode Указатель на vnode корневого каталога
В зависимости от имени файла трансляция начинается с vnode, адресован!
ного либо полем либо u_rdir. Трансляция имени осуществляется
покомпонентно, при этом для vnode текущего каталога вызывается соот!
ветствующая ему операция vn_lookup в качестве аргумента которой
передается имя следующего компонента. В результате операции возвраща!
ется vnode, соответствующий искомому компоненту.
Если для vnode каталога установлен указатель
то данный каталог является точкой монтирования. Если имя файла
требует дальнейшего спуска по дереву файловой системы (т. е. пересече!
ния точки монтирования), то операция следует указателю
для перехода в подключенную файловую систему и
вызывает для нее операцию s_root для получения ее корневого
vnode. Трансляция имени затем продолжается с этого места.
Пересечение границы файловых систем возможно и при восхождении по
дереву, например, если имя файла задано указанием родительского ката!
лога — Если при движении в этом направлении по пути
встречается корневой vnode подключенной файловой системы (установлен
флаг VROOT в поле то операция vn_lookup следует указателю
vfs_vnodecovered, расположенному в записи vf s этой файловой систе!
мы. При этом происходит пересечение границы файловых систем, и даль!
нейшая трансляция продолжается с точки монтирования.
Если искомый файл является символической связью, и системный вызов,
от имени которого происходит трансляция имени, "следует" символиче!
ской связи, операция вызывает vn_readlink для получе!
ния имени целевого файла. Если оно является абсолютным (т. е. начина!
ется с то трансляция начинается с vnode корневого каталога, адресо!
ванного полем u_rdir области u!area.
Процесс трансляции имени продолжается, пока не просмотрены все ком!
поненты имени или не обнаружена ошибка (например, отсутствие прав
доступа). В случае удачного завершения возвращается vnode искомого
файла.
Доступ к файловой системе
Как было показано в главе 2, процесс совершает операции с файлами, адре!
суя их при помощи файловых дескрипторов — целых чисел, имеющих ло!
www.books-shop.com
к файловой системе 305
для процесса значение. Это значит, что файловый дескриптор од!
ного процесса может адресовать совершенно другой файл, нежели файловый
дескриптор с таким же номером, используемый другим процессом. Процесс
получает файловый дескриптор с помощью ряда системных вызовов, на!
пример, или выполняющих операцию трансляции имени, в
результате которой выделяемый файловый дескриптор адресует определен!
ный (или и, соответственно, файл файловой системы.
На рис. показаны основные структуры ядра, необходимые для доступа
процесса к файлу.
Рис. 4.12. Внутренние структуры доступа к файлу
Файловый дескриптор, используемый для доступа процесса к файлу, явля!
ется индексом таблицы файловых дескрипторов (file descriptor table). Каж!
дый процесс имеет собственную таблицу файловых дескрипторов, которая
расположена в его На рис. 4.12 показаны два процесса, каждый из
которых использует собственную таблицу файловых дескрипторов.
Каждая активная запись этой таблицы, представляющая открытый файл,
адресует запись системной файловой таблицы (system table), в которой
хранятся такие параметры, как режим доступа к файлу (запись, чтение,
добавление и т. д.), текущее смещение в файле (файловый указатель), а
также указатель па vnode этого файла. Системная файловая таблица одна и
совместно используется всеми процессами.
Как следует из рис. 4.12, несколько записей системной файловой таблицы
могут адресовать один и тот же файл, который представлен
записью в таблице vnode.
www.books-shop.com
306 Глава 4. Файловая
Файловые дескрипторы
Файловый дескриптор представляет собой неотрицательное целое число,
возвращаемое системными вызовами, такими как или
pipe(2). После получения файлового дескриптора процесс может использо!
вать его для дальнейшей работы с файлом, например с помощью систем!
ных вызовов или
Ядро обеспечивает работу процесса с файлами, используя различные
структуры данных, часть из которых расположена в процесса. На!
помним, что эта область описывается структурой user. В табл. 4.7 приве!
дены поля структуры user, которые используются ядром для обеспечения
доступа процесса к файлу.
Таблица 4.7. Поля структуры user, связанные с файловым дескриптором
Поле Описание
Указатель на системную файловую таблицу
Флаги файлового дескриптора
Файловый дескриптор связан с этими двумя полями и, таким образом,
обеспечивает доступ к соответствующему элементу файловой таблицы
(структуре данных
В настоящее время в качестве единственного флага файлового дескриптора
определен флаг Если этот флаг установлен, то производится
закрытие файлового дескриптора (аналогично явному вызову при
выполнении процессом системного вызова При этом для запу!
щенной программы не происходит наследования файлового дескриптора и
доступа к файлу.
Более старые версии UNIX используют статическую таблицу дескрипто!
ров, которая целиком хранится в u!area. Номер дескриптора является ин!
дексом этой таблицы. Таким образом, размер таблицы, которая обычно
содержит 64 элемента, накладывает ограничение на число одновременно
открытых процессом файлов. В современных версиях таблица размещается
динамически и может увеличиваться при необходимости. Следует, однако,
иметь в виду, что и в этом случае максимальное число одновременно от!
крытых файлов регламентируется пределом который рас!
сматривался в разделе "Ограничения" главы 2. В некоторых версиях, на!
пример, Solaris 2.5, данные файловых дескрипторов хранятся не в виде
таблицы, а в виде блоков структур uf_entry, поля которой аналогичны
приведенным в табл. 4.7.
Содержимое таблицы дескрипторов процесса можно посмотреть с помо!
щью утилиты Команда покажет содержимое u!area процсс!
www.books-shop.com
к файловой системе 307
са. Например, для текущего командного интерпретатора мы получим сле!
дующую информацию:
crash
= = stdout
> proc #8591
PROC TABLE SIZE = 1498
SLOT ST SID NAME FLAGS
121 s 8591 8589 8591 8591 286 48 bash load
> user 121
PER PROCESS USER AREA FOR PROCESS 121
PROCESS
command: bash, psargs: bash
start: PO 24 18:11:31 1997
mem: type: exec
of current directory: f5b95e40
OPEN FILES, POFILE FLAGS, AND THREAD REFCNT:
F Oxf62b6030, 0, 0 F Oxf62b6030, О, О
F Oxf62b6030, О, О
0022
RESOURCE LIMITS:
cpu time: unlimited/unlimited
file size: unlimited/unlimited
swap size: 2147479552/2147479552
stack size: 8388608/2147479552
size: unlimited/unlimited
file descriptors: 64/1024
address unlimited/unlimited
SIGNAL DISPOSITION:
Файловая таблица
Поля файлового дескриптора u_ofile и содержат начальную
информацию, необходимую для доступа процесса к данным файла. До!
полнительная информация находится в системной файловой таблице и
таблице индексных дескрипторов. Для обеспечения доступа процесса к
данным файла ядро должно полностью создать цепочку от файлового де!
скриптора до vnode и, соответственно, до блоков хранения данных, как
показано на рис. 4.12.
Каждый элемент файловой таблицы содержит информацию, необходимую
для управления работой с файлом. Если несколько процессов открывают
один и тот же файл, каждый из них получает собственный элемент файло!
вой таблицы, хотя все они будут работать с одним и тем же файлом. Важ!
поля элемента файловой таблицы приведены ниже:
www.books-shop.com
308 Глава 4. Файловая
Поле Описание
f_flag Флаги, при открытии файла (системные вызовы ореп(2),
Каждая операция с файлом проверяется на допустимость со%
гласно указанным режимам. Другими словами, если процесс открыл
файл только для чтения (флаг FREAD), ему будет отказано в операции
записи, даже если он имеет на это необходимые права доступа.
FREAD Файл открыт только для чтения. То же, что и O_RDONLY при открытии
файла.
Файл открыт только на запись. То же, что и при открытии
файла.
FAPPEND Режим добавления. Перед началом операции записи файловый ука%
затель будет установлен в конец файла. То же, что и O_APPEND при
открытии файла.
Возврат без блокирования. Системный вызов не будет ожидать за%
вершения операции. То же, что и или при от%
крытии файла.
FSYNC Обеспечить синхронизацию с соответствующими дисковыми структу%
рами для метаданных и данных файла при совершении операции за%
писи. То же, что и o_SYNC при открытии файла.
FNONBLOCK,
FDSYNC Обеспечить синхронизацию с соответствующими дисковыми структу%
рами только для данных файла при совершении операции записи. То
же, что и при открытии файла.
FRSYNC Совместно с флагами FCYNC и FDSYNC определяет процесс синхрони%
зации для соответствующих компонентов файла при операции чтения.
Число файловых дескрипторов, адресующих данный элемент файло%
вой таблицы. Один и тот же элемент файловой таблицы может совме%
стно использоваться при дублировании дескрипторов с помощью сис%
темного вызова или в результате
f Указатель на виртуальный индексный дескриптор файла.
f_of f set Текущее смещение в файле. Начиная с этого места будет произведе%
на следующая операция чтения или записи.
Для иллюстрации обсуждения продолжим работу с утилитой С
помощью команды user в предыдущем разделе были получены адреса эле!
ментов файловой таблицы для стандартного ввода (fd=0), вывода (fd=l) и
вывода сообщений об ошибках (fd=2). Заметим, что все они указывают на
один и тот же элемент. С помощью команды file исследуем его содержимое:
> file Oxf62b6030
ADDRESS RCNT TYPE/ADDR OFFSET FLAGS
f62b6030 9 SPEC/f5e91clc 15834 read write
> vnode f5e91clc
VCNT VFSP VTYPE RDEV VDATA VFILOCKS
2 0 f5c6b2aO с 24,26 0
www.books-shop.com
к файловой системе
Поскольку это специальный файл устройства (об этом свидетельствует по!
ле TYPE элемента файловой таблицы), поле (VDATA) указы!
вает не на файловой системы а на — индексный дескрип!
тор логической файловой системы specfs, обслуживающей специальные
файлы устройств. Более подробно этот интерфейс будет рассматриваться в
главе. Таким образом, для продолжения путешествия по струк!
турам ядра, следует обратиться к snode, адрес которого указан в
поле
> snode f5e91c18
SNODE TABLE SIZE = 256
HASHSLOT NEXTR SIZE COUNT FLAGS
f5f992e8 f636b27c О О О up ac
Поле (REALVP) указывает на vnode файла реальной файловой
системы (в данном случае ufs). Поэтому далее поиск аналогичен проде!
ланному при исследовании таблицы монтирования.
> vnode f5f992e8
VFSP VTYPE RDEV VDATA
2 0 f0286570 0 с 24,26 f5f992eO 0
>
UFS INODE TABLE SIZE =
SLOT MAJ/MIN LINK SIZE MODE FLAGS
32,24 317329 2 1 286 7 0 620 rf
> ! i 317329
317329
В результате мы определили имя специального файла устройства (в дан!
ном случае — это псевдотерминал), на которое производится ввод и вывод
командного интерпретатора.
Блокирование доступа к файлу
Традиционно архитектура файловой подсистемы UNIX разрешает
скольким процессам одновременный доступ к файлу для чтения и записи.
Хотя операции записи и чтения, осуществляемые с помощью системных
вызовов или являются атомарными, в UNIX по умолчанию
отсутствует синхронизация между отдельными вызовами. Другими слова!
ми, между двумя последовательными вызовами одного процесса
другой процесс может модифицировать данные файла. Это, в частности,
может привести к несогласованным операциям с файлом, и как следствие,
к нарушению целостности его данных. Такая ситуация является неприем!
лемой для многих приложений.
UNIX б б б й
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 4. Файловая
специально для управления блокированием. При этом перед фак!
тической файловой операцией (чтения или записи) процесс устанавливает
блокирование соответствующего типа (для чтения или для записи). Если
блокирование завершилось успешно, это означает, что требуемая файловая
операция не создаст конфликта или нарушения целостности данных, на!
пример, при одновременной записи в файл несколькими процессами.
По умолчанию блокирование является рекомендательным (advisory lock).
Это означает, что кооперативно работающие процессы могут руководство!
ваться созданными блокировками, однако ядро не запрещает чтение или
запись в заблокированный участок файла. При работе с рекомендательны!
ми блокировками процесс должен явно проверять их наличие с помощью
тех же функций и lockf(3C).
Мы уже встречались с использованием системного вызова для бло!
кирования записей файла в главе 2. Там же была упомянута структура
flock, служащая для описания блокирования. Поля этой структуры опи!
саны в табл. 4.8.
Таблица 4.8. Поля структуры flock
Поле
short Тип блокирования: F_RDLCK обозначает блокирование для
чтения (read lock), — блокирование для записи (write
lock), обозначает снятие блокирования.
short l_whence Точка отсчета смещения записи в файле. Может принимать
значения, аналогичные рассмотренным при разговоре о функ%
ции lseek(2) в главе 2: SEEK_CUR, SEEK_END.
of f_t l_start Смещение блокируемой записи относительно точки отсчета,
указанной полем l_whence.
of f_t l_len Длина блокируемой записи. Нулевое значение l_len указы%
вает, что запись всегда распространяется до конца файла,
независимо от возможного изменения его размера.
Идентификатор процесса, установившего блокирование, воз%
вращаемый при вызове команды GETLK.
Как следует из описания поля l_type структуры flock, существуют два
типа блокирования записи: для чтения RDLCK) и для записи
Правила блокирования таковы, что может быть установлено несколько
блокирований для чтения на конкретный байт файла, при этом в установ!
ке блокирования для записи на этот байт будет отказано. Напротив, бло!
кирование для записи на конкретный байт должно быть единственным,
при этом в установке блокирования для чтения будет отказано.
Приведем фрагмент программы, использующей возможность блокирова!
ния записей:
www.books-shop.com
Буферный кэш 3
struct flock lock;
описание lock с целью блокирования всего файла для
=
0;
SEEK_SET;
= 0;
файл. Если блокирования, препятствующие данной операции,
уже существуют — ждем их
fcntl(fd,
данные в файл — нам никто не
record,
=
SETLKW,
В отличие от рекомендательного в UNIX существует обязательное
вание (mandatory lock), при котором ограничение на доступ к записям
файла накладывается самим ядром. Реализация обязательных блокировок
может быть различной. Например, в SCO UNIX (SVR3) снятие бита х для
группы и установка бита для группы приводит к тому, что блоки!
ровки, установленные или lockf(3C), станут обязательными. UNIX
SVR4 поддерживает установку блокирования отдельно для записи и для
чтения, обеспечивая тем самым доступ для чтения многим, а для записи —
только одному процессу. Эти установки также осуществляются с помощью
системного вызова Следует иметь в виду, что использование обяза!
тельного блокирования таит потенциальную опасность. Например, если
процесс блокирует доступ к жизненно важному системному файлу и по
каким!либо причинам теряет контроль, это может привести к аварийному
останову операционной системы.
Буферный кэш
Во введении отмечалось, что работа файловой подсистемы тесно связана с
обменом данными с периферийными устройствами. Для обычных файлов
и каталогов — это устройство, на котором размещается соответствующая
файловая система, для специальных файлов устройств — это принтер,
терминал, или сетевой адаптер. Не вдаваясь в подробности подсистемы
ввода/вывода, рассмотрим, как во многих версиях UNIX организован об!
мен данными с дисковыми устройствами — традиционным местом хране!
ния подавляющего большинства
На самом файловые системы могут располагаться на удаленных компьютерах
(например, в случае NFS). Хотя при работе с такими файловыми системами
ввод/вывод тем не менее и в этом случае кэширование блоков данных значи!
тельно повышает производительность.
www.books-shop.com
312 Глава 4. Файловая
Не секрет, что операции дискового ввода/вывода являются медленными
по сравнению, например, с доступом к оперативной или сверхоперативной
памяти. Время чтения данных с диска и копирования тех же данных в па!
мяти может различаться в несколько тысяч раз. Поскольку основные дан!
ные хранятся на дисковых накопителях, дисковый ввод/вывод является
узким местом операционной системы. Для повышения производительно!
сти дискового ввода/вывода и, соответственно, всей системы в целом, в
UNIX используется кэширование дисковых блоков в памяти.
Для этого используется выделенная область оперативной памяти, где кэ!
дисковые блоки файлов, к которым наиболее часто осуществля!
ется доступ. Эта область памяти и связанный с ней процедурный интер!
фейс носят название буферного и через него проходит большинство
операций файлового ввода/вывода. Схема взаимодействия различных под!
систем ядра с буферным кэшем приведена на рис. 4.13.
Рис. 4.13. Роль буферного кэша
www.books-shop.com
Буферный кэш 313
Внутренняя структура буферного кэша
Буферный кэш состоит из буферов данных, размер которых достаточен
для размещения одного дискового блока. С каждым блоком данных связан
заголовок буфера, представленный структурой buf, с помощью которого
ядро производит управление кэшем, включая идентификацию и поиск бу!
феров, а также синхронизацию доступа. Заголовок также используется при
обмене данными с драйвером устройства для выполнения фактической
операции ввода/вывода. Когда возникает необходимость чтения или запи!
си буфера на диск, ядро заносит параметры операции ввода/вывода в заго!
ловок и передает его функции драйвера устройства. После завершения
операции ввода/вывода заголовок содержит информацию о ее результатах.
Основные поля структуры buf приведены в табл. 4.9.
Таблица 4.9. Поля структуры buf
Описание
b_f lags Флаги. Определяют состояние буфера в каждый момент вре%
мени (например, — буфер занят или — закон%
чена операция с буфером) и направление пере%
дачи B_PHYS)
av_f orw, Указатели двухсвязного рабочего списка буферов, ожидающих
обработки драйвером
Число байтов, которое требуется передать
b_addr Виртуальный адрес буфера
Номер блока начала данных на устройстве
Старший и младший номера устройства
Поле b_flags хранит различные флаги связанного с заголовком буфера.
Часть флагов используется буферным кэшем, а часть — драйвером устрой!
ства. Например, с помощью флага осуществляется синхронизация
доступа к буферу. Флаг отмечает буфер как модифицированный,
или "грязный", требующий сохранения на диске перед повторным исполь!
зованием. Флаги B_READ, B_WRITE, И B_ERROR ИСПОЛЬ!
зуются драйвером диска. Более подробно операция ввода/вывода для драй!
вера будет рассмотрена в следующей главе.
Буферный кэш использует механизм отложенной (write!behind), при
котором модификация буфера не вызывает немедленной записи на диск.
Такие буферы отмечаются как "грязные", а синхронизация их содержимого
с дисковыми данными происходит через определенные промежутки вре!
мени. Примерно одна треть операций дискового ввода/вывода приходится
на запись, причем один и тот же буфер может на протяжении ограничен!
ного промежутка времени модифицироваться несколько раз. Поэтому бу!
кэш уменьшить интенсивность записи на
www.books-shop.com
Глава 4.
и реорганизовать последовательность записи отдельных буферов для
повышения производительности ввода/вывода (например, уменьшая время
поиска, группируя запись соседних дисковых блоков). Однако этот меха!
низм имеет свои недостатки, поскольку может привести к нарушению це!
лостности файловой системы в случае неожиданного останова или сбоя
операционной системы.
Операции ввода/вывода
На рис. 4.14 представлена схема выполнения операций ввода/вывода с ис!
пользованием буферного кэша. Важной особенностью этой подсистемы
является то, что она обеспечивает независимое выполнение операций чте!
ния или записи данных процессом как результат соответствующих систем!
ных вызовов, а также фактический обмен данными с периферийным уст!
ройством.
Когда процессу требуется прочитать или записать данные он использует
системные вызовы read(2) или направляя тем самым запрос файло!
вой подсистеме. В свою очередь файловая подсистема транслирует этот за!
прос в запрос на чтение или запись соответствующих дисковых блоков фай!
ла и направляет его в буферный кэш. Прежде всего кэш просматривается на
предмет наличия требуемого блока в памяти. Если соответствующий буфер
найден, его содержимое копируется в адресное пространство процесса в
случае чтения и наоборот при записи, и операция завершается. Если блок в
кэше не найден, ядро размещает буфер, связывает его с дисковым блоком с
помощью заголовка buf и направляет запрос на чтение драйверу устройства.
Обычно используется схема вперед (read!ahead), когда считываются
не только запрашиваемые блоки, но и которые с высокой вероятно!
стью могут потребоваться в ближайшее время (рис. 4.14, а). Таким образом,
последующие вызовы скорее всего не потребуют дискового вво!
да/вывода, а будут включать лишь копирование данных из буферов в память
процесса, — операция, которая, как отмечалось, обладает на несколько по!
рядков большей производительностью (рис. 4.14, При запросе на мо!
дификацию блока изменения также затрагивают только буфер кэша. При
этом ядро помечает буфер как "грязный" в заголовке buf (рис. 4.14, г). Пе!
ред освобождением такого буфера для повторного использования, его со!
держимое должно быть предварительно сохранено на диске (рис. д).
Перед фактическим использованием буфера, например при чтении или
записи буфера процессом, или при операции дискового ввода/вывода, дос!
туп к нему для других процессов должен быть заблокирован. При обраще!
нии к уже заблокированному буферу процесс переходит в состояние сна,
пока данный ресурс не станет доступным.
Использование буферного кэша позволяет избежать 95% операций чтения с диска и 85%
операций записи на диск для типичной конфигурации операционной системы.
www.books-shop.com
Буферный кэш 315
Рис. 4.14. Схема работы буферного кэша
www.books-shop.com
Глава 4. Файловая
Не заблокированные буферы помечаются как свободные и помещаются в
специальный список. Буферы в этом списке располагаются в порядке
наименее частого использования (Least Recently Used, LRU). Таким обра!
зом, когда ядру необходим буфер, оно выбирает тот, к которому не было
обращений в течение наиболее продолжительного промежутка времени.
После того как работа с буфером завершена, он помещается в конец спи!
ска и является наименее вероятным кандидатом на освобождение и по!
вторное использование. Поэтому, если процесс вскоре опять обратится к
тому же блоку данных, операция ввода/вывода по!прежнему будет проис!
ходить с буфером кэша. С течением времени буфер перемещается в на!
правлении начала очереди, но при каждом последующем обращении к не!
му, будет помещен в ее конец.
Основной проблемой, связанной с буферным кэшем, является "старение"
информации, хранящейся в дисковых блоках, образы которых находятся в
буферном кэше. Как следует из схемы работы кэша, большинство измене!
ний затрагивают только данные в соответствующих буферах, в то время,
как дисковые блоки хранят уже устаревшую информацию. Разумеется в
нормально работающей системе проблемы как таковой не возникает, по!
скольку в операциях ввода/вывода всегда используются свежие данные
буферного кэша. Однако при аварийном останове системы, это может
привести к потере изменений данных файлов, сделанных процессами не!
посредственно перед остановом.
Для уменьшения вероятности таких потерь в UNIX имеется несколько
возможностей:
Во!первых, может использоваться системный вызов который
обновляет все дисковые блоки, соответствующие "грязным" буферам.
Необходимо отметить, что sync(2) не ожидает завершения операции
ввода/вывода, таким образом после возврата из функции не гаранти!
руется, что все "грязные" буферы сохранены на
Во!вторых, процесс может открыть файл в синхронном режиме
(указав флаг в системном вызове При этом все из!
менения в файле будут немедленно сохраняться на диске.
Наконец, через регулярные промежутки времени в системе пробуж!
дается специальный системный процесс — диспетчер буферного кэ!
ша (в различных версиях UNIX его названия отличаются, чаще всего
используется или Этот процесс освобождает
В распоряжении администратора имеется командный интерфейс к системному вызову —
утилита Поскольку выполнение команды не свидетельствует о фактическом
завершении ввода/вывода, администраторы практикуют вызов несколько раз.
Повторные вызовы повышают вероятность что ввод/вывод будет завершен прежде,
чем будет введена другая команда или остановлена система, поскольку набор команды за!
нимает определенное время. Тот же эффект может быть достигнут просто ожиданием не!
скольких секунд после ввода но набор команды позволяет "скрасить ожидание".
www.books-shop.com
Целостность файловой системы 317
"грязные" буферы, сохраняя их содержимое в соответствующих дис!
ковых (рис. 4.14, д).
Кэширование в SVR4
Центральной концепцией в архитектуре виртуальной памяти SVR4 являет!
ся отображение файлов. При этом подходе все адресное пространство мо!
жет быть представлено набором отображений различных файлов в память.
Действительно, в страницы памяти, содержащие кодовые сегменты, ото!
бражаются соответствующие секции исполняемых файлов. Процесс может
задать отображение с помощью системного вызова при этом
страницам памяти будут соответствовать определенные участки отобра!
жаемого файла. Даже области памяти, содержимое которых изменяется и
не связано ни с каким файлом файловой системы, т. н. анонимные страни!
цы, можно отобразить на определенные участки специального файла уст!
ройства, отвечающего за область свопинга (именно там сохраняются ано!
нимные объекты памяти). При этом фактический обмен данными между
памятью и устройствами их хранения, инициируется возникновением
страничной ошибки. Такая архитектура позволяет унифицировать опера!
ции ввода/вывода практически для всех случаев.
При этом подходе, когда процесс выполняет вызовы или
ядро устанавливает отображение части файла, адресованного этими вызо!
вами, в собственное адресное пространство. Затем эта область копируется
в адресное пространство процесса. При копировании возникают странич!
ные ошибки, приводящие в фактическому считыванию дисковых блоков
файла в память. Поскольку все операции кэширования данных в этом слу!
чае обслуживаются подсистемой управления памятью, необходимость в
буферном кэше, как отдельной подсистеме, отпадает.
Целостность файловой системы
Значительная часть файловой системы находится в оперативной памяти.
А именно, в оперативной памяти расположены суперблок примонтиро!
ванной системы, метаданные активных файлов (в виде системно!зависи!
мых inode и соответствующих им и даже отдельные блоки хранения
данных файлов, временно находящиеся в буферном кэше.
Работа буферного кэша зависит от версии и конкретных настроек ядра
системы. Например, в SCO UNIX для этого используются несколько параметров. Параметр
задает интервал между последовательными пробуждениями его
по умолчанию составляет 30 секунд. Параметр задает промежуток времени, кото!
рый буфер должен оставаться "грязным", прежде чем bdflush сохранит его на
www.books-shop.com
Глава 4. Файловая
Для операционной системы рассогласование между буферным кэшем и бло!
ками хранения данных отдельных файлов, не приведет к катастрофическим
последствиям даже в случае внезапного останова системы, хотя с точки зре!
ния пользователя все может выглядеть иначе. Содержимое отдельных фай!
лов не вносит существенных нарушений в целостность файловой системы.
Другое дело, когда подобные несоответствия затрагивают метаданные фай!
ла или другую управляющую информацию файловой системы, например,
суперблок. Многие файловые операции затрагивают сразу несколько объ!
ектов файловой системы, и если на диске будут сохранены изменения
только для части этих объектов, целостность файловой системы может
быть существенно нарушена.
Рассмотрим пример создания жесткой связи для файла. Для этого файло!
вой подсистеме необходимо выполнить следующие операции:
1. Создать новую запись в необходимом каталоге, указывающую на
файла.
2. Увеличить счетчик связей в inode.
Предположим, что аварийный системы произошел между первой
и второй операциями. В этом случае после запуска в файловой системе
будут существовать два имени файла (две записи каталогов), адресующие
inode со счетчиком связей равным 1. Эта ситуация показана
на рис. (а). Если теперь будет удалено одно из имен, это приведет к
удалению файла как такового, т. е. к освобождению блоков хранения дан!
ных и inode, поскольку счетчик связей di_nlinks станет равным 0. Ос!
тавшаяся запись каталога будет указывать на неразмещенный индексный
дескриптор, или inode, адресующий уже другой файл (рис. б).
Порядок операций с метаданными может иметь существенное влияние на
целостность файловой системы. Рассмотрим, например, предыдущий при!
мер. Допустим, порядок операций был изменен и, как и прежде, останов
произошел между первой и второй операциями. После запуска системы
файл будет иметь лишнюю жесткую связь, но существующая запись ката!
лога останется правильной. Тем не менее при удалении имени файла фак!
тически файл удален не будет, поскольку число связей останется равным 1
(рис. 4.15, в). Хотя это также является ошибкой, результатом которой яв!
ляется засорение дискового пространства, ее последствия все же менее ка!
тастрофичны, чем в первом случае.
Ядро выбирает порядок совершения операций с метаданными таким обра!
зом, чтобы вред от ошибок в случае аварии был минимальным. Однако
проблема нарушения этого порядка все же остается, т. к. драйвер может
изменять очередность выполнения запросов для оптимизации вво!
да/вывода. Единственной возможностью сохранить выбранный порядок
является синхронизация операций со стороны файловой подсистемы.
www.books-shop.com
Целостность файловой системы 319
В нашем примере файловая подсистема будет ожидать, пока на диск не
будет записано содержимое индексного дескриптора, и только после этого
произведет изменения каталога.
Рис. 4.15. Нарушение целостности файловой системы
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
320 Глава 4.
Отсутствие синхронизации между образом файловой системы в памяти и
ее данными на диске в случае аварийного останова может привести к по!
явлению следующих ошибок:
1. Один блок адресуется несколькими mode (принадлежит нескольким
файлам).
2. Блок помечен как свободный, но в то же время занят (на него ссыла!
ется
Блок помечен как занятый, но в то же время свободен (ни один inode
на него не ссылается).
4. Неправильное число ссылок в inode (недостаток или избыток ссы!
лающихся записей в каталогах).
5. Несовпадение между размером файла и суммарным размером адресуе!
мых inode блоков.
6. Недопустимые адресуемые блоки (например, расположенные за преде!
лами файловой системы).
7. "Потерянные" файлы (правильные inode, на которые не ссылаются за!
писи каталогов).
8. Недопустимые или неразмещенные номера inode в записях каталогов.
Эти ошибки схематически показаны на рис.
Рис. 4.16. Возможные ошибки файловой системы
www.books-shop.com
Заключение
Если нарушение все же произошло, на помощь может прийти утилита
производящая исправление файловой системы. Запуск этой ути!
литы может производиться автоматически каждый раз при запуске систе!
мы, или администратором, с помощью команды:
fsck [options]
где filesystem — специальный файл устройства, на котором находится
файловая система.
Проверка и исправление должны производиться только на размонтиро!
ванной файловой системе. Это связано с необходимостью исключения
синхронизации таблиц в памяти (ошибочных) с их дисковыми эквивален!
тами (исправленными). Исключение составляет корневая файловая систе!
ма, которая не может быть размонтирована. Для ее исправления необхо!
димо использовать опцию обеспечивающую немедленный перезапуск
системы после проведения проверки.
Заключение
В этой главе описана организация файловой подсистемы UNIX. Начав
разговор с обсуждения архитектуры традиционных файловых систем
UNIX, мы остановились на анализе т. н. виртуальной файловой системы,
обеспечивающей единый интерфейс доступа к различным типам физиче!
ских файловых систем.
Мы также рассмотрели, каким образом происходит доступ процесса к
данным, хранящимся в файлах, вплотную подошли к разговору о подсис!
ввода/вывода, который и продолжим в главе.
www.books-shop.com
Фактическая архитектура ввода/вывода скрыта от прикладного процесса
несколькими интерфейсами. Один из них — интерфейс файловой системы
был рассмотрен в предыдущей главе. Взаимодействие с удаленными ресур!
сами обеспечивается сетевыми интерфейсами сокетов или ТЫ (Transport
Layer Interface), которые описываются в главе 6. Однако возможны ситуа!
ции, когда прикладному процессу требуется взаимодействие с периферий!
ными устройствами на более низком уровне. Хотя в этом случае роль фай!
ловой подсистемы не столь велика, как при работе с обычными файлами,
все равно ядро предоставляет процессу унифицированную схему, скры!
вающую истинную архитектуру того или иного устройства.
В конечном итоге работа всех этих интерфейсов, как высокого уровня,
(файловая система), так и более низкого (взаимодействие с физическим
устройством), обеспечивается подсистемой ввода/вывода ядра операцион!
ной системы.
В данной главе мы ознакомимся с архитектурой этой подсистемы, основ!
ным компонентом которой являются драйверы — модули ядра, обеспечи!
вающие непосредственную работу с периферийными устройствами. По!
скольку характеристики периферийных устройств значительно различают!
ся, то UNIX использует два основных типа драйверов — символьные и
блочные. Как следует из названия, драйверы первого типа обеспечивают
обмен сравнительно небольшими объемами данных с устройством, что
имеет место при работе, например, с терминалами или принтерами. Драй!
веры второго типа производят передачу данных блоками, что характерно
для дисковых носителей данных. Эти типы драйверов входят в традицион!
ную подсистему ввода/вывода и присутствуют во всех версиях UNIX.
Во второй части главы мы подробно остановимся на архитектуре драйверов
подсистемы STREAMS, которая является неотъемлемой частью ядра в вер!
сиях UNIX System V. Эти драйверы представляют собой отдельный тип, об!
ладающий такими ценными возможностями, как буферизация и управление
потоком данных. К подсистеме STREAMS мы также вернемся в следующей
главе при обсуждении архитектуры сетевого доступа в UNIX System V.
www.books-shop.com
устройств 323
Драйверы устройств
Драйверы устройств обеспечивают интерфейс между ядром UNIX и аппа!
ратной частью компьютера. Благодаря этому от остальной части ядра скры!
ты архитектурные особенности компьютера, что значительно упрощает пе!
ренос системы и поддержку работы различных периферийных устройств.
В UNIX существует большое количество драйверов. Часть из них обеспечи!
вает доступ к физическим устройствам, например, жесткому диску, принте!
ру или терминалу, другие предоставляют услуги.
Примером последних могут служить драйверы для работы с вир!
туальной памятью ядра представляющий "нулевое" устройство.
В процессе запуска системы ядро вызывает соответствующие процедуры ини!
циализации установленных драйверов. Во многих версиях UNIX эти про!
цедуры выводят на консоль сообщение о том, что драйвер найден, и инициа!
лизация прошла успешно, а также параметры драйвера и устройства.
Типы драйверов
Драйверы различаются по возможностям, которые они предоставляют, а
также по тому, каким образом обеспечивается к ним доступ и
Можно рассматривать три основные типа драйверов:
Символьные Этот тип драйверов обеспечивает работу с устройствами с
драйверы побайтовым доступом и обменом данными. К таким уст!
ройствам можно отнести модемы, терминалы, принтеры,
манипуляторы мышь и т. д.
Доступ к таким драйверам не включает использование бу!
ферного кэша, таким образом ввод и вывод как правило не
буферизуется. При необходимости буферизации для сим!
вольных драйверов обычно используется подход, основан!
ный на структурах данных, называемых
Блочные Этот тип драйверов позволяет производить обмен данными
драйверы с устройством фиксированными порциями (блоками). На!
пример, для жесткого диска данные можно адресовать и,
соответственно, читать только секторами, размер которых
составляет несколько сотен байтов. Для блочных драйверов
обычно используется буферный кэш, который и является
интерфейсом между файловой системой и устройством.
Хотя операции чтения и записи для процесса допускают
обмен данными, размер которых меньше размера блока, на
системном уровне это все равно приводит к считыванию
всего блока, изменению части его данных и записи изме!
ненного блока обратно на диск.
www.books-shop.com
324 Глава 5.
Драйверы низкого
уровня (raw drivers)
Этот тип интерфейса блочных драйверов позволяет
производить обмен данными с блочными устройст!
вами, минуя буферный кэш. Это, в частности, озна!
чает, что устройство может быть адресовано элемен!
тами, размер которых не совпадает с размером блока.
Обмен данными происходит независимо от файловой
подсистемы и буферного кэша, что позволяет ядру
производить передачу непосредственно между поль!
зовательским процессом и устройством, без допол!
нительного копирования.
На рис. 5.1 приведена упрощенная схема взаимодействия драйверов уст!
ройств с другими подсистемами операционной системы UNIX.
Рис. Драйверы устройств UNIX
Не все драйверы служат для работы с физическими устройствами, такими
как сетевой адаптер, последовательный порт или монитор. Часть драйве!
www.books-shop.com
Драйверы устройств 326
ров служат для предоставления различных услуг ядра прикладным процес!
сам и не имеют непосредственного отношения к аппаратной части ком!
пьютера. Такие драйверы называются программными или драйверами псев!
доустройств. Можно привести несколько примеров псевдоустройств и со!
ответствующих им программных драйверов:
Обеспечивает доступ к виртуальной памяти ядра. Зная виртуальные
адреса внутренних структур ядра, процесс может считывать храня%
щуюся в них информацию. С помощью этого драйвера может, на%
пример, быть реализована версия утилиты ps(1), выводящей ин%
формацию о состоянии процессов в системе.
Обеспечивает доступ к разделу исполняемого файла ядра, содержа%
щего таблицу символов. Совместно с драйвером /dev/kmem обеспе%
чивает удобный интерфейс для анализа внутренних структур ядра.
Обеспечивает доступ к физической памяти компьютера.
Является "нулевым" устройством. При записи в это устройство дан%
ные просто удаляются, а при чтении процессу возвращается 0 бай%
тов. Примеры использования этого устройства рассматривались в
главе когда с помощью /dev/null мы подавляли вывод сообщений
об ошибках.
/dev/zero Обеспечивает заполнение нулями указанного буфера. Этот драйвер
часто используется для инициализации области памяти.
Базовая архитектура драйверов
Драйвер устройства адресуется старшим номером (major number) устройства.
Напомним, что среди атрибутов специальных файлов устройств, которые
обеспечивают пользовательский интерфейс доступа к периферии компьюте!
ра, это число присутствует наряду с другим, также имеющим отношение к
драйверу, — младшим номером (minor number). Младший номер интерпрети!
руется самим драйвером (например, для клонов, оно задает старшее число
устройства, которое требуется "размножить"). Другим примером использова!
ния младших номеров может служить драйвер диска. В то время как доступ
к любому из разделов диска осуществляется одним и тем же драйвером и,
соответственно, через один и тот же старший номер, младший номер указы!
вает, к какому именно разделу требуется обеспечить доступ.
Доступ к драйверу осуществляется ядром через специальную структуру
данных (коммутатор каждый элемент которой содержит ука!
затели на соответствующие функции драйвера — точки входа. Старшее
число, по существу, является указателем на элемент коммутатора уст!
ройств, обеспечивая, тем самым, ядру возможность вызова необходимой
функции указанного драйвера. Таким образом, коммутатор устройств оп!
ределяет базовый интерфейс драйвера устройств.
www.books-shop.com
326 Глава 5.
Этот интерфейс различен для блочных и символьных устройств. Ядро со!
держит коммутаторы устройств двух типов: для блочных и
для символьных устройств. Ядро размещает отдельный массив для каждого
типа коммутатора, и любой драйвер устройства имеет запись в соответст!
вующем массиве. Если драйвер обеспечивает как блочный, так и символь!
ный интерфейсы, его точки входа будут представлены в обоих массивах.
Типичное описание этих двух массивов имеет следующий вид (назначение
различных точек входа мы рассмотрим далее в этом разделе):
struct {
int
int (*d_close)
int
int
int
}
struct {
int
int
int
int
int ()
int
int
struct
}
Ядро вызывает функцию open требуемого драйвера следующим образом:
передавая ей в качестве одного из параметров переменную dev (типа
содержащую старший и младший номера. Макрос
служит для извлечения старшего номера из переменной dev. Благодаря
этому драйвер имеет возможность определить, с каким младшим номером
была вызвана функция open и выполнить соответствующие действия.
Коммутатор определяет абстрактный интерфейс драйвера устройства. Каж!
дый драйвер обеспечивает соответствующую реализацию функций этого
интерфейса. Если драйвер не поддерживает каких!либо функций стан!
дартного интерфейса, он заменяет соответствующие точки входа специ!
альными заглушками, предоставляемыми ядром. Когда ядру требуется за!
просить какую!либо операцию у драйвера устройства, оно определяет эле!
мент коммутатора, соответствующий данному драйверу (используя его
старший номер), и вызывает требуемую функцию.
В названиях точек входа драйвера используются определенные соглаше!
ния. Поскольку в ядре системы одновременно присутствует большое ко!
www.books-shop.com
327
личество различных драйверов, каждый их них должен иметь уникальное
имя во избежание проблем при компиляции (точнее, при редактировании
связей) ядра. Каждый драйвер имеет уникальное обозна!
чение, используемое в качестве префикса названий функций. Например,
драйвер виртуальной памяти ядра имеет префикс mm, таким
образом функции этого драйвера будут иметь названия
, И .
В табл. 5.1 приведены некоторые точки входа, общие для различных типов
драйверов, а символами хх, с которых начинается имя каждой функции,
обозначен уникальный префикс драйвера. Стандартные точки входа драй!
вера отличаются для разных версий UNIX. Например, некоторые версии
имеют расширенный коммутатор блочных устройств, включающий такие
функции, как и xxwrite В некоторых версиях
включены точки входа для инициализации и сброса шины данных.
Таблица 5.1. Типичные точки входа в драйвер устройства
Точка входа Сим[
воль[
ный
Блоч
ный
Низкого
уровня
Назначение
+
+
+
+
+
+
—
—
+
+
+
Вызывается при каждой опера%
ции открытии устройства. Обес%
печивает необходимую реини%
физического уст%
ройства и внутренних данных
драйвера. Например, для каждо%
го последующего открытия драй%
вера могут размещаться допол%
нительные буферы, обеспечи%
вающие возможность независи%
мой работы с устройством не%
скольким процессам.
Вызывается, когда число ссылок
на данный драйвер становится
равным нулю, т. е. ни один из
процессов системы не работает с
устройством (не имеет открытым
соответствующий файл устрой%
ства). Может вызывать отключе%
ние физического устройства.
Например, драйвер накопителя
на магнитной ленте может пере%
мотать ленту в начало.
Производит чтение данных от
устройства.
Производит запись данных на
устройство.
www.books-shop.com
328 Глава 5, ввода/вывода
Таблица 5.1 (продолжение)
Точка входа Сим[
воль[
ный
Блоч[ Низкого
уровня
Назначение
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Является общим интерфейсом
управления устройством. Драй%
вер может определить набор
команд, которые могут быть пе%
реданы ему, например с помо%
щью системного вызова ioctl(2).
Вызывается при поступлении
прерывания, связанного с дан%
ным устройством. Может выпол%
нить копирование данных от уст%
ройства в промежуточные буфе%
ры, которые затем считываются
функцией xxread по запросу
прикладного процесса.
Производит опрос устройства.
Обычно используется для уст%
ройств, не поддерживающих
прерывания, например, для оп%
ределения поступления данных
для чтения.
Вызывается для останова драй%
вера при останове системы или
при выгрузке драйвера.
Общая точка входа для операций
блочного Назва%
ние функции говорит о том, что
устройство может обеспечивать
собственную стратегию обработ%
ки поступающих запросов, на%
пример, изменять их порядок
для повышения производитель%
ности Если уст%
ройство занято, функция поме%
щает запросы в очередь. В этом
случае фактический
инициирует функция обработки
прерывания, которая вызывает%
ся, когда устройство закончит
предыдущую операцию ввода/вы%
вода.
Выводит сообщение драйвера на
консоль, обычно при запуске
системы.
www.books-shop.com
Драйверы устройств
Ядро вызывает те или иные функции драйвера в зависимости от запроса.
Например, если процесс выполняет системный вызов для специ!
ального файла символьного устройства, ядро вызовет функцию
для соответствующего символьного драйвера. Если же процесс запрашива!
ет ту же операцию для обычного дискового файла, ядро вызовет процедуру
для блочного драйвера, обслуживающего данную файловую
систему.
Вообще говоря, можно выделить пять основных случаев, в которых ядро
обращается к функциям драйвера:
Автоконфигурация. Обычно происходит в процессе инициализации
UNIX, когда ядро определяет, какие устройства доступны в системе.
Ввод/вывод. Запрос на операцию ввода/вывода может быть иниции!
рован как прикладным процессом, так и некоторыми подсистемами
ядра, например, подсистемой управления памятью.
О Обработка прерываний. Ядро вызывает соответствующую функцию
драйвера для обработки прерывания, поступившего от устройства
(если устройство способно генерировать прерывания).
Специальные запросы. Ядро вызывает соответствующую функцию
драйвера для обработки специальных команд, полученных с помо!
щью системного вызова ioctl(2).
П Некоторые типы аппаратных архитектур
могут требовать сброса и устройства. Определен!
ные функции драйвера также вызываются при останове операцион!
ной системы.
На рис. 5.2 и 5.3 приведены схемы доступа к драйверам символьного и
блочного устройств.
Как видно из рисунков, схема обработки запроса ядром UNIX различна
для символьных и блочных устройств.
При обсуждении точек входа драйверов устройств следует иметь в виду,
что большинство функций драйвера, отвечающих за передачу данных,
осуществляют копирование информации из адресного пространства ядра,
в котором находится сам драйвер, в адресное пространство задачи. Когда
ядро вызывает функцию драйвера, все действия выполняются в системном
контексте процесса. Однако схема вызова функций может быть различной:
П Функция может быть вызвана по запросу процесса. Например, если
процесс выполняет системный вызов read(2), ядро вызывает соответст!
вующую точку входа драйвера xxread(), обеспечивающего работу с
файлом. В этом случае говорят, что функция имеет контекст задачи.
П Функция может быть вызвана другой подсистемой ядра операцион!
ной системы. Например, для блочного драйвера функция
может быть вызвана страничным демоном, для со!
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
330 Глава 5.
хранения страниц во вторичной памяти (как правило, на жестком
диске). Поскольку страничный демон представляет собой системный
процесс, выполняющийся только в контексте ядра, функция
xxstrategy в этом случае имеет системный контекст.
Рис. 5.2. Доступ к драйверу символьного устройства
Если функция вызывается в процессе обработки прерывания, то она
имеет контекст прерывания — специальный вид системного контек!
ста. Функции драйвера, отвечающие за обработку прерывания, на!
пример имеют этот тип контекста.
www.books-shop.com
устройств
Рис. 5.3. Доступ к драйверу блочного устройства
Различия в контексте и причинах вызова тех или иных функций драйвера
позволяют представить драйвер устройства состоящим из двух частей:
верхней части (top half) и нижней (bottom half). Функции верхней
www.books-shop.com
332 Глава 5.
части драйвера имеют синхронный характер, т. е. вызываются по опреде!
ленным запросам прикладного процесса и выполняются в контексте.
Таким образом, для этих функций доступно адресное пространство и
процесса, и при необходимости эти функции могут перевести про!
цесс в состояние сна (вызовом функции (} ядра). Функции вво!
да/вывода и управления принадлежат верхней части драйвера.
Вызов функций нижней части носит асинхронный характер. Например,
момент вызова функции обработки прерываний нельзя предугадать, и ядро
не может контролировать, когда эта функция будет вызвана. Выполнение
таких функций происходит в контексте ядра и обычно не имеет никакого
отношения к контексту текущего процесса. Таким образом, функции сис!
темного контекста не имеют права адресовать структуры данных текущего
процесса, например его u!area, а также не могут перевести процесс в со!
стояние сна, поскольку это заблокирует процесс, не имеющий непосредст!
венного отношения к работе драйвера.
Две части драйвера требуют синхронизации. Например, в случае, когда
функции обеих частей используют одну и ту же структуру данных, функ!
ция верхней части при выполнении должна заблокировать прерывания на
период работы с "разделяемой" областью памяти. В противном случае,
прерывание может поступить в тот момент, когда целостность структуры
данных нарушена, что приведет к непредсказуемым результатам.
Все представленные выше функции, за исключением xxhalt xxpoll
и xxintr принадлежат верхней части драйвера. Функция xxhalt вы!
зывается ядром при останове системы и, таким образом, имеет системный
контекст, не связанный с контекстом прикладного процесса.
Функция обычно вызывается при обработке ядром прерывания
таймера для всех устройств, указанных как опрашиваемые. Это необходи!
мо, в частности, для устройств, которые не могут или "не хотят" использо!
вать аппаратные прерывания. Вместо этого xxpoll может использовать!
ся для эмуляции прерываний, например вызывая функцию xxintr на
каждый тик системного таймера. Поэтому и функция () и
функция обработки прерывания () не могут рассчитывать на кон!
текст прикладного процесса. В большинстве версий UNIX функции опро!
са и обработки прерываний вызываются не через коммутатор устройств, а
через специальные таблицы ядра.
В UNIX SVR4 определены две дополнительные точки входа — init и
start Драйвер регистрирует эти функции в таблицах ядра
и Код начальной загрузки системы запускает функции
перед инициализацией ядра, а функции сразу же
после инициализации.
www.books-shop.com
333
Файловый интерфейс
В главе 4 мы рассмотрели интерфейс т. н. независимой или виртуальной
файловой системы, обеспечивающей унифицированный интерфейс работы
с различными типами физических файловых систем (например, или
s5fs), имеющих разные внутренние структуры и возможности. При этом
подходе используется унифицированный формат метаданных активных
файлов, которые хранятся в памяти (в in!core — таблице индексных деск!
рипторов) и не зависят от конкретной реализации файловой системы. Эти
объекты получили название виртуальных индексных дескрипторов или
vnode. Для каждого vnode определен набор абстрактных операций, кото!
рые реализованы функциями реальных файловых систем. Например, vnode
файла, расположенного в файловой системе s5fs, адресует вектор операций
(или коммутатор файловых систем, FSS) содержащий конкрет!
ные функции этой файловой системы — s5f s_open или
.
Этот подход, используемый в большинстве современных версий UNIX,
требует соответствующей архитектуры файлового интерфейса к драйверам
устройств. Как уже обсуждалось, доступ к периферии в UNIX осуществля!
ется с помощью специальных файлов устройств, расположенных в корне!
вой файловой системе некоторого типа, например ufs. В соответствии с
архитектурой виртуальной файловой системы, все операции с этими фай!
лами будут обслуживаться соответствующими функциями реальной файло!
вой системы, в данном случае — ufs.
Однако такой схеме недостает традиционного для UNIX изящества. Спе!
циальный файл устройства не является обычным файлом системы ufs.
Фактически все операции со специальным файлом устройства выполняют!
ся драйвером и не зависят от типа файловой системы. Поэтому было бы
логичнее отобразить операции vnode не на вектор файловой системы, а
непосредственно на коммутатор устройств.
Современные системы ветви System V используют для этого специальный
тип файловой системы, называемый devfs или Для этого типа фай!
ловой системы все операции vnode адресуют соответствующие функции
требуемого элемента коммутатора устройств. После первоначального от!
крытия файла, когда создается vnode, все запросы, связанные со специ!
альным файлом устройства, проходят через vnode файловой системы
specfs.
В то же время открытие файла, например с помощью системного вызова
предусматривает ряд операций, реализованных реальной файловой
В системах SVR4 принята терминология specfs, операционная система SCO кото!
рая формально является но фактически имеет многие черты называет этот
тип файловой системы devfs.
www.books-shop.com
334 Глава 5.
системой, в которой находится специальный файл устройства (в нашем
примере Одной из таких операций является трансляция имени, кото!
рая не может быть реализована файловой системой specfs, по существу яв!
ляющейся виртуальной.
Решение данной проблемы рассмотрим на конкретном примере. Допус!
тим, процесс вызывает функцию для специального файла устрой!
ства для работы с виртуальной памятью ядра. Функция транс!
ляции имени файловой системы ufs — сначала откроет
файла а затем, прочитав каталог, обнаружит файла
при этом будет размещен этого файла. Однако опре!
делит, что тип этого файла IFCHR, т. е. специальный файл символьного
устройства. Поэтому вместо функции s_open бессмысленной для
этого типа файла, будет вызвана специальная функция файловой системы
specfs, которая создаст собственный индексный дескриптор, описываемой
структурой (от special inode), для этого файла, если таковой уже не
находится в памяти. Согласно стандартной процедуре, также будет создан
и виртуальный индексный дескриптор vnode, который будет указывать на
вектор операций specops, которые специально предназначены для работы
с драйверами устройств. Например, функции
или в свою очередь вызовут соответствующие точки входа
драйвера — функции , или После этого
функции s_open будет передан адрес этого vnode, который она, в
свою очередь, передаст системному вызову В результате, ореп(2)
вернет процессу файловый дескриптор, адресующий vnode файловой сис!
темы specfs, а не vnode файла /dev/kmem. Таким образом, все дальнейшие
операции с /dev/kmem будут перехватываться файловой системой specfs.
Схема связи процесса с этим vnode приведена на рис. 5.4.
Рис. 5.4. Связь процесса с файлом /dev/kmem после его открытия
www.books-shop.com
335
Однако изложенная схема является неполной и имеет ряд существенных
недостатков. Дело в том, что драйвер конкретного устройства может адресо!
ваться несколькими специальными файлами устройств, возможно, располо!
женными в различных физических файловых системах. В этом случае ядро
бессильно определить фактическое число связей прикладных процессов с
данным устройством, что может потребоваться, например, при вызове
функции когда все процессы закончили работу с устройством.
Для решения этой проблемы файловая система specfs предусматривает на!
личие дополнительного snode, позволяющего контролировать доступ к
конкретному устройству. Этот объект, получивший название общего snode
(common snode), является единственным интерфейсом доступа к драйверу
устройства. Для каждого устройства (драйвера устройства) существует
единственный common snode, который создается при первом доступе к
устройству. Каждый специальный файл устройства, в свою очередь, имеет
собственный snode в файловой системе specfs и соответствующий ему
vnode, а также inode физической файловой системы, где расположен спе!
циальный файл устройства, и соответствующий ему vnode.
Для связи всех этих индексных дескрипторов между собой snode имеет два
поля: указывающее на common snode, и s_realvp, указы!
вающее на vnode специального файла устройства файловой системы, где
расположен последний.
Использование тех или иных vnode и связанных с ними inode или snode
зависит от конкретных операций, выполняемых процессом с устройством.
Большинство из этих операций не зависят от имени специального файла
устройства и, соответственно, от реальной файловой системы, в которой
он расположен. Эти операции выполняются через vnode, соответствующий
common snode. Однако существует ряд операций, выполнение которых за!
висит от конкретного специального файла устройства, через который про!
цесс взаимодействует с драйвером. Примером может служить проверка
прав доступа при открытии специального файла устройства, которые рас!
положены в реальной файловой системы. В этом случае ис!
пользуется vnode соответствующего специального файла устройства.
Схема описанной архитектуры приведена на рис. 5.5.
Клоны
Как уже обсуждалось, старший номер устройства адресует драйвер, в то
время как младший номер интерпретируется самим драйвером и может
использоваться для различных целей. Например, используя различные
младшие номера, процесс может получить доступ к разным разделам же!
сткого диска, обслуживаемого одним драйвером.
Во многих случаях использование различных младших номеров позволяет
нескольким процессам осуществлять одновременную независимую работу
с устройством (или псевдоустройством). Каждый младший номер при этом
соответствует логическому драйверу, поддерживающему собственные
www.books-shop.com
Глава 5.
структуры данных при работе с конкретным процессом. Типичным приме!
ром могут служить псевдотерминалы. В таких случаях процессу требуется
получить доступ к устройству, при этом его не интересует его младший
номер, поскольку различие в младших номерах не отражает различие в
функциональности. Типичным примером являются сетевые протоколы,
чаще всего реализованные в виде соответствующих драйверов. Сетевые
соединения, основанные на одном и том же протоколе (и, следовательно,
работающие с одним и тем же драйвером), используют различные млад!
шие номера для доступа к драйверу. Это позволяет драйверу обеспечивать
обработку нескольких сетевых соединений, для каждого из которых под!
держиваются собственные структуры данных. Если процессу необходимо
установить сетевую связь, ему безразлично, какой младший номер будет у
драйвера, главное, чтобы он еще не использовался.
Рис. 5.5. Доступ к устройству через различные специальные файлы
www.books-shop.com
Драйверы устройств 337
Возможным сценарием доступа к такому устройству может являться пере!
бор различных младших номеров (соответствующих специальных файлов),
пока операция open не завершится успешно. Это будет гарантировать,
что процесс получил в свое распоряжение отдельное логическое устройст!
во. Другой сценарий возлагает всю работу по поиску неиспользуемого
младшего номера устройства на специальные драйверы, получившие на!
звания
Когда процесс открывает специальный файл устройства, происходит ини!
циализация соответствующего snode и вызов функции реа!
лизованной в файловой системе specfs, о которой только что говорилось.
Эта функция, в свою очередь, вызывает функцию драйвера ххореп пе!
редавая ей в качестве аргумента указатель на номера устройства, сохра!
ненного в поле s_dev snode. Одной из схем реализации клонов является
использование зарезервированного младшего номера. Когда процесс от!
крывает специальный файл устройства с этим номером, функция
ххореп выбирает неиспользуемый младший номер и соответственно
модифицирует данные snode (с помощью указателя на vnode, передавае!
мые ей Поскольку доступ процесса к драйверу осуществля!
ется через vnode файловой системы specfs, все последующие операции бу!
дут использовать новый младший номер. Таким образом, процесс получит
доступ к новому логическому устройству. Эта схема приведена на рис. 5.6.
Рис. 5.6. Создание клонов с помощью зарезервированного младшего номера
Clone (англ.) — размножаться.
www.books-shop.com
crwrw
crw
crwrwrw
111
1
1
1
root
root
root
root
root
root
sys
sys
sys
sys
sys
11, 44
11, 5
11, 3
11, 40
11, 42
11, 41
Oct 31
Oct 31
Nov 3
Nov 3
Oct 31
Nov 3
16:36
16: 36
1995
1995
16:36
1995
arp
ip
tcp
Встраивание драйверов в ядро
Драйвер устройства является частью кода ядра операционной системы и
обеспечивает взаимодействие других подсистем UNIX с физическими или
псевдоустройствами. Существует два основных метода встраивания кода и
данных драйвера в ядро операционной системы: перекомпиляция ядра,
позволяющая статически поместить драйвер, и динамическая загрузка
драйвера в ядро в процессе работы системы.
338 5. ввода/вывода
Другой подход заключается в использовании специального драйвера, обес!
печивающего создание клонов, — драйвера клонов (clone driver). При этом
все драйверы, чье "размножение" обеспечивается таким образом, имеют
один и тот же старший номер, адресующий драйвер клонов. Младший но!
мер адресует собственно драйвер, т. е. представляет собой старший номер
реального устройства, для которого создается клон. Примеры использова!
ния такой схемы можно обнаружить для драйверов системы STREAMS, с
помощью которых часто реализуются сетевые протоколы и терминальный
доступ, включая псевдотерминалы. Это можно заметить, рассмотрев под!
робный список файлов, отвечающих за эти устройства:
$ !1
В данном случае старший номер всех драйверов равен 11 — это драйвер
клонов. Если проанализировать информацию файла, скажем, tcp, To станет
понятно, что старший номер драйвера этого протокола равен 42, для фай!
ла tcp он представлен младшим номером устройства. Когда процесс от!
крывает этот файл, производится вызов функции clopen() драйвера кло!
нов, которой передаются номера устройства. Функция clopen() исполь!
зует младший номер для поиска требуемых точек входа драйвера TCP в
коммутаторе устройств cdevswf[] После этого clopen () вызывает про!
цедуру хxореn() драйвера, в данном случае tcpopen(), передавая ей ука!
затель на номера устройства и флаг CLONEOPEN. В ответ на это tcpopen()
генерирует неиспользуемый младший номер, создает отдельный логиче!
ский драйвер (т. е. копирует необходимые структуры данных) и соответст!
вующим образом модифицирует поле индексного дескриптора
файловой системы specfs. Таким образом, для получения уникального
TCP!соединения процессу нет необходимости самостоятельно производить
поиск неиспользуемого младшего номера.
www.books-shop.com
устройств 339
Традиционно для встраивания драйвера в ядро UNIX требуется переком!
пиляция ядра и перезапуск системы. Принципиально эта процедура не
отличается от компиляции обычной программы, все компоненты ядра яв!
ляются объектными модулями и редактор связей объединяет их с объект!
ным модулем драйвера для получения исполняемого файла. В этом случае
драйвер встраивается в ядро статически, т. е. независимо от фактического
наличия устройства и ряда других причин, код и данные драйвера будут
присутствовать в ядре UNIX до следующей перекомпиляции.
Однако тенденция развития современных версий операционной системы
UNIX заключается в предоставлении возможности динамического расши!
рения функциональности ядра. Это, в частности, относится к файловой
системе, драйверам устройств и сетевым протоколам (точнее, драйверам
подсистемы STREAMS). Возможность работы с новыми периферийными
устройствами без необходимости перекомпиляции ядра обеспечивается
загружаемыми драйверами. Вместо того чтобы встраивать модуль драйвера,
основываясь на статических таблицах и интерфейсах, ядро содержит набор
функций, позволяющих загрузить необходимые драйверы и, соответствен!
но, выгрузить их, когда необходимость работы с данным устройством от!
падает. При этом структуры данных для доступа к драйверам устройств
также являются динамическими.
Динамическая установка драйвера в ядро операционной системы требует
выполнения следующих операций:
Размещение и динамическое связывание символов драйвера. Эта
операция аналогична загрузке динамических библиотек, и выполня!
ется специальным загрузчиком.
Инициализация драйвера и устройства.
Добавление точек входа драйвера в соответствующий коммутатор
устройств.
П Установка обработчика прерываний драйвера.
Естественно, код динамически загружаемых драйверов сложнее, и содер!
жит, помимо стандартных точек входа, ряд функций, отвечающих за за!
грузку и выгрузку драйвера, а также ряд дополнительных структур. При!
мер дополнительных функций и структур данных, которые должны быть
определены в динамически загружаемом драйвере операционной системы
Solaris 2.5, приведен в табл. 5.2.
Таблица 5.2. Дополнительные функции и структуры данных для загружаемых драйверов
Функция инициализации и установки, вызываемая при за%
грузке драйвера
Функция, вызываемая перед выгрузкой драйвера, удаляю%
щая его из системы
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
340 Глава 5.
Таблица 5.2 (продолжение)
_inf о Функция, возвращающая информацию о драйвере по за%
просу ядра
struct Структура, используемая функциями и
_inf о при загрузке, выгрузке и получении информации о
драйвере
struct Структура, экспортируемая ядру при загрузке драйвера, в
частности, содержит адреса точек входа в драйвер
Помимо этого Solaris 2.5 предоставляет ряд функций ядра для работы с дина!
мически загружаемыми драйверами: mod_remove (9F) и
mod .
Блочные устройства
Драйверы блочных устройств предназначены для обслуживания перифе!
рийного оборудования, обеспечивающего обмен данными с помощью
фрагментов фиксированной длины, называемыми блоками, размер которых
значительно превышает один байт. В основном эти драйверы используют!
ся файловой подсистемой и подсистемой управления памятью. Например,
свопинг характеризуется обменом данными с устройством вторичной па!
мяти, размер которых обычно равен размеру страницы, что составляет
4 или 8 Кбайт. Файловая подсистема производит чтение и запись данных
фрагментами, размер которых равен одному или нескольким блокам уст!
ройства. Типичными представителями блочных устройств являются жест!
кий и гибкий диски.
Блочные устройства можно разделить на два типа в зависимости от того,
используются ли они для хранения файловой системы или нет. Соответст!
венно различается и схема доступа к этим устройствам. В последнем слу!
чае доступ к устройству осуществляется только через специальный файл
устройства, представляющий интерфейс низкого уровня. Хотя обращение
к устройствам, содержащим файловые системы, может также осуществ!
ляться через интерфейс низкого уровня, доступ к таким устройствам, как
правило, осуществляется процессом косвенно, через запросы к файловой
системе. Например, чтение или запись обычного файла вызывает опера!
ции с драйвером блочного устройства (жесткого диска), на котором распо!
ложена файловая система, хранящая данный файл. В этом случае обмен
данными происходит при активном участии буферного кэша, позволяю!
щего минимизировать число обращений непосредственно к физическому
устройству.
www.books-shop.com
Блочные 341
Вообще говоря, операции ввода/вывода для блочного устройства могут
быть вызваны рядом событий:
Чтением или записью в обычный файл.
О Чтением или записью непосредственно в специальный файл устройства.
Операциями подсистемы управления памятью: страничным замеще!
нием или свопингом.
Доступ к блочным устройствам осуществляется с помощью трех основных
точек входа: и При этом за факти!
ческое выполнение ввода/вывода отвечает xxstrategy ( ) . Единственным
аргументом, передаваемым этой функции, является указатель на структуру
buf, представляющую собой заголовок буфера обмена, с которой мы уже
встречались в предыдущей главе при разговоре о буферном кэше. Структу!
ра buf содержит всю необходимую для операций ввода/вывода информа!
цию. Основные поля структуры buf:
Флаги. Определяют состояние буфера (например,
или B_DONE) и направление передачи данных
B_PHYS)
Указатели двухсвязного рабочего списка буферов, ожидаю%
щих обработки драйвером
Размер буфера
. Виртуальный адрес буфера
Номер блока начала данных на устройстве
Число байтов, которые требуется передать
Старший и младший номера устройства
Использование заголовка buf при передачи блока данных показано на
рис. 5.7.
Ядро адресует дисковый блок, указывая vnode и смещение. Если доступ
осуществляется к специальному файлу устройства, то смещение является
физическим, отсчитываемым от начала устройства. Например, если специ!
альный файл устройства обеспечивает доступ ко второму
разделу жесткого диска, то смещение будет отсчитываться от начала этого
раздела. Если vnode представляет обычный файл, то смещение является
логическим, отсчитываемым от начала файла.
Таким образом, блок устройства, содержащего файловую систему, может
быть адресован двумя способами — либо через обычный файл и логиче!
ское смещение, либо через специальный файл устройства и физическое
смещение на этом устройстве. Это, в свою очередь, может привести к раз!
личной идентификации одного и того же блока и, как следствие, двум
различным копиям блока в памяти. Результатом такого несоответствия
может стать потеря или нарушение целостности данных. Поэтому непо!
средственный доступ к специальному файлу такого устройства возможен
только при размонтированной файловой системе.
www.books-shop.com
342 Глава 5.
Рис. 5.7. Обмен данными с блочным устройством (диском)
Поскольку каждый дисковый блок связан с каким!либо файлом и соответ!
ственно с его vnode, а его образ в памяти — с физическими страницами,
которые также связаны с vnode (через структуры описания физической
памяти — page в SVR4, pfdat в SVR3), все операции ввода/вывода связа!
ны с подкачкой и сохранением страниц и идентифицируются vnode.
Символьные устройства
Символьные устройства представляют собой значительную часть перифе!
рийного оборудования системы, включая терминалы, манипуляторы
(например, мышь), клавиатуру и локальные принтеры. Основное отличие
этих устройств от блочных заключается в том, что они, как правило, пере!
дают небольшие объемы данных.
Обмен данными с символьными устройствами происходит непосредствен!
но через драйвер, минуя буферный кэш. При этом данные обычно копи!
www.books-shop.com
Символьные 343
в драйвер из адресного пространства процесса, запросившего опе!
рацию ввода/вывода.
Если процесс сделал системный вызов ввода/вывода, например,
или со специальным файлом символьного устройства, запрос на!
правляется в файловую подсистему. Поскольку доступ к устройству обслу!
живается файловой системой specfs, рассмотренной ранее, в ответ на вы!
полнение системного вызова процесса ядро выполняет вызов функции
или соответственно для или
Действия функций и похожи. Обе проверяют
тип vnode и определяют, что устройство является символьным. После
этого с помощью коммутатора ядро выбирает соответствующую точку вхо!
да драйвера, используя старший номер, хранящийся в поле v_rdev vnode,
и вызывает эту функцию (соответственно или пе!
редавая ей в качестве параметров старший и младший номера, ряд допол!
нительных параметров, зависящих от конкретного вызова, а также явно
или неявно адресует область копирования данных в адресном пространст!
ве
Интерфейс доступа низкого уровня
Символьные драйверы обеспечивают доступ не только к символьным уст!
ройствам, например, к адаптеру последовательного или параллельного
портов, манипулятору "мышь", монитору или терминалам. Часть символь!
ных драйверов служит в качестве интерфейса доступа низкого уровня к
блочным устройствам, таким как диски или накопители на магнитных
лентах.
Большинство таких драйверов отличаются от соответствующих им драйве!
ров блочных устройств характером выполнения операций ввода/вывода. В
то время как драйверы блочных устройств производят обмен данными с
буферным кэшем, драйверы доступа низкого уровня обеспечивают обмен
данных непосредственно с адресным пространством процесса. Отсутствие
посредника в виде буферного кэша устраняет необходимость в соверше!
нии дополнительных операций копирования (драйвер — буферный кэш —
буфер процесса), но в то же время лишает процесс услуг кэширования
данных, предоставляемых операционной системой.
Интерфейс доступа низкого уровня используется многими системными
утилитами обслуживания файловой системы, например, а также
рядом приложений, работающих с накопителями на магнитной ленте, на!
пример или Этот интерфейс используется некоторыми
Несколько иная схема применяется для драйверов подсистемы STREAMS, которые также
имеют интерфейс доступа. Эти драйверы будут в данной
главе в "Подсистема STREAMS".
www.books-shop.com
344 Глава 5.
ложениями, например СУБД, которые самостоятельно обеспечивают оп!
тимизированные механизмы кэширования данных на уровне задачи.
Поскольку драйверы низкого уровня не используют буферный кэш, они
самостоятельно обеспечивают необходимые буферы для совершения опе!
рации ввода/вывода. На рис. 5.8 показаны отличия в характере выполнения
операции ввода/вывода с блочными устройствами в случаях, когда запрос
формируется при участии буферного кэша (драйверы блочных устройств),
и когда манипуляция буфером производится драйвером самостоятельно
(драйверы низкого уровня).
Интерфейс
системных
вызовов
Рис. 5.8. Различ%
ные типы доступа
к блочным устрой%
ствам
Буферизация
Очевидно, что побайтная передача данных между драйвером символьного
устройства и прикладным процессом весьма неэффективна. При таком
режиме работы байт должен быть сначала скопирован в адресное про!
www.books-shop.com
Символьные 345
странство драйвера, затем некоторое время должно пройти, прежде чем
драйвер сможет передать этот символ физическому устройству. Если при
этом устройство оказывается занятым, процесс должен ожидать заверше!
ния предыдущей операции, что, скорее всего, вынудит его перейти в со!
стояние сна и приведет к переключению контекста.
Существует несколько способов преодолеть данную ситуацию, но все они
предполагают обеспечение некоторой буферизации данных драйвером уст!
ройства. Первый способ заключается в использовании прерываний, когда
при поступлении на устройство следующего символа, генерируется аппарат!
ное прерывание, которое обрабатывается функцией xxintr драйвера не!
зависимо от функции xxwrite Функция обработки прерывания записы!
вает данные в буфер, которые затем считываются функцией xxwrite
Если устройство не поддерживает прерываний, их поступление можно
сэмулировать с помощью функции xxpoll драйвера устройства, которая
вызывается ядром через определенные промежутки времени (обычно каж!
дый сигнал таймера). Обычно функция в свою очередь, вызы!
вает функцию xxintr (), скажем, на каждый десятый сигнал таймера,
обеспечивая тем самым независимое считывание и буферизацию данных.
Буферизация данных для символьных устройств осуществляется с помо!
щью специальных структур данных, называемых Каждая структура
имеет следующие поля:
struct cblock
struct cblock
Поле с_сс содержит число символов в буфере cblock. Поля и
указывают, соответственно, на первый и последний элементы cblock,
организованные в виде связанного списка и фактически обеспечивающие
буферы хранения данных. Каждая структура cblock может хранить не!
сколько символов. Когда буфер хранения заполняется, ядро автоматически
выделяет новую структуру cblock и помещает ее в связанный список. По!
ля структуры cblock и их использование приведены на рис. 5.9.
64 символа
5.9. данных с помощью clist
www.books-shop.com
346 Глава 5.
Пример буферизации с использованием структуры в драйвере тер!
минала показан на рис. 5.10.
Рис. 5.10. Пример использования
буферов clist в драйвере терминала
Архитектура терминального доступа
Алфавитно!цифровой терминал — последовательное устройство, и опера!
ционная система производит обмен данными с терминалом через последо!
вательный интерфейс, называемый терминальной линией. С каждой терми!
нальной линией в UNIX ассоциирован специальный файл символьного
устройства
Терминальные драйверы выполняют ту же функцию, что и остальные
драйверы: управление передачей данных от/на терминалы. Однако терми!
В зависимости от версии UNIX вместо символов хх в имени файла терминала присутству!
ет идентификатор, позволяющий поставить в соответствии специальному файлу конкрет!
ную линию. Например, в SCO UNIX виртуальные экраны системного мо!
нитора имеют имена /dev/tty02 и т. д.
www.books-shop.com
терминального 347
налы имеют одну особенность, связанную с тем, что они обеспечивают
интерфейс пользователя с системой. Обеспечивая интерактивное исполь!
зование системы UNIX, терминальные драйверы имеют свой внутренний
интерфейс с модулями, интерпретирующими ввод и вывод строк. Модуль,
отвечающий за такую обработку, называется линии (line dis!
cipline).
Существует два режима терминального ввода/вывода:
1. Канонический режим. В этом режиме ввод с терминала обрабатывает!
ся в виде законченных строк.
2. Неканонический режим, при котором ввод не интерпретируется.
В каноническом режиме интерпретаторы строк преобразуют нест!
руктурированные последовательности данных, введенные с клавиатуры, в
каноническую форму (то есть в форму, соответствующую тому, что поль!
зователь имел в виду на самом деле) прежде, чем послать эти данные при!
нимающему процессу. Например, программисты работают на клавиатуре
терминала довольно быстро, но иногда допускают ошибки. На этот случай
имеется клавиша стирания, и пользователь имеет возможность удалять
часть введенной строки и вводить коррективы. Драйвер терминала получа!
ет всю введенную последовательность, включая и символы стирания. В
каноническом режиме модуль дисциплины линии буферизует информа!
цию в строку (набор символов, заканчивающийся символом возврата ка!
ретки) и стирает символы в буфере, прежде чем переслать исправленную
последовательность считывающему процессу. В таком режиме, например,
работает командный интерпретатор shell.
В режиме без обработки строковый интерфейс передает данные между
процессами и терминалом без каких!либо преобразований. Например,
текстовый редактор работает с драйвером в неканоническом режиме, бла!
годаря чему любой символ, введенный пользователем интерпретируется
самим процессом.
В функции модуля дисциплины линии входят:
1. Построчный разбор введенных последовательностей.
2. Обработка символов стирания.
Обработка символов удаления, отменяющих всех предыдущих символов.
4. Отображение символов, полученных терминалом.
5. Расширение выходных данных, например, преобразование символов
табуляции в последовательности пробелов.
6. Предоставление возможности не обрабатывать специальные символы,
такие как символы стирания, удаления и возврата каретки.
Существует дополнительная возможность обработки данных, получаемых
и передаваемых устройству — отображение вводимых и выводимых символов
www.books-shop.com
349 Глава 5.
в символы, определенные таблицей отображения. Данную возможность
поддерживает утилита
Псевдотерминалы
Псевдотерминалы являются специальным устройством, эмулирующим
стандартную терминальную линию. Псевдотерминалы напоминают каналы
как средство межпроцессного взаимодействия, позволяющее двум процес!
сам обмениваться данными. Однако в отличие от каналов, псевдотермина!
лы обеспечивают дополнительную функциональность, специфичную для
терминальных линий. Схематически архитектура псевдотерминала пред!
ставлена на рис.
Ярким примером использования псевдотерминалов является регистрация в
системе по сети с использованием серверов удаленного доступа
или или использование графического эмулятора терминала xterm в
системе X Window System. Когда пользователь регистрируется в системе
подобным образом, псевдотерминал эмулирует обычную терминальную
линию, поэтому пользователь не видит различия между удаленной и ло!
кальной работой с помощью терминала, подключенного по последова!
тельной линии. Например, пользователь может установить различные ре!
жимы обработки и использовать соответствующие комбинации клавиш для
генерации сигналов, как он это делает в случае обычного терминала.
Псевдотерминал по существу представляет собой два отдельных драйвера.
Один из них выглядит как обычный терминальный драйвер и носит на!
звание подчиненного устройства (slave). Второй драйвер называется основ!
ным
Рис. Взаимодействие процессов с помощью псевдотерминала
www.books-shop.com
Архитектура терминального
Поскольку подчиненное устройство имеет все характеристики терминала,
процесс может связать свои стандартные потоки ввода, вывода и вывода
ошибок с этим устройством. Однако в отличие от обычного терминала, в
случае которого запись процесса приводит к отображению данных на фи!
зическом устройстве, а ввод данных пользователем с клавиатуры может
быть получен чтением терминальной линии, все данные, записанные в
подчиненное устройство, передаются основному и наоборот — почти так,
как работает канал. Однако модуль дисциплины линии позволяет обеспе!
чить дополнительные возможности этого канала, которые могут потребо!
ваться некоторым приложениям, например, командному интерпретатору
shell.
В качестве иллюстрации использования псевдотерминала, рассмотрим
схему работы в режиме командной строки пользователя, находящегося на
некоторой удаленной системе в сети.
Пользователь удаленной системы запускает программу удаленного доступа
которая формирует запрос и передает его по сети на требуемый
компьютер. Там этот запрос доставляется серверу удаленного доступа
который (после надлежащей проверки) запускает программу
При этом стандартные потоки ввода, вывода и вывода ошибок
программы связываются не с терминальным файлом, как в случае
входа в систему с помощью сервера а с подчиненным устройст!
вом псевдотерминала. Основное же устройство оказывается связанным с
сервером Программа запрашивает имя пользователя и
его пароль точно так же, как она это делает при входе через Бо!
лее того, и "не представляет", что на самом деле работает с эмуля!
тором терминала, а не с традиционной терминальной линией. Весь ввод
поступает серверу и затем передается по сети клиентской
части на удаленном компьютере. Далее работа ничем не отличает!
ся от работы локального пользователя, подключенного к системе с помо!
щью обыкновенного терминала или консоли. Если имя пользователя и
пароль были введены правильно, программа login(l) запустит требуемый
командный интерпретатор (login shell), который также не заметит подме!
ны. Действительно, по всем характеристикам терминал будет неотличим от
традиционной последовательной линии, включая различные установки и
генерацию сигналов при нажатии определенных клавиш клавиатуры. Сле!
дует, правда, оговориться, что поскольку псевдотерминал не является
"полноценным" терминальным устройством, часть установок для него не
имеют смысла (например, скорость передачи, четность и т. д.) и просто
игнорируются.
На рис. приведена схема работы удаленного пользователя в системе с
использованием псевдотерминала.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
350 Глава 5.
Рис. Архитектура удаленного доступа с использованием псевдотерминала
Подсистема STREAMS
Архитектура подсистемы потокового ввода/вывода STREAMS впервые была
описана в статье Ритчи "Потоковая система ввода/вывода" (Ritchie, D. М.,
www.books-shop.com
STREAMS
"A Stream Input!Output System", AT&T Bell Laboratories Technical Journal,
Vol. 63, No. 8, Oct. 1984) в 1984 году. Двумя годами позднее эта система бы!
ла реализована в коммерческой версии UNIX SVR3.
Поводом для создания новой архитектуры ввода/вывода послужили не!
сколько обстоятельств.
Традиционная система ввода/вывода, ориентированная на посимвольную
передачу данных и рассмотренная ранее в этой главе, была изначально
предназначена для работы с ограниченным числом низкоскоростных асин!
хронных терминальных устройств. Операционная система взаимодействует
с такими устройствами (через точки входа в драйвер) на достаточно высо!
ком уровне, возлагая основную обработку данных на драйвер. При этом
только часть кода драйвера аппаратно зависима. Остальная обработка мо!
жет являться однотипной для широкого спектра периферийного оборудо!
вания. По мере роста числа поддерживаемых операционной системой уст!
ройств использование стандартной архитектуры подсистемы ввода/вывода
приводило к существенным накладным расходам, в частности, к неоправ!
данному дублированию кода в ядре UNIX.
Другой побудительной причиной для разработки новой подсистемы вво!
да/вывода явилось отсутствие стандартного механизма буферизации дан!
ных для символьных устройств. По мере увеличения скоростей передачи,
посимвольная обработка и передача стала неэффективной. Поэтому был
разработан ряд подходов для обеспечения буферизации, например исполь!
зование механизма, основанного на структуре рассмотренного на!
ми ранее. Однако такие схемы, по!прежнему обладая невысокой произво!
дительностью, по существу возлагают буферизацию данных на драйвер,
что приводит к неэффективному распределению памяти.
Наконец, необходимость поддержки сетевых протоколов, большинство из
которых имеют уровневую организацию, требует соответствующей архи!
тектуры подсистемы ввода/вывода. Передача сетевых данных производится
в виде пакетов или сообщений, при этом каждый уровень сетевого прото!
кола производит определенную обработку и передает их другому уровню.
Каждый уровень имеет стандартные интерфейсы взаимодействия с други!
ми (верхним и нижним уровнями) и при этом может работать с различ!
ными протоколами верхнего и нижнего уровней. Например, протокол IP
(уровень 3 модели OSI может поддерживать работу нескольких протоко!
лов верхнего уровня: TCP и UDP. На нижнем уровне протокол IP также
взаимодействует с несколькими протоколами, обеспечивая передачу дан!
ных через различные сетевые интерфейсы (например, Ethernet, Token Ring
OS1 иерархии сетевых протоколов, предложенная Международной организацией
по стандартам (ISO), включает определение функциональности для 7 уровней. Различные
семейства протоколов, например TCP/IP или SNA, имеют то или иное отображение на
эту модель. Эти вопросы рассмотрены в главе 6.
www.books-shop.com
352 Глава 5.
или последовательный канал). Такая организация сетевых протоколов
предполагает иерархическую структуру подсистемы ввода/вывода, когда
драйверы являются объединением независимых модулей.
Подсистема STREAMS в большой степени призвана решить эти задачи.
Она предоставляет интерфейс обмена данными, основанный на сообще!
ниях, и обеспечивает стандартные механизмы буферизации, управления
потоком данных и различную приоритетность обработки. В STREAMS
дублирование кода сводится к минимуму, поскольку однотипные функции
обработки реализованы в независимых модулях, которые могут быть ис!
пользованы различными драйверами. Сам драйвер обеспечивает требуемую
функциональность, связывая в цепочку один или несколько модулей, по!
добно тому как программный канал позволяет получить новое качество
обработки, связав несколько независимых утилит.
Сегодня подсистема STREAMS поддерживается большинством производи!
телей операционных систем UNIX и является основным способом реали!
зации сетевых драйверов и модулей протоколов. Использование STREAMS
охватывает и другие устройства, например терминальные драйверы в
UNIX SVR4.
Архитектура STREAMS
Подсистема STREAMS обеспечивает создание потоков — полнодуплекс!
ных каналов между прикладным процессом и драйвером С
другой стороны, архитектура STREAMS определяет интерфейсы и набор
правил, необходимых для взаимодействия различных частей этой системы
и для разработки модульных драйверов, обеспечивающих такое взаимодей!
ствие и обработку.
На рис. 5.13 показана общая архитектура коммуникационного канала меж!
ду процессом и драйвером STREAMS. Сам поток полностью располагается
в пространстве ядра, соответственно и все функции обработки данных вы!
полняются в системном контексте. Типичный поток состоит из головного
модуля, драйвера и, возможно, одного или более модулей. Головной мо!
дуль взаимодействует с прикладными процессами через интерфейс сис!
темных вызовов. Драйвер, замыкающий поток, взаимодействует непосред!
ственно с физическим устройством или псевдоустройством, в качестве ко!
торого может выступать другой поток. Модули выполняют промежуточную
обработку данных.
Процесс взаимодействует с потоком, используя стандартные системные
вызовы и ioctl(2). Дополнительные функ!
Потоковый драйвер (драйвер STREAMS) имеет архитектуру, отличную от архитектуры
драйверов символьных устройств, рассмотренных ранее.
www.books-shop.com
STREAMS 353
ции работы с потоками включают poll(2), и Передача
данных по потоку осуществляется в виде сообщений, содержащих данные,
тип сообщения и управляющую информацию. Для передачи данных каж!
дый модуль, включая головной модуль и сам драйвер, имеет две очереди —
очередь чтения (read queue) и очередь записи (write queue). Каждый модуль
обеспечивает необходимую обработку данных и передает их в очередь сле!
дующего модуля. При этом передача в очередь записи осуществляется вниз
по потоку (downstream), а в очередь чтения — вверх по потоку (upstream).
Например, на рис. 5.13 из очереди записи модуля 2 сообщение может быть
передано в очередь записи модуля 1, но не наоборот. В свою очередь со!
общение из очереди чтения модуля 2 передается в очередь чтения голов!
ного модуля, который далее передает данные процессу в ответ на систем!
ный вызов Когда процесс выполняет системный вызов
данные передаются головному модулю и далее вниз по потоку.
Рис. 5.13. Базовая архитектура потока
Сообщения также могут передаваться в парную очередь. Другими словами,
из очереди записи модуля 1 сообщение может быть направлено в очередь
www.books-shop.com
354 Глава 5.
чтения того же модуля, а затем, при необходимости, передано вверх по
потоку. При этом модулю нет необходимости знать, какой части потока
принадлежит следующая очередь — головному или промежуточному моду!
лю, или драйверу. Такой подход позволяет производить разработку моду!
лей независимо друг от друга и использовать их затем в различных комби!
нациях и в различных потоках.
Подсистема STREAMS обеспечивает возможность такой комбинации бла!
годаря механизму динамического встраивания (push) модуля в поток.
Встраивание модуля возможно непосредственно после головного модуля.
При этом будут установлены связи между соответствующими очередями
встраиваемого модуля, головного модуля и модулей вниз по потоку. После
этого встроенный модуль будет производить определенную обработку про!
ходящих данных, тем самым изменяя изначальную функциональность по!
тока. При необходимости модуль может быть извлечен (pop) из потока.
На рис. 5.14 показаны различные потоки, созданные из нескольких стан!
дартных компонентов, для поддержки сетевых протоколов семейства
TCP/IP. Причем модули IP, TCP и UDP могут поставляться одним произ!
водителем, а драйверы Ethernet или Token Ring соответствующими про!
изводителями сетевых адаптеров. В результате встраивания необходимых
модулей первый поток будет обеспечивать передачу трафика TCP через
адаптер Ethernet, в то время как второй — передачу трафика через
адаптер Token Ring.
Рис. 5.14. Использование
одних и тех же модулей для
создания различных пото%
ков
www.books-shop.com
STREAMS 355
Подсистема STREAMS также обеспечивает возможность мультиплексиро!
вания потоков. Мультиплексирующий драйвер может быть подключен к
нескольким модулям как вверх, так и вниз по потоку. Различают три типа
мультиплексоров — верхний, обеспечивающий мультиплексирование вверх
по потоку, обеспечивающий мультиплексирование вниз по пото!
ку, и поддерживающий несколько потоков выше и ниже муль!
типлексора.
С помощью мультиплексирующих драйверов потоки, представленные на
рис. 5.14, могут быть объединены в единый драйвер поддержи!
вающий несколько каналов передачи данных. Именно таким образом реа!
лизована поддержка сети во многих версиях операционной системы UNIX.
Возможная организация компонентов STREAMS приведена на рис. 5.15.
Рис. Конфигура%
ция сетевого доступа с
использованием под%
системы STREAMS
В этом случае модули TCP и UDP являются верхними мультиплексорами,
а модуль IP реализован в виде гибридного Такая органи!
зация позволяет приложениям создавать потоки, используя различные
комбинации сетевых протоколов и драйверов сетевых устройств. Задача
На самом деле мультиплексором может являться только драйвер STREAMS. Объединение
драйверов в единый объект отлично от встраивания модулей и носит название
подробно и различия между модулями и драйверами STREAMS мы рас!
смотрим несколько позже в этой главе.
www.books-shop.com
356 Глава 5.
мультиплексирующего драйвера помимо обработки данных заключается в
хранении состояния всех потоков и правильной маршрутизации данных
между ними, т. е. передаче данных в очередь требуемого модуля.
Модули
Модули являются основными компонентами потока. Каждый модуль со!
стоит из пары очередей — очереди чтения и записи, а также набора функ!
ций, осуществляющих обработку данных и их передачу вверх или вниз по
потоку. Архитектура модуля представлена на рис. 5.16.
Рис. 5.16. Модуль STREAMS
очередь представлена структурой данных queue. Наиболее важны!
ми полями queue являются:
q qinfo
q first, q last
q next
Указатель на структуру qinit, описывающую функции
обработки сообщений данной очереди.
Указатели на связанный список сообщений, ожидающих
передачи вверх или вниз по потоку.
Указатель на очередь следующего модуля вверх или вниз
по потоку.
Указатель на внутренние данные модуля (очереди).
www.books-shop.com
Подсистема 357
Помимо указанных полей, структура queue содержит параметры для обес!
печения управления потоком данных — верхнюю и нижнюю ватерлинии
очереди.
Передача данных вверх или вниз по потоку осуществляется с помощью
функций модуля, указатели на которые хранятся в структуре qinit. Мо!
дуль должен определить четыре процедуры для обработки каждой из оче!
редей: xxput и xxclose где хх, как и пре!
жде, обозначает уникальный префикс драйвера. Эти функции адресуются
указателями (*qi_putp) (*qi_srvp) (*qi_qopen)
Этих четырех функций достаточно для взаимодействия с
соседними модулями, обработки и передачи данных. Функция
xxopen вызывается каждый раз, когда процесс открывает поток или при
встраивании модуля. Соответственно функция (} вызывается при
закрытии потока или извлечении модуля. Функция xxput осуществляет
обработку сообщений, проходящих через модуль. Если xxput не может
передать сообщение следующему модулю (например, в случае, если оче!
редь следующего модуля переполнена), она помещает сообщение в собст!
венную очередь. Периодически ядро вызывает процедуру ()
каждого модуля для передачи отложенных сообщений.
Модуль должен иметь функцию xxput для каждой очереди. Функция
(} может не существовать, в этом случае xxput () не имеет
возможности отложить передачу сообщения и должна передать его немед!
ленно, даже если очередь следующего модуля переполнена. Таким образом
модули, не имеющие процедур не обладают возможностью
управления потоком данных. Эти аспекты мы подробнее рассмотрим в
следующих разделах.
Оставшиеся поля структуры qinit:
В этой структуре хранятся базовые значения таких парамет%
ров, как ватерлинии, размер сообщений и т. д. Некоторые из
этих параметров также находятся в структуре queue. Это дает
возможность динамически изменять их, сохраняя при этом
базовые значения.
Эта структура непосредственно не используется подсистемой
STREAMS. Однако модуль имеет возможность осуществлять
сбор разнообразной статистики своего участка потока с по%
мощью полей этой структуры.
Сообщения
В подсистеме STREAMS все данные передаются в виде сообщений. С по!
мощью сообщений передаются данные от приложений к драйверу и об!
ратно. Сообщения используются для взаимодействия модулей между со!
бой. Модули могут также генерировать сообщения для уведомления при!
www.books-shop.com
Глава 5.
процесса или друг друга о возникновении ошибок или непредви!
денных ситуаций. Таким образом, сообщения являются единственным
способом передачи информации между различными компонентами потока
и потому занимают ключевое место в подсистеме STREAMS.
Сообщение описывается двумя структурами данных: сообщения
msgb (message block) и заголовком блока данных (data block). Обе эти
структуры адресуют буфер данных, где находятся фактические данные со!
общения.
Заголовок сообщения msgb имеет следующие поля:
b_prev Используются для формирования связанного списка со%
общений и соответственно адресуют следующее и пре%
дыдущее сообщение очереди
Указывает на продолжение сообщения и используется
для связывания различных частей одного сообщения
Указатель на заголовок блока данных
Ь Указатели, определяющие расположение (начало и ко%
нец) данных в буфере данных
Содержит ссылку на следующую структуру msgb
Заголовок блока данных datab используется для описания буфера и имеет
следующие поля:
Адрес начала буфера
Адрес ячейки памяти, следующей непосредственно
за буфером. Таким образом, размер буфера равен
— db_base
db_type Тип сообщения
db Число заголовков сообщения, адресующих этот блок
Использование этих структур данных для формирования очереди сообще!
ний и сообщений, состоящих из нескольких частей, показано на рис.
Поле заголовка сообщения позволяет объединять несколько бло!
ков данных в одно сообщение. Эта возможность особенно полезна при
использовании подсистемы STREAMS для реализации сетевых протоко!
лов. Сетевые протоколы имеют уровневую организацию. По мере передачи
данных вниз по потоку, каждый последующий модуль (реализующий про!
токол определенного уровня) добавляет собственную управляющую инфор!
мацию. Поскольку протоколы верхнего уровня не имеют представления об
архитектуре нижних, невозможно заранее зарезервировать
память под сообщение. Вместо того чтобы изменять размер буфера данных
сообщения, модуль может добавлять управляющую информацию в виде
отдельных частей, связывая их с помощью указателя Этот процесс,
получивший название инкапсуляции данных, графически представлен на
рис. 5.18.
www.books-shop.com
STREAMS 359
5.17. Сообщения STREAMS
Поле заголовка блока данных позволяет нескольким заголовкам
сообщения совместно использовать один и тот же буфер. При этом проис!
ходит виртуальное копирование сообщения, каждая копия которого может
обрабатываться отдельно. Как правило, такой буфер используется совме!
стно только для чтения, хотя сама подсистема STREAMS не накладывает
никаких ограничений, возлагая всю ответственность за обработку данных
на модули
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
360 Глава б.
Рис. 5.18. Инкапсуляция данных с использованием составных сообщений
В качестве примера виртуального копирования можно привести реализа!
цию протокола TCP. Протокол TCP является надежным, т. е. данные счи!
таются доставленными только после того, как от получателя поступит под!
тверждение. Это означает, что протокол должен хранить копии всех от!
правленных, но не подтвержденных сообщений. Вместо неэффективного
физического копирования, производится виртуальное дублирование сооб!
щения, одна копия которого затем передается вниз по потоку (модулю IP),
а вторая сохраняется до получения подтверждения. После отправления
сообщения драйвером сетевого адаптера, одна из копий будет уничтожена,
www.books-shop.com
STREAMS 361
что выразится в уменьшении поля db_ref заголовка блока данных, но сам
блок данных сохранится, поскольку значение счетчика по!прежнему будет
превышать 0. И только после получения подтверждения станет
равным 0, и соответствующий буфер будет освобожден.
Типы сообщений
Каждое сообщение принадлежит определенному типу, определяющему
назначение сообщения и его приоритет. В зависимости от типа сообщения
попадают в одну из двух категорий: обычные сообщения и приоритетные
сообщения. Категория определяет порядок, в котором сообщения будут
обрабатываться соответствующей процедурой Приоритет!
ные сообщения всегда помещаются перед обычными сообщениями и по!
тому обрабатываются в первую очередь.
В подсистеме STREAMS определены следующие типы обычных сообще!
ний:
M_DATA Содержит обычные данные. Например, системные вызовы и
write(2) осуществляют передачу данных в виде сообщений этого типа.
Содержит управляющую информацию. Обычно сообщение этого типа
содержит также несколько блоков типа M_DATA. С помощью систем%
ных вызовов и getmsg(2) процесс имеет возможность от%
правлять и получать как управляющую часть сообщения (блок
M_PROTO), так и данные (блоки
Посылается драйверу устройства для генерации команды break.
Используется в каналах STREAMS (STREAMS pipe) для передачи
файлового указателя от одного конца канала к другому.
Генерируется модулями или драйверами и передается вверх по по%
току головному модулю для отправления процессу сигнала.
Передается драйверу устройства и указывает задержку между по%
следовательно передаваемыми символами. Как правило, использу%
ется при работе с медленными устройствами во избежание пере%
полнения их буферов.
Используется для взаимодействия модулей потока друг с другом.
Все сообщения этого типа уничтожаются головным модулем и, та%
ким образом, не могут распространяться за пределы потока.
Формируется головным модулем в ответ на управляющие команды,
переданные процессом с помощью системного вызова
И Эти
используются для создания мультиплексированных потоков. По%
следняя команда используется для управления модулями потока.
M_SETOPTS Используется для задания различных характеристик головного мо%
дуля.
Зарезервировано для внутреннего использования. Модули и драй%
веры должны передавать его без изменений.
M_BREAK
M IOCTL
www.books-shop.com
362 Глава 5. ввода/вывода
Как мы увидим далее, на передачу обычных сообщений влияет механизм
управления потоком данных, который может быть реализован модулями
потока. Этот механизм не оказывает влияния на передачу приоритетных
сообщений. Сообщения этой категории будут переданы следующему моду!
лю, независимо от того, насколько заполнена его очередь. Эти сообщения
обеспечивают основное взаимодействие между компонентами потока. Пе!
речисленные ниже сообщения являются высокоприоритетными:
Передается вверх по потоку головному модулю и указывает
ему скопировать данные от процесса для команды ioctl(2).
Сообщение допустимо в интервале между получением сооб%
щения M_IOCTL и сообщения или
Передается вверх по потоку головному модулю и указывает
ему передать данные, связанные с вызовом процессу.
Сообщение допустимо в интервале между получением сооб%
щения M_IOCTL и сообщений или
Передается вверх по потоку головному модулю и указывает
на возникновение ошибки вниз по потоку. Последующие опе%
рации с потоком будут заканчиваться ошибкой, за исключе%
нием системных вызовов close(2) и poll(2).
При получении этого сообщения модуль должен очистить
очередь (чтения, записи или обе) от сообщений.
Передается вверх по потоку головному модулю и указывает,
что драйвер не может передавать данные, обычно из%за об%
рыва линии (связи с удаленным
Подтверждение предыдущего сообщения В ответ
головной модуль возвратит необходимые данные процессу,
сделавшему системный вызов ioctl(2).
M_IOCNAK Если выполнение команды ioctl(2) закончилось неудачей, это
сообщение передается вверх по потоку головному модулю, в
ответ на это последний возвратит процессу ошибку.
M_PCPROTO Высокоприоритетная версия сообщения
Высокоприоритетная версия сообщения
M_PCRSE Зарезервировано для внутреннего использования в подсис%
теме.
Сообщение передается вниз по потоку, когда от процесса
поступает запрос на чтение, но в головном модуле отсутству%
ют данные.
Предписывает немедленно прекратить передачу.
Предписывает продолжить передачу после останова, вызван%
ного сообщением
Передача
Как уже обсуждалось, передача данных в потоке происходит в виде сооб!
щений. Процесс инициирует передачу данных с помощью системных вы!
www.books-shop.com
STREAMS 363
зовов и которые непосредственно взаимодействуют с го!
ловным модулем. Головной модуль формирует сообщение, копируя в него
прикладные данные, и передает его следующему модулю вниз по потоку. В
конечном итоге сообщение принимается драйвером, который выполняет
необходимые операции с конкретным устройством. В случае, когда драй!
вер получает данные от устройства, он также передает их в виде сообще!
ний вверх по потоку. Процесс имеет возможность получить данные с по!
мощью системных вызовов read(2) или Если в головном модуле
данные отсутствуют, процесс блокируется и переходит в состояние сна.
Сообщения передаются модулями с помощью системной функции
int *q,
Эта функция адресует очередь следующего модуля параметром q и вызы!
вает процедуру xxput этой очереди, передавая ей сообщение тр. Не
поощряется непосредственный вызов функции xxput следующего моду!
ля, поскольку это может вызвать определенные проблемы переносимости.
Передача данных внутри потока осуществляется асинхронно и не может
блокировать процесс. Блокирование процесса возможно только при пере!
даче данных между процессом и головным модулем. Таким образом,
функции обработки данных потока — xxput и xxservice не могут
блокироваться. Если процедура xxput не может передать данные сле!
дующему модулю, она помещает сообщение в собственную очередь, откуда
оно может быть передано позже процедурой Если и про!
цедура () не может осуществить передачу сообщения, напри!
мер, из!за переполнения очереди следующего модуля, она не будет ожи!
дать изменения ситуации, а вернет сообщение обратно в собственную оче!
редь и завершит выполнение. Попытка передачи повторится, когда ядро
через некоторое время опять запустит xxservice
Процедура () вызывается в системном контексте, а не в кон!
тексте процесса, который инициировал передачу данных. Таким образом,
блокирование процедуры () может заблокировать (перевести в
состояние сна) независимый процесс, что может привести к непредска!
зуемым результатам и потому недопустимо. Решение этой проблемы за!
ключается в запрещении процедурам xxput () и () блокирова!
ния своего выполнения.
Блокирование недопустимо и для драйвера. Обычно прием данных драй!
вером осуществляется с использованием прерываний. Таким образом про!
цедура xxput вызывается в контексте прерывания и не может блокиро!
вать свое выполнение.
www.books-shop.com
364 Глава 5.
Когда процедура xxput не может передать сообщение следующему мо!
дулю, она вызывает функцию имеющую следующий вид:
*q,
Функция помещает сообщение mp в очередь q, где сообщение
ожидает последующей передачи, и заносит очередь в список очередей, ну!
ждающихся в обработке. Для таких очередей ядро автоматически вызывает
процедуру Планирование вызова процедур
производится функцией ядра runqueues Функция вы!
зывается ядром в двух случаях:
Когда какой!либо процесс выполняет операцию ввода/вывода над
потоком.
Непосредственно перед переходом какого!либо процесса из режима
ядра в режим задачи.
Заметим, что планирование обслуживания очередей не связано с конкрет!
ным процессом и производится для всей подсистемы STREAMS в целом.
Функция runqueue производит поиск всех потоков, нуждающихся в
обработке очередей. При наличии таковых просматривается список очере!
дей, ожидающих обработки, и для каждой из них вызывается соответст!
вующая функция Каждая процедура в свою
очередь, пытается передать все сообщения очереди следующему модулю.
Если для каких!либо сообщений это не удается, они остаются в очереди,
ожидая следующего вызова runqueue после процесс повторяется.
Управление передачей данных
Деление процесса передачи данных на два этапа, выполняемых, соответст!
венно, функциями xxput и xxservice позволяет реализовать меха!
низм управления передачей данных.
Как уже упоминалось, обязательной для модуля является лишь функция
xxput Рассмотрим ситуацию, когда модули потока не содержат про!
цедур В этом случае, проиллюстрированном на рис. 5.19,
каждый предыдущий модуль вызывает функцию xxput следующего, пе!
редавая ему сообщение, с помощью функции ядра Функция
xxput немедленно вызывает и т. д.:
*mp)
{
Система STREAMS использует собственные функции и
ния к планированию процессов в UNIX.
www.books-shop.com
STREAMS 365
Рис. 5.19. Передача данных без
управления потоком
Когда данные достигают драйвера, он передает их непосредственно устрой!
ству. Если устройство занято, или драйвер не может немедленно обработать
данные, сообщение уничтожается. В данном примере никакого управления
потоком не происходит, и очереди сообщений не используются.
Хотя такой вариант может применяться для некоторых драйверов (как
правило, для псевдоустройств, например, в общем случае уст!
ройство не может быть все время готово к обработке данных, а потеря
данных из!за занятости устройства недопустима. Таким образом, в потоке
может происходить блокирование передачи и эта ситуация не
должна приводить к потере сообщений, во избежание которой необходим
согласованный между модулями механизм управления потоком. Для этого
сообщения обрабатываются и буферизуются в соответствующей очереди
модуля, а их передача возлагается на функцию вызываемую
ядром автоматически. Для каждой очереди две ватерлинии —
Блокирование передачи может происходить не только в драйвере (оконечном модуле)
из!за занятости устройства. Возможна ситуация, когда отдельный модуль
ден отложить обработку сообщений до наступления некоторого события.
www.books-shop.com
366 Глава 5. Подсистема
верхняя и нижняя, которые используются для контроля заполненности
очереди. Если число сообщений превышает верхнюю ватерлинию, очередь
считается переполненной, и передача сообщений блокируется, пока их
число не станет меньше нижней ватерлинии.
Рассмотрим пример потока, модули 1 и 3 которого поддерживают управ!
ление потоком данных, а модуль 2 — нет. Другими словами, модуль 2 не
имеет процедуры Когда сообщение достигает модуля 3, вы!
зывается его функция xxput После необходимой обработки сообщения,
оно помещается в очередь модуля 3 с помощью функции Если
при этом число сообщений в очереди превышает верхнюю ватерлинию,
устанавливает специальный флаг, сигнализирующий о том, что
очередь переполнена:
*q,
{
/* Необходимая обработка
}
Через некоторое время ядро автоматически запускает процедуру
xxservice модуля 3. Для каждого сообщения очереди xxput вызыва!
ет функцию которая проверяет заполненность очереди следую!
щего по потоку модуля. Функция имеет вид:
int
Заметим, что проверяет заполненность очереди следующего мо!
дуля, реализующего механизм управления передачей данных, т. е. произ!
водящего обработку очереди с помощью процедуры В про!
тивном случае, как уже говорилось, очередь модуля не принимает участия
в передаче данных. В нашем примере, проверит заполненность
очереди записи модуля 1. Функция возвращает истинное значение, если
очередь может принять сообщение, и ложное — в противном случае. В зави!
симости от результата проверки процедура либо передаст
сообщение следующему модулю (в нашем примере — модулю 2, который
после необходимой обработки сразу же передаст его модулю 1), либо вер!
нет сообщение обратно в очередь, если следующая очередь переполнена.
Описанная схема показана на рис. 5.20. Ниже приведен скелет процедуры
модуля 3, иллюстрирующий описанный алгоритм передачи
сообщений с использованием механизма управления передачей данных.
{
= !=NULL) {
if
www.books-shop.com
STREAMS 367
else
break;
Рис. 5.20. Управление потоком данных
В этом примере функция getq(9F) используется для извлечения следующего
сообщения из очереди, а функция — для помещения
в начало очереди. Если модуль 1 блокирует передачу, т. е. вер!
нет "ложно", процедура завершает свою работу, и сообщения
начинают буферизироваться в очереди модуля 3. При этом очередь вре!
менно исключается из списка очередей, ожидающих обработки, и про!
цедура xxservice () для нее вызываться не будет. Данная ситуация про!
}
}
www.books-shop.com
368 Глава 5. Подсистема
длится до тех пор, пока число сообщений очереди записи модуля 1 не ста!
нет меньше нижней ватерлинии.
Пока существует возникшая блокировка передачи, затор будет постепенно
распространяться вверх по потоку, последовательно заполняя очереди мо!
дулей, пока, в конечном итоге, не достигнет головного модуля. Поскольку
передачу данных в головной модуль (вниз по потоку) инициирует прило!
жение, попытка передать данные в переполненный головной модуль вызо!
вет блокирование и переход его в состояние сна.
В конечном итоге, модуль 1 обработает сообщения своей очереди, и их
число станет меньше нижней ватерлинии. Как только очередь модуля 1
станет готовой к приему новых сообщений, планировщик STREAMS ав!
томатически вызовет процедуры xxservice для модулей, ожидавших
освобождения очереди модуля в нашем примере — для модуля 3.
Управление передачей данных в потоке требует согласованной работы всех
модулей. Например, если процедура xxput буферизирует сообщения
для последующей обработки xxservice такой алгоритм должен выпол!
няться для всех сообщений". В противном случае, это может привести к
нарушению порядка сообщений, и как следствие, к потере данных.
Когда запускается процедура она должна обработать все
сообщения очереди. "Уважительной" причиной прекращения обработки
является переполнение очереди следующего по потоку модуля. В против!
ном случае нарушается механизм управления передачей, и очередь может
навсегда лишиться обработки.
Драйвер
Драйверы и модули очень похожи, они используют одинаковые структуры
данных (streamtab, qinit, о) и одинаковый интерфейс
(ххореп xxput ( ) , xxservice () и xxclose Однако между драйве!
рами и модулями существуют различия.
Во!первых, только драйверы могут непосредственно взаимодействовать с
аппаратурой и отвечать за обработку аппаратных прерываний. Поэтому
драйвер должен зарегистрировать в ядре соответствующий обработчик
прерываний. Аппаратура обычно генерирует прерывания при получении
данных. В ответ на это драйвер копирует данные от устройства, формирует
сообщение и передает его вверх по потоку.
Во!вторых, к драйверу может быть подключено несколько потоков. Как
уже обсуждалось, на мультиплексировании потоков построены многие
Это единственная в которой возможно блокирование процесса.
Более точно — для всех сообщений с данным приоритетом.
www.books-shop.com
STREAMS 369
подсистемы ядра, например, поддержка сетевых протоколов. В качестве
мультиплексора может выступать только драйвер. Несмотря на то что
драйвер в этом случае не является оконечным модулем (см., например,
рис. 5.15), размещение драйверов существенным образом отличается от
встраивания модулей.
Наконец, процесс инициализации драйверов и модулей различен. Функ!
ция ххореп драйвера вызывается при открытии потока, в то время как
инициализация модуля происходит при встраивании.
Головной модуль
Обработку системных вызовов процессов осуществляет головной модуль.
Головной модуль потока является единственным местом, где возможно
блокирование обработки и, соответственно, процесса, в контексте кото!
рого осуществляется операция ввода/вывода. Головной модуль является
внешним интерфейсом потока, и хотя его структура похожа на структуру
обычного модуля, функции обработки здесь обеспечиваются самой под!
системой STREAMS. В отличие от точек входа в модуль или драйвер пото!
ка, реализующих специфическую для данного устройства обработку,
функции головного модуля выполняют ряд общих для всех потоков задач,
включающих:
Трансляцию данных, передаваемых процессом с помощью систем!
ных вызовов, в сообщения и передачу их вниз по потоку.
Сообщение об ошибках и отправление сигналов процессам, связан!
ным с потоком.
Распаковку сообщений, переданных вверх по потоку, и копирование
данных в пространство ядра или задачи.
Процесс передает данные потоку с помощью системных вызовов и
Системный вызов представляющий собой унифициро!
ванный интерфейс передачи данных любым устройствам, позволяет про!
изводить передачу простых данных в виде потока байтов, не сохраняя гра!
ницы логических записей. Системный вызов предназначенный
специально для работы с потоками, позволяет процессу за один вызов пе!
редать управляющее сообщение и данные. Головной модуль преобразует
эту информацию в единое сообщение с сохранением границ записи.
Системный вызов имеет вид:
<stropts.h>
putmsg(int fildes, const struct
const struct strbuf int
С помощью этого вызова головной модуль формирует сообщение, состоя!
щее из управляющей части м PROTO и данных, передаваемых в блоках
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
370 Глава 5.
DATA. Содержимое сообщения передается с помощью указателей на
структуру strbuf — ctlptr для управляющего блока и для бло!
ков данных.
Структура strbuf имеет следующий формат:
struct strbuf {
int
int len;
void
)
где maxlen не используется, len — размер передаваемых данных, buf —
указатель на буфер.
С помощью аргумента процесс может передавать экстренные сооб!
щения, установив флаг RS_HIPRI.
В обоих случаях головной модуль формирует сообщение и с помощью
функции проверяет, способен ли следующий вниз по потоку мо!
дуль, обеспечивающий механизм управления передачей, принять его. Если
возвращает истинный ответ, сообщение передается вниз по пото!
ку с помощью функции а управление возвращается процессу.
Если возвращает ложный ответ, выполнение процесса блокирует!
ся, и он переходит в состояние сна, пока не рассосется образовавшийся за!
тор. Заметим, что возврат системного вызова еще не гарантирует, что дан!
ные получены устройством. Возврат из или свидетельствует
лишь о том, что данные были успешно скопированы в адресное пространст!
во ядра, и в виде сообщения направлены вниз по потоку.
Процесс может получить данные из потока с помощью системных вызовов
и Стандартный вызов read(2) позволяет получать только
обычные данные без сохранения границ В отличие от этого
вызова позволяет получать данные сообщений типов и
M_PROTO, при этом сохраняются границы сообщений. Например, если по!
лученное сообщение состоит из блока м PROTO и нескольких блоков
M_DATA, вызов getmsg(2) корректно разделит сообщение на две части:
управляющую информацию и собственно данные.
Вызов getmsg(2) имеет вид:
ftinclude <stropts.h>
int fildes, struct strbuf *ctlptr,
struct strbuf int
С помощью сообщения м SETOPTS можно дать указания головному модулю обрабатывать
сообщения как обычные данные. В этом случае вызов будет возвращать
содержимое сообщений так и Однако информация о сообще!
ния (данных) и границы сообщений сохранены не будут.
www.books-shop.com
STREAMS
С помощью вызова прикладной процесс может получить сообще!
ние, причем его управляющие и прикладные данные будут помещены в
буферы, адресуемые и соответственно. Так же как и в
случае эти указатели адресуют структуру которая отлича!
ется только тем, что поле определяет максимальный размер буфе!
ра, a устанавливается равным фактическому числу полученных байтов.
По умолчанию getmsg(2) получает первое полученное сообщение, однако с
помощью флага RS_HIPRI, установленного в переменной, адресуемой ар!
гументом flagsp, процесс может потребовать получение только экстрен!
ных сообщений.
В обоих случаях, если данные находятся в головном модуле, ядро извлека!
ет их из сообщения, копирует в адресное пространство процесса и воз!
вращает управление последнему. Если же в головном модуле отсутствуют
сообщения, ожидающие получения, выполнение процесса блокируется, и
он переходит в состояние сна до прихода сообщения.
Когда головной модуль получает сообщение, ядро проверяет, ожидает ли
его какой!либо процесс. Если такой процесс имеется, ядро пробуждает
процесс, копирует данные в пространство задачи и производит возврат из
системного вызова. Если ни один из процессов не ожидает получения со!
общения, оно буферизуется в очереди чтения головного модуля.
Доступ к потоку
Как и для обычных драйверов устройств, рассмотренных ранее, прежде чем
процесс сможет получить доступ к драйверу STREAMS, необходимо встро!
ить драйвер в ядро системы и создать специальный файл устройства — фай!
ловый интерфейс доступа. Независимо от того, как именно осуществляется
встраивание (статически с перекомпиляцией ядра, или динамически), для
этого используются три структуры данных, определенных для любого драй!
вера или модуля STREAMS: qinit и streamtab. Связь меж!
ду ними представлена на рис. 5.21.
Структура streamtab используется ядром для доступа к точкам входа
драйвера или модуля — к процедурам его очередей ххореп xxclose
xxput и xxservice Для этого streamtab содержит два указателя на
структуры qinit, соответственно, для обработки сообщений очереди чте!
ния и записи. Два других указателя, также на структуры qinit, использу!
ются только для мультиплексоров для обработки команды I_LINK, исполь!
зуемой при конфигурации мультиплексированного потока. Каждая струк!
тура qinit определяет процедуры, необходимые для обработки сообщений
вверх и вниз по потоку (очередей чтения и записи). Функции ххореп и
xxclose являются общими для всего модуля и определены только для
очереди чтения. Все очереди модуля имеют ассоциированную с ними про!
цедуру xxput ( ) , в то время как процедура () определяется
www.books-shop.com
372 5.
только для очередей, реализующих управление передачей. Каждая структу!
ра qinit также имеет указатель на структуру которая обыч!
но определяется для всего модуля и хранит базовые значения таких пара!
метров, как максимальный и минимальный размеры передаваемых пакетов
данных mi_minpsz), значения ватерлиний
а также идентификатор и имя драйвера (модуля) (mi_idnum,
mi_idname).
Рис. Конфигурационные данные драйвера (модуля) STREAMS
Доступ к драйверам STREAMS осуществляется с помощью коммутатора
символьных устройств — таблицы Каждая запись этой таблицы
имеет поле d_str, которое равно NULL для обычных символьных уст!
ройств. Для драйверов STREAMS это поле хранит указатель на структуру
драйвера. Таким образом, через коммутатор устройств ядро
имеет доступ к структуре streamtab драйвера, а значит и к его точкам
входа. Для обеспечения доступа к драйверу из прикладного процесса необ!
ходимо создать файловый интерфейс — т. е. специальный файл символь!
ного устройства, старший номер которого был бы равен номеру элемента
cdevsw [ адресующего точки входа драйвера.
Создание потока
Поток создается при первом открытии с помощью системного вызова
специального файла устройства, ассоциированного с драйвером STREAMS.
Как правило, процесс создает поток в два этапа: сначала создается элемен!
тарный поток, состоящий из нужного драйвера и головного модуля
www.books-shop.com
Подсистема STREAMS 373
(являющегося обязательным приложением), а затем производится встраива!
ние дополнительных модулей для получения требуемой функциональности.
Процесс открывает поток с помощью системного вызова переда!
вая ему в качестве аргумента имя специального файла устройства. При
этом ядро производит трансляцию имени и обнаруживает, что адресуемый
файл принадлежит файловой системе specfs, через которую в дальнейшем
производятся все операции работы с файлом. В памяти размещается vnode
этого файла и вызывается функция открытия файла для файловой системы
specfs — spec_open В свою очередь spec_open находит требуемый
элемент коммутатора cdevsw[] и обнаруживает, что поле ненуле!
вое. Тогда она вызывает процедуру подсистемы STREAMS stropen ко!
торая отвечает за размещение головного модуля и подключение драйвера.
После выполнения необходимых операций поток приобретает вид, изо!
браженный на рис. 5.22.
Рис. 5.22. Структура потока после открытия
www.books-shop.com
374 Глава 5.
Головной модуль представлен структурой stdata, которая выполняет роль
интерфейса между потоком и ядром системы при выполнении операций
чтения, записи и управления. Индексный дескриптор содержит ука!
затель на эту структуру. Поля структур queue головного модуля
также указывают на stdata. Поля очередей queue указывают на
структуры адресующие общие для всех головных модулей функции,
реализованные самой подсистемой STREAMS.
Очереди чтения и записи драйвера связываются с соответствующими оче!
редями головного модуля. Информация, хранящаяся в структуре
используется для заполнения полей соответствующих
структур queue драйвера указателями на процедурные интерфейсы очере!
дей чтения и записи.
В завершение вызывается функция ххореп драйвера. При последующих
операциях открытия потока функция последовательно вызовет
функции ххореп каждого модуля и драйвера, тем самым информируя
их, что другой процесс открыл тот же поток, и позволяя разместить соот!
ветствующие структуры данных для обработки нескольких каналов одно!
временно. Обычно открытие потоков производится через драйвер клонов.
После открытия потока процесс может произвести встраивание необходи!
мых модулей. Для этого используется системный вызов ioctl(2). Команда
I_PUSH этой функции служит для встраивания модулей, а команда —
для извлечения модулей из потока. Приведем типичный сценарий конст!
руирования потока:
fd =
ioctl(fd,
ioctl(fd,
I_POP, (char
ioctl(fd, I_POP, (char
В этом примере процесс открыл поток /dev/stream, а затем последователь!
но встроил модули modulel и Заметим, что команда сис!
темного вызова встраивает модуль непосредственно после голов!
ного модуля. После выполнения операций ввода/вывода, процесс извлек
модули и закрыл
Поскольку модули описываются такими же структурами данных, что и
драйверы, схемы их встраивания похожи. Как и в случае драйверов, для
заполнения полей q_qinfo структур queue используются данные из
структуры streamtab модуля. Для хранения информации, необходимой
для инициализации модуля, во многих версиях UNIX используется табли!
При закрытии потока все встроенные модули извлекаются автоматически.
www.books-shop.com
STREAMS 375
ца fmodsw [ каждый элемент которой хранит имя модуля и указатель на
структуру streamtab. После установления всех связей вызывается функ!
ция ххореп модуля.
Управление потоком
Управление потоком осуществляется прикладным процессом с помощью
команд системного вызова
ttinclude
<stropts.h>
<sys/conf.h>
int ioctl(int fildes, int command,
Хотя часть команд обрабатывается исключительно головным модулем по!
тока, другие предназначены промежуточным модулям или драйверу. Для
этого головной модуль преобразует команды ioctl(2) в сообщения и на!
правляет их вниз по потоку. При этом возникают две потенциальные про!
блемы: синхронизация процесса с системным вызовом (поскольку переда!
ча сообщения и реакция модуля имеют асинхронный характер) и передача
данных между процессом и модулем.
Синхронизацию осуществляет головной модуль. Когда процесс выполняет
системный вызов ioctl(2), который может быть обработан самим головным
модулем, последний выполняет все операции в контексте процесса, и ни!
каких проблем синхронизации и копирования данных не возникает.
Именно так происходит обработка ioctl(2) для обычных драйверов уст!
ройств. Если же головной модуль не может обработать команду, он блоки!
рует выполнение процесса и формирует сообщение содержащее
команду и ее параметры, и отправляет его вниз по потоку. Если какой!
либо модуль вниз по потоку может выполнить указанную команду, в ответ
он направляет подтверждение в виде сообщения Если ни один
из модулей и сам драйвер не смогли обработать команду, драйвер направ!
ляет вверх по потоку сообщение При получении одного из этих
сообщений головной модуль пробуждает процесс и передает ему результа!
ты выполнения команды.
При обработке сообщения промежуточным модулем или драйвером возни!
кает проблема передачи данных. Как правило, команда ioctl(2) содержит
ассоциированные с ней параметры, число и размер которых зависят от
команды. При обработке команды ioctl(2) обычным драйвером последний
имеет возможность копировать параметры из пространства задачи и по!
добным образом возвращать результаты, поскольку вся обработка команды
происходит в контексте процесса.
Эта схема неприменима для подсистемы STREAMS. Обработка сообщений
модулем или драйвером выполняется в системном контексте и не имеет
www.books-shop.com
376 Глава 5.
отношения к адресному пространству текущего процесса. Поэтому модуль
не имеет возможности копировать параметры команды и возвращать ре!
зультаты обработки, используя адресное пространство задачи.
Для преодоления этой проблемы в подсистеме STREAMS предлагаются
два подхода.
Первый из них основан на использовании специальной команды ioctl(2)
При этом в качестве параметра передается указатель на структуру
strioctl:
I_STR, (struct strioctl
struct strioctl {
int
int
int ic_len;
}
где _ фактическая команда,
_ число секунд, которое головной модуль будет
ожидать подтверждения запроса, после он
вернет процессу ошибку тайм!аута ETIME,
_ размер блока параметров команды,
ic_dp — указатель на блок параметров.
Если головной модуль не может обработать команду, он формирует сооб!
щение и копирует в него команду и блок параметров
(ic_len, ic_dp). После этого сообщение направляется вниз по потоку.
Когда модуль получает сообщение, оно содержит все необходимые данные
для обработки команды. Если команда предполагает передачу информации
процессу, модуль записывает необходимые данные в то же сообщение, из!
меняет его тип на и отправляет его вверх по потоку. В свою
очередь головной модуль получает сообщение и производит передачу па!
раметров процессу.
Другой подход получил название прозрачных команд ioctl(2) (transparent
Он позволяет использовать стандартные команды ioctl(2), решая при
этом проблему копирования данных. Когда процесс выполняет вызов
ioctl(2), головной модуль формирует сообщение и копирует в него
параметры вызова — command и arg. Обычно параметр arg является ука!
зателем на блок параметров, размер и содержимое которого известны
только модулю (или драйверу), отвечающему за обработку данной коман!
ды. Поэтому головной модуль просто копирует этот указатель, не интер!
претируя его и тем более не копируя в сообщение сам блок параметров.
Сообщение передается вниз по потоку.
www.books-shop.com
STREAMS
Когда модуль получает сообщение, в ответ он отправляет сообщение
M_COPYIN, содержащее размер и расположение необходимых для
выполнения команды. Головной модуль пробуждает процесс, вызвавший
для копирования параметров. Поскольку последующие операции
выполняются в контексте процесса, никаких проблем доступа к его адрес!
ному пространству не возникает. Головной модуль создает сообщение
M_IOCARGS, копирует в него параметры команды и направляет сообщение
вниз по потоку. После этого процесс опять переходит в состояние сна.
Когда модуль получает сообщение он интерпретирует содер!
жащиеся в нем параметры и выполняет команду. В некоторых случаях для
получения всех параметров, необходимых для выполнения команды, мо!
жет потребоваться дополнительный обмен сообщениями M_COPYIN и
M_IOCARGS. Такая ситуация может возникнуть, например, если один из
параметров являлся указателем на структуру данных. Для получения копии
структуры модулю потребуется дополнительная итерация.
После получения всех необходимых данных и выполнения команды в слу!
чае, если результат должен быть передан процессу, модуль формирует одно
или несколько сообщений M_COPYOUT, помещая в них требуемые данные,
и направляет их вверх по потоку. Головной модуль пробуждает процесс,
передавая ему результаты выполнения команды. Когда все результаты пе!
реданы процессу, модуль посылает подтверждение в результате
которого головной модуль пробуждает процесс в последний раз, завершая
тем самым выполнение вызова ioctl(2).
Мультиплексирование
Подсистема STREAMS обеспечивает возможность мультиплексирования
потоков с помощью мультиплексора, который может быть реализован
только драйвером STREAMS. Различают три типа мультиплексоров —
верхний, нижний и гибридный. Верхний мультиплексор, называемый также
мультиплексором N:l, обеспечивает подключение нескольких каналов
вверх по потоку к одному каналу вниз по потоку. Нижний мультиплексор,
называемый также мультиплексором 1:М, обеспечивает подключение не!
скольких каналов вниз по потоку к одному каналу вверх по потоку. Гиб!
ридный мультиплексор, как следует из названия, позволяет мультиплекси!
ровать несколько каналов вверх по потоку с несколькими каналами вниз
по потоку.
Расположение данных уже содержится в параметре arg, который передается обратно в
сообщении COPYIN.
www.books-shop.com
378 Глава 5.
Заметим, что подсистема STREAMS обеспечивает возможность мульти!
плексирования, но за идентификацию различных каналов и маршрутиза!
цию данных между ними отвечает сам мультиплексор.
Мультиплексирование каналов вверх по потоку осуществляется в результа!
те открытия одного и того же драйвера с различными младшими номера!
ми. Верхний мультиплексор должен обеспечить возможность одновремен!
ной работы с устройством с использованием различных младших номеров.
Если два процесса открывают поток, используя различные младшие номе!
ра, ядро создаст отдельный канал для каждого из них, каждый из них бу!
дет адресоваться отдельным vnode, и процедура ххореп драйвера будет
вызвана дважды. Драйвер при этом будет обрабатывать две пары очередей,
каждая из которых отвечает за отдельный поток. Когда данные поступают
от устройства, драйвер должен принять решение, в какую очередь чтения
их направить. Обычно такое решение делается на основании управляющей
информации, содержащейся в полученных данных. На рис. 5.23 представ!
лен вид верхнего мультиплексора с двумя подключенными потоками.
Рис. 5.23. Верхний мультиплексор
Нижний мультиплексор представляет собой драйвер псевдоустройства.
Вместо работы с физическим устройством он взаимодействует с несколь!
кими каналами вниз по потоку. Для этого нижний мультиплексор обеспе!
www.books-shop.com
Подсистема STREAMS 379
чивает работу с еще одной парой очередей — нижними очередями чтения
и записи. Структура нижнего мультиплексора адресует проце!
дурный интерфейс работы с нижними очередями соответственно полями
и st_muxwinit.
Для работы с мультиплексированными потоками подсистема STREAMS
поддерживает четыре команды
Используется для потоков. При этом файловый деск%
риптор указывает на поток, подключенный к мультиплексору. Второй
файловый дескриптор, передаваемый в качестве аргумента коман%
ды, указывает на поток, который необходимо подключить ниже муль%
типлексора.
I_PLINK Используется для потоков, которое сохраняется при
закрытии файлового дескриптора. В остальном аналогично команде
I_LINK.
I_UNLINK, Используются для разъединения потоков, созданных командами
Создание мультиплексированного потока происходит в два этапа. Пояс!
ним этот процесс на примере создания стека протокола IP, поддерживаю!
щего работу как с адаптером Ethernet, так и с адаптером FDDI. Для этого
необходимо объединить драйвер адаптера Ethernet, драйвер адаптера FDD1
и драйвер IP, который является нижним мультиплексором. Процесс дол!
жен выполнить следующие действия:
fdenet =
=
fdip =
ioctl(fdip, I_LINK, fdenet);
I_LINK,
Сначала процесс создает три независимых потока, адресуемых дескрипто!
рами fdenet, fdfddi и fdip (рис. 5.24, а) Для объединения потоков ис!
пользуется команда системного вызова В результате полу!
чается конфигурация, представленная на рис. 5.24, б.
В результате объединения потоков очереди и процедурный интерфейс го!
ловного модуля нижнего потока (в данном случае, потока, подключенного
к драйверу Ethernet или FDDI), реализованный самой подсистемой
STREAMS, заменяются на нижние очереди и соответствующий процедур!
ный интерфейс мультиплексора. Более детально процесс объединения по!
тока IP и потока Ethernet показан на рис. 5.25.
Задачей нижнего мультиплексора является хранение информации обо всех
подключенных ниже потоках и обеспечение правильной маршрутизации
между ними.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
380 Глава 5.
Рис. 5.24. Создание мультиплексированного потока
Заключение
Эта глава посвящена внутренней архитектуре подсистемы ввода/вывода,
движущей силой которой являются драйверы устройств. Были рассмотре!
ны традиционные типы драйверов, присутствующих в операционной сис!
теме UNIX с ранних ее версий, — символьные и блочные драйверы. Важ!
ную роль в процессе обмена данными с драйвером играют файловый ин!
терфейс и файловая система.
www.books-shop.com
Заключение 381
Рис. 5.25. Объединение верхнего и нижнего потоков
Во второй части главы была описана архитектура драйверов подсистемы
STREAMS, имеющая модульную структуру и позволяющая более изящно
осуществить буферизацию данных и управление их передачей. Вопросы,
затронутые в этой части, будут также рассмотрены в следующей главе при
обсуждении архитектуры сетевого доступа в операционной системы UNIX.
www.books-shop.com
сети
в операционной системе UNIX
Сегодня изолированный компьютер имеет весьма ограниченную функцио!
нальность. Дело даже не в том, что пользователи лишены возможности
доступа к обширным информационным и вычислительным ресурсам, рас!
положенным на удаленных системах. Изолированная система не имеет
требуемой в настоящее время гибкости и масштабируемости. Возможность
обмена данными между рассредоточенными системами открыла новые го!
ризонты для построения распределенных ресурсов, их администрирования
и наполнения, начиная от распределенного хранения информации (сете!
вые файловые системы, файловые архивы, информационные системы с
удаленным доступом), и заканчивая сетевой вычислительной средой.
UNIX — одна из первых операционных систем, которая обеспечила воз!
можность работы в сети. И в этом одна из причин ее потрясающего успеха
и долгожительства.
Хотя многие версии UNIX сегодня поддерживают несколько сетевых про!
токолов, в этой главе мы подробнее остановимся на наиболее известном и
распространенном семействе под названием TCP/IP. Эти протоколы были
разработаны, а затем прошли долгий путь усовершенствований для обес!
печения требований феномена XX века — глобальной сети Internet. Про!
токолы TCP/IP используются практически в любой коммуникационной
среде, от локальных сетей на базе технологии Ethernet или FDDI, до
сверхскоростных сетей ATM, от телефонных каналов точка!точка до транс!
атлантических линий связи с пропускной способностью в сотни мегабит
в секунду.
Глава начинается с описания наиболее важных протоколов семейства
TCP/IP — Internet Protocol (IP), User Datagram Protocol (UDP) и
Transmission Control Protocol (TCP). Здесь описываются стандартная спе!
цификация этих протоколов и особенности реализации их алгоритмов, не
определенные стандартами, но позволяющие значительно повысить про!
изводительность работы в сети.
Далее обсуждается программный интерфейс доступа к протоколам TCP/IP.
При этом рассматриваются два основных интерфейса — традиционный
интерфейс работы с протоколами TCP/IP — интерфейс сокетов,
www.books-shop.com
Семейство протоколов TCP/IP 383
но разработанный для системы BSD UNIX, и интерфейс ТЫ, позволяю!
щий унифицированно работать с любыми сетевыми протоколами, соответ!
ствующими модели OSI. В конце раздела описан программный интерфейс
более высокого уровня, позволяющий отвлечься от особенностей сетевых
протоколов и полностью сосредоточиться на определении интерфейса и
функциональности предоставляемых прикладных услуг. Эта система, кото!
рая называется (Remote Procedure Call — удаленный вызов процедур),
явилась предтечей современных систем разработки распределенных при!
ложений, таких как CORBA (Common Object Request Broker), Java и т. д.
В последних разделах главы рассматривается архитектура сетевого доступа
в двух основных ветвях операционной системы — BSD UNIX и UNIX
System V.
Семейство протоколов TCP/IP
В названии семейства присутствуют имена двух протоколов — TCP и IP.
Это, конечно, не означает, что данными двумя протоколами исчерпывает!
ся все семейство. Более того, как будет видно, названные протоколы вы!
полняют различные функции и используются совместно.
В 1969 году Агентство Исследований Defence Advanced Research Projects
Agency (DAPRA) Министерства Обороны США начало финансирование
проекта по созданию экспериментальной компьютерной сети коммутации
пакетов (packet switching network). Эта сеть, названная ARPANET, была
построена для обеспечения надежной связи между компьютерным обору!
дованием различных производителей. По мере развития сети были разра!
ботаны коммуникационные протоколы — набор правил и форматов дан!
ных, необходимых для установления связи и передачи данных. Так появи!
лось семейство протоколов TCP/IP. В 1983 году TCP/IP был стандартизи!
рован (MIL STD), в то же время агентство DAPRA начало финансирова!
ние проекта Калифорнийского университета в Беркли по поддержке
TCP/IP в операционной системе UNIX.
Основные достоинства TCP/IP:
О Семейство протоколов основано на открытых стандартах, свободно
доступных и разработанных независимо от конкретного оборудова!
ния или операционной системы. Благодаря этому TCP/IP является
наиболее распространенным средством объединения разнородного
оборудования и программного обеспечения.
Протоколы TCP/IP не зависят от конкретного сетевого оборудова!
ния физического уровня. Это позволяет использовать TCP/IP в фи!
зических сетях самого различного типа: Ethernet, Token!Ring,
т. е. практически в любой среде передачи данных.
www.books-shop.com
384 Глава 6. сети в операционной системе UNIX
Протоколы этого семейства имеют гибкую схему адресации, позво!
ляющую любому устройству однозначно адресовать другое устройст!
во сети. Одна и та же система адресации может использоваться как в
локальных, так и в территориально распределенных сетях, включая
Internet.
О В семейство TCP/IP входят стандартизированные высо!
кого уровня для поддержки прикладных сетевых услуг, таких как пе!
редача файлов, удаленный терминальный доступ, обмен сообщения!
ми электронной почты и т. д.
Краткая история TCP/IP
История создания и развития протоколов TCP/IP неразрывно связана с
Internet — интереснейшим достижением мирового сообщества в области
коммуникационных технологий. Internet является глобальным объедине!
нием разнородных компьютерных сетей, использующих протоколы
TCP/IP и имеющих общее адресное пространство. Явление Internet уни!
кально еще и потому, что эта глобальная сеть построена на принципах са!
моуправления (хотя ситуация отчасти начинает меняться). Однако вернем!
ся к истории.
Сегодняшняя сеть Internet "родилась" в 1969 году, когда агентство DARPA
получило заказ на разработку сети, получившей название ARPANET.
Целью создания этой сети было определение возможностей использования
коммуникационной технологии пакетной коммутации. В свою очередь,
агентство DARPA заключило контракт с фирмой Bolt, Beranek and Newman
(BBN). В сентябре 1969 года произошел запуск сети, соединивший четыре
узла: Станфордский исследовательский институт (Stanford Research
Institute), Калифорнийский университет в Санта!Барбаре (University of
California at Santa Barbara), Калифорнийский университет в Лос!Анжелесе
(University of California at Los Angeles) и Университет Юты (University of
Utah). Роль коммуникационных узлов выполняли мини!компьютеры
Honeywell 316, известные как Interface Message Processor (IMP).
Запуск и работа сети были успешными, что определило быстрый рост
ARPANET. В то же время использованием сети в своих целях заинтересо!
вались исследователи, далекие от военных кругов. Стали поступать много!
численные запросы от руководителей университетов США в Националь!
ный научный фонд (National Science Foundation, NSF) с предложениями
создания научно!образовательной компьютерной сети. В результате в 1981
году NSF одобрил и финансировал создание сети CSNET (Computer
Science Network).
В 1984 году ARPANET разделилась на две различные сети: MILNET,
предназначенную исключительно для военных приложений, и ARPANET
для использования в "мирных" целях.
www.books-shop.com
Семейство протоколов TCP/IP 385
В 1986 году фонд NSF финансировал создание опорной сети, соединившей
каналами с пропускной способностью 56 Кбит/с шесть суперкомпьютер!
ных центров США. Сеть получила название NSFNET и просуществовала
до 1995 года, являясь основной магистралью Internet. За это время пропу!
скная способность опорной сети возросла до 45 Мбит/с, а число пользова!
телей превысило 4
Стремительное развитие NSFNET сделало бессмысленным дальнейшее
существование ARPANET. В июне 1990 года Министерство обороны США
приняло решение о прекращении работы сети. Однако уроки, полученные
в процессе создания и эксплуатации ARPANET, оказали существенное
влияние на развитие коммуникационных технологий, таких как локальные
сети и сети пакетной коммутации.
При создании ARPANET был разработан и протокол сетевого взаимодей!
ствия коммуникационных узлов. Он получил название Network Control
Program (NCP). Однако этот протокол строился на предположении, что
сетевая среда взаимодействия является абсолютно надежной. Учитывая
специфику ARPANET, такое предположение являлось, мягко говоря, ма!
ловероятным: качество коммуникационных каналов могло существенно
изменяться в худшую сторону (особенно при предполагаемом использова!
нии радио! и спутниковой связи), а отдельные сегменты сети могли быть
Таким образом, подход к коммуникационной среде нуждался
в пересмотре, и, как следствие, возникла необходимость разработки новых
протоколов. Еще одной задачей, стоявшей перед разработчиками, являлось
обеспечение согласованной работы связанных сетей (internet), использую!
щих различные коммуникационные технологии (например, пакетное ра!
дио, спутниковые сети и локальные сети). Результатом исследований в
этой области явилось рождение нового семейства протоколов — Internet
Protocol (IP), с помощью которого осуществлялась базовая доставка дан!
ных в гетерогенной коммуникационной среде, и Transmission Control
Protocol (TCP), который обеспечивал надежную передачу данных между
пользователями в ненадежной сетевой инфраструктуре. Спецификации
этих протоколов в 1973 году получили статус стандартов Министерства
обороны и соответственно.
Общее число пользователей на начало 1995 года составило 4852000, из них в США —
более 3 миллионов. Уже к середине 1996 года сеть Internet имела следующие показатели:
почти миллионов хостов, 134 365 сетей, почти полмиллиона зарегистрированных доменов.
На начало 1997 года население Internet по сведениям компании Network Wizards
(http://www.nw.com) составляло 16 146 000 хостов (число записей в системе DNS), располо!
женных в 828 000 доменах. Правда, на запрос "откликнулось" в среднем около 3 миллионов
хостов.
Принимая во внимание существовавшие в то время отношения между СССР и США,
приходится констатировать, что такое вполне могло произойти. Сегодня предположение о
надежности сети также не всегда справедливо, только роль бомб и ракет исполняют
ши экскаваторов.
www.books-shop.com
386 Глава 6. Поддержка сети в операционной системе UNIX
Архитектура TCP/IP
Архитектура семейства протоколов TCP/IP основана на представлении,
что коммуникационная инфраструктура включает три объекта: процессы,
хосты, и сети. Процессы являются основными коммуникационными объ!
ектами, поскольку между процессами, в конечном итоге, осуществляется
передача информации. Выполнение процессов происходит на различных
хостах (или компьютерах). Передача информации между процессами про!
ходит через сети, к которым подключены хосты.
Подобный взгляд на вещи позволяет сделать основной вывод: чтобы дос!
тавить данные процессу, их необходимо сначала передать нужному хосту, а
затем определенному процессу, который выполняется на этом хосте. Более
того — эти две фазы могут выполняться независимо. Таким образом, от
коммуникационной инфраструктуры требуется маршрутизация и доставка
данных между хостами, а хосты, в свою очередь, обязаны обеспечить дос!
тавку нужным процессам.
Основываясь на этом простом соображении, при разработке семейства
протоколов взаимодействия логичным было четкое распределение обязан!
ностей между отдельными протоколами, представив их в виде нескольких
уровней. Разработчиками было выбрано четыре уровня:
Уровень приложений/процессов (Application/process layer)
Транспортный уровень (Host!to!host layer)
Уровень Internet (Internet layer)
Уровень сетевого интерфейса (Network interface layer)
Уровень сетевого интерфейса составляют протоколы, обеспечивающие
доступ к физической сети. С помощью этих протоколов осуществляется
передача данных между коммуникационными узлами, подключенными к
одному и тому же сетевому сегменту (например, сегменту Ethernet или ка!
налу точка!точка). Протоколы этого уровня должны поддерживаться всеми
активными устройствами, подключенными к сети (например, мостами). К
этому уровню относятся протоколы Ethernet, IEEE802.X, SLIP, PPP и т. д.
Протоколы уровня сетевого интерфейса формально не являются частью
семейства TCP/IP, однако стандарты Internet определяют, каким образом
должна осуществляться передача данных TCP/IP с использованием выше!
перечисленных протоколов.
Уровень Internet составляют протоколы, обеспечивающие передачу данных
между хостами, подключенными к различным сетям. Одной из функций,
которая должна быть реализована протоколами этого уровня, является
выбор маршрута следования данных, или маршрутизация. Сетевые элемен!
ты, осуществляющие передачу данных из одной сети в другую, получили
www.books-shop.com
Семейство протоколов TCP/IP 387
название шлюзов Шлюз имеет несколько сетевых интерфейсов,
подключенных к различным физическим сетям, и его основной задачей
является выбор маршрута передачи данных из одного сетевого интерфейса
в другой. Основной представитель уровня Internet — протокол IP.
Протоколы транспортного уровня обеспечивают передачу данных между
процессами, выполняющихся на разных хостах. Помимо этого транспорт!
ные протоколы могут реализовывать дополнительные функции, например,
гарантированную доставку, создание виртуального канала и т. д. К транс!
портному уровню относятся протоколы TCP и UDP.
Наконец, протоколы уровня приложений обеспечивают функционирова!
ние прикладных услуг, таких как удаленный терминальный доступ, копи!
рование удаленных файлов, передача почтовых сообщений и т. д. Работу
этих приложений обеспечивают протоколы Telnet, File Transfer Protocol
(FTP), Simple Mail Transfer Protocol (SMTP) и т. д.
На рис. 6.1 показана иерархическая четырехуровневая модель семейства
протоколов TCP/IP. Заметим, что протоколы уровня сетевого интерфейса,
фактически не являются частью семейства, поскольку не определены ни
стандартами Министерства обороны США, ни стандартами Internet. Вместо
этого используются существующие протоколы сети и определяются методы
передачи трафика TCP/IP с помощью данной коммуникационной техноло!
гии. Например, RFC894 (A Standard for the Transmission of IP Datagrams over
Ethernet Networks) определяет формат и процедуру передачи IP!пакетов в
сетях Ethernet, a RFC 1577(Classical IP and ARP over ATM) — в сетях ATM.
На рис. 6.2 показана базовая коммуникационная схема протоколов
TCP/IP. Коммуникационная инфраструктура может состоять из несколь!
ких физических сетей. Для передачи данных в физической сети между
подключенными хостами используется некоторый протокол уровня сете!
вого интерфейса, определенный для данной технологии передачи данных
(Ethernet, ATM и т. д.). Отдельные сети связаны между собой шлю!
зами, — устройствами, подключенными одновременно к нескольким сетям
и служащими для передачи пакетов данных из одного интерфейса в дру!
гой. Выполнение этой функции обеспечивается протоколом IP. Как видно
из рисунка, протокол IP выполняется на хостах и шлюзах и в конечном
итоге обеспечивает доставку данных от хоста!отправителя к хосту!
получателю. За обмен данными между процессами отвечают протоколы
транспортного уровня — TCP или UDP. Поскольку работа транспортных
Более точным названием этих устройств является "маршрутизатор" (router). С формальной
точки зрения термин "шлюз", применительно к данным устройствам, не совсем верен.
Модель OSI определяет шлюз, как устройство, которое может осуществлять функции пе!
редачи на всех семи уровнях (подробнее о модели будет рассказано в следующем раз!
деле). Однако в мире UNIX маршрутизаторы почему!то называют шлюзами, и мы будем
придерживаться этой терминологии.
www.books-shop.com
388 Глава 6. сети в операционной системе UNIX
протоколов обеспечивает передачу данных между удаленными процессами,
протоколы этого уровня должны быть реализованы на хостах. При этом
шлюзов для TCP или UDP как бы не существует, поскольку их присутст!
вие и работу полностью скрывает протокол IP. Наконец, процессы также
используют некоторый протокол для обмена данными, например Telnet
или FTP.
Рис. 6.1. Архитектура протоколов TCP/IP
Рис. 6.2. Коммуникационная схема TCP/IP
www.books-shop.com
Семейство протоколов TCP/IP 389
Для правильного обмена данными каждый коммуникационный узел дол!
жен иметь уникальный адрес. На самом деле, как правило, существует не!
сколько уровней адресации. Например, в локальной сети, каждый сетевой
интерфейс (первый уровень модели) имеет т. н. С помощью
этого адреса обеспечивается доставка данных требуемому получателю в
физической сети. Для доставки данных IP необходимо адресовать хост!
получатель. Для этого используется т. н. IP! или Internet!адрес. Наконец,
хост, получивший данные, должен доставить их требуемому процессу. Та!
ким образом, каждый процесс хоста, участвующий в коммуникационном
взаимодействии также имеет адрес. Этот адрес получил название номера
порта.
Таким образом, для того чтобы однозначно адресовать принимающую сто!
рону, отправитель данных должен указать адреса хоста (IP!адрес) и про!
цесса на этом хосте (номер порта). Он также должен указать, какой прото!
кол транспортного уровня будет использован при обмене данными (номер
протокола). Поскольку путь данных может проходить по нескольким фи!
зическим сегментам, физический адрес, или МАС!адрес, сетевого интер!
фейса не имеет смысла и определяется автоматически на каждом этапе
пересылки (hop) между шлюзами.
Попробуем вкратце рассмотреть процесс передачи данных от процесса
2000 (номер порта), выполняющегося на хосте А, к процессу 23, выпол!
няющемуся на хосте В. Согласно рис. 6.2 хосты расположены в разных
физических сегментах, соединенных шлюзом X. Для этого процесс 2000
передает некоторые данные модулю протокола TCP (допустим, что при!
ложение использует этот транспортный протокол), указывая, что данные
необходимо передать процессу 23 хоста В. Модуль TCP, в свою очередь,
передает данные модулю IP, указывая при только адрес хоста В. Мо!
дуль IP выбирает маршрут и соответствующий ему сетевой интерфейс
(если их несколько) и передает последнему данные, указывая шлюз X в
качестве промежуточного получателя.
Можно заметить, что наряду с передачей данных, каждый уровень обра!
ботки передает последующему некоторую управляющую информацию (IP!
адрес, номер порта и т. д.). Эта информация необходима для правильной
доставки данных адресату. Поэтому каждый протокол формирует пакет
(Protocol Data Unit, PDU), состоящий из данных, переданных модулем
верхнего уровня, и заголовка, содержащего управляющую информацию.
Эта управляющая информация распознается модулем того же уровня (peer
module) удаленного узла и используется для правильной обработки данных
и передачи их соответствующему протоколу верхнего уровня.
На рис. 6.3 схематически показан процесс обработки данных при их пере!
даче между хостами сети с использованием протоколов TCP/IP. С точки
зрения процессов 23 и 2000 между ними существует коммуникационный
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
Глава 6. сети в операционной системе UNIX
канал, обеспечивающий надежную и достоверную передачу потока дан!
ных, внутреннюю структуру которого определяют сами процессы по пред!
варительной договоренности (например, в соответствии с протоколом
Telnet). Модуль TCP хоста А обменивается сегментами данных с парным
ему модулем TCP хоста В, не задумываясь о топологии сети или физиче!
ских интерфейсах. Задача модулей TCP заключается в обеспечении досто!
верной и последовательной передачи данных между модулями приложе!
ний (процессов). TCP не интерпретирует прикладные данные и ему без!
различно, передается ли в сегменте фрагмент почтового сообщения, файл
или регистрационное имя пользователя. В свою очередь модуль IP хоста А
передает данные, полученные от транспортных протоколов, модулю IP
хоста В, не заботясь о надежности и последовательности передачи. Он не
интерпретирует данные TCP, поскольку его задача — правильно адресо!
вать отправляемую датаграмму. Поэтому модулю IP все равно, передает ли
он данные TCP или UDP, управляющие сегменты или инкапсулированные
прикладные данные.
Рис. 6.3. Обработка данных в соответствии с протоколами TCP/IP
Работу модулей TCP/IP можно сравнить со сборочным конвейером: каж!
дый участок выполняет определенную для него задачу, полагаясь на каче!
ство работы, выполненной на предыдущем этапе.
www.books-shop.com
Семейство протоколов TCP/IP 391
Общая модель сетевого взаимодействия OSI
При знакомстве с семейством протоколов TCP/IP мы отметили уровневую
структуру этих протоколов. Каждый из уровней выполняет строго опреде!
ленную функцию, изолируя в то же время особенности этой обработки и
связанные с ней данные от протоколов верхнего уровня. Четкое определе!
ние интерфейсов между протоколами соседних уровней позволяет выпол!
нять разработку и реализацию протоколов независимо, не внося измене!
ний в другие модули системы. Характерным примером является интерфейс
между протоколом IP и протоколами транспортного уровня TCP и UDP.
Хотя последние выполняют различную обработку, их взаимодействие с IP
идентично.
Развитие сетевых технологий и связанных с ними протоколов обмена дан!
ными наглядно показало необходимость стандартизации этого процесса.
Вместе с тем было очевидно, что единый стандарт на все случаи жизни не
может решить подобную задачу. Очевидно также, что коммуникационная
архитектура должна иметь модульную структуру, в которой модули обла!
дают стандартными интерфейсами взаимодействия и могут подключаться в
соответствии с этими интерфейсами, образуя "конвейер" обработки дан!
ных. Все это позволяет считать наиболее жизнеспособным подход, когда в
рамках общей модели или архитектуры сетевого взаимодействия стандар!
тизируются интерфейсы и функциональность отдельных модулей.
Такая общая модель была принята в 1983 году Международной организа!
цией по стандартизации (International Organization for Standardization, ISO),
и получила название модели взаимодействия открытых систем (Open
Systems Interconnection, OSI). Эта модель является основой для объедине!
ния разнородных компьютеров в гетерогенную сетевую инфраструктуру.
Данная архитектура определяет возможность установления соединения
между любыми двумя системами, удовлетворяющими модели и поддержи!
вающими соответствующие стандарты.
В модели OSI, как и в TCP/IP, общая функциональность системы разде!
лена на несколько уровней, каждый из которых выполняет свою часть
функций, необходимых для установления соединения с парным ему уров!
нем удаленной системы. В то же время каждый из уровней выполняет оп!
ределенную обработку реализуя набор услуг для уровня выше.
Описание услуг и формат их предоставления определяются внутренним
протоколом взаимодействия соседних уровней и определяют межуровне!
интерфейс.
Модель OSI состоит из семи уровней, краткое описание которых приведе!
но в табл. 6.1.
www.books-shop.com
392 Глава 6. сети в операционной системе UNIX
Таблица Семь уровней модели OSI
Название уровня
Уровень приложений
(Application layer)
Обеспечивает пользовательский интерфейс доступа к
распределенным ресурсам
Уровень представления
(Presentation layer)
Обеспечивает независимость приложений от различий в
способах представления данных
Уровень сеанса
(Session layer)
Транспортный уровень
(Transport layer)
Сетевой уровень
(Network layer)
Уровень канала данных
(Data link layer)
Физический уровень
(Physical layer)
Обеспечивает взаимодействие прикладных программ в
сети
Обеспечивает прозрачную передачу данных между ко%
нечными точками сетевых коммуникаций. Отвечает за
восстановление ошибок и контроль за потоком данных
Обеспечивает независимость верхних уровней от кон%
кретной реализации способа передачи данных по физи%
ческой среде. Отвечает за установление, поддержку и
завершение сетевого соединения
Обеспечивает надежную передачу данных по физиче%
ской сети. Отвечает за передачу пакетов данных — кад%
ров и обеспечивает необходимую синхронизацию, обра%
ботку ошибок и управление потоком данных
Отвечает за передачу неструктурированного потока дан%
ных по физической среде. Определяет физические ха%
рактеристики среды передачи данных
Рассмотрим процесс передачи данных между удаленными системами в
рамках модели OSI. Пусть пользователю А системы С1 необходимо пере!
дать данные приложению В системы С2. Обработка прикладных данных
начинается на уровне приложения. Уровень приложения передает обрабо!
танные данные и управляющую информацию на следующий уровень —
уровень представления и т. д., пока данные наконец не достигнут физиче!
ского уровня и не будут переданы по физической сети. Система при!
нимает эти данные и обрабатывает их в обратном порядке, начиная с фи!
зического уровня и заканчивая уровнем приложения, после чего исходные
прикладные данные будут получены пользователем В.
Для того чтобы каждый уровень правильно обработать полученные
данные, последние содержат также управляющую информацию. Эта
управляющая информация интерпретируется только тем уровнем, для ко!
торого она предназначена, в соответствии с его протоколом, и невидима
для других уровней: для верхних, потому что после обработки она удаляет!
ся, а для нижних — потому, что представляется им как обычные данные.
Благодаря этому каждый уровень по существу общается с расположенным
на удаленной системе равным (peer) ему уровнем. Таким образом, взаимо!
действие между удаленными системами можно представить состоящим из
нескольких логических каналов, соответствующих уровням модели, пере!
дача данных в каждом из которых определяется протоколом своего уровня.
www.books-shop.com
Протокол IP 393
Так физический уровень и уровень канала данных обеспечивают комму!
никационный канал сетевому уровню, который, в свою очередь, предос!
тавляет связность объектам транспортного уровня и т. д.
Нетрудно заметить, что модель TCP/IP отличается от модели OSI. На
рис. 6.4 показана схема отображения архитектуры TCP/IP на модель OSI.
Видно, что соответствие существует для уровня Internet (сетевой уровень)
и транспортного уровня. Уровни сеанса, представления и приложений OSI
в TCP/IP представлены одним уровнем приложений. Обсуждение соответ!
ствия двух моделей носит весьма теоретический характер, поэтому мы пе!
рейдем к более ценному для практики обсуждению прекрасно зарекомен!
довавших себя протоколов Internet.
TCP/IP
Уровень приложений
(Application layer)
Транспортный уровень
(Host%to%Host layer)
Уровень Internet
(Internet layer)
Уровень сетевого
(Network interface layer)
Рис. 6.4. Соответствие между моделями TCP/IF
OSI
Уровень приложений
(Application layer)
Уровень представления
(Presentation layer)
Уровень сеанса
(Session layer)
Транспортный уровень
(Transport layer)
Сетевой уровень
(Network layer)
Уровень канала данных
(Data link layer)
Физический уровень
(Physical layer)
и OSI
Протокол IP
Межсетевой протокол (Internet Protocol, IP) обеспечивает доставку фраг!
мента данных от источника к получателю через систему свя!
занных между собой сетей. В протоколе IP отсутствуют функции подтвер!
ждения, контроля передачи, сохранения последовательности передаваемых
и т. д. В этом смысле протокол IP обеспечивает потенциально
ненадежную передачу. Надежность и прочие функции, отсутствующие у
IP, при необходимости реализуются протоколами верхнего уровня. На!
пример, протокол TCP дополняет IP функциями подтверждения и управ!
ления передачей, позволяя приложениям (или протоколам более высокого
www.books-shop.com
Глава 6. сети в операционной системе UNIX
уровня) рассчитывать на получение упорядоченного потока данных, сво!
бодных от ошибок. Эта функциональность может быть реализована и про!
токолами более высокого уровня, как например это сделано в реализации
распределенной файловой системы NFS, традиционно работающей на базе
"ненадежного" транспортного протокола UDP. При этом работа NFS в це!
лом является надежной.
В рамках модели OSI протокол IP занимает 3!й уровень и, таким образом,
взаимодействует с протоколами управления передачей снизу и транспорт!
ными протоколами сверху. В рамках этой модели IP выполняет три основ!
ные функции: адресацию, фрагментацию и маршрутизацию данных.
Данные, формат которых понятен протоколу IP, носят название дата!
граммы (datagram), вид которой приведен на рис. 6.5. состоит
из заголовка, содержащего необходимую управляющую информацию для
модуля IP, и данных, которые передаются от протоколов верхних уровней
и формат которых неизвестен IP. Вообще говоря, термин
обычно используется для описания пакета данных, передаваемого по сети
без установления предварительной связи (connectionless).
Заголовок Заголовок
UDP или TCP Прикладные данные
или
ТСР%сегмент
Рис. 6.5.
Протокол IP обрабатывает каждую как самостоятельный объ!
ект, не зависящий от других передаваемых Для не!
применимы виртуальные каналы или другие логические тракты передачи.
Модули IP производят передачу по направлению к получате!
лю на основании адреса, расположенного в заголовке Вы!
бор пути передачи датаграммы называется маршрутизацией.
В процессе обработки датаграммы протокол IP иногда вынужден выпол!
нять ее фрагментацию. Фрагментация бывает необходима, поскольку путь
датаграммы от источника к получателю может пролегать через локальные
и физические сети различной топологии
и архитектуры, использующие различные размеры кадра. Например, кадр
FDDI позволяет передавать датаграммы размером до 4470 октетов, в то
время как сети Ethernet накладывают ограничение в 1500 октетов.
Заголовок IP!датаграммы, позволяющий модулю протокола выполнить
необходимую обработку данных, приведен на рис. 6.6.
www.books-shop.com
Протокол IP 395
Рис. 6.6. Заголовок
Заголовок занимает как минимум 20 октетов управляющих данных. Поле
Version определяет версию протокола и ее значение равно 4 (для IPv4).
Поле (Internet Header Length) указывает длину заголовка в 32!битных
словах. При минимальной длине заголовка в 20 октетов значение IHL бу!
дет равно 5. Это поле также используется для определения смещения, на!
чиная с которого размещаются управляющие данные протоколов верхнего
уровня (например, заголовок TCP). Поле Type of Service определяет
требуемые характеристики обработки и может принимать сле!
дующие значения:
Биты Precedence. Относительная значимость датаграммы. Это
поле может использоваться рядом сетей, при этом боль!
шее значение поля Precedence соответствует более при!
оритетному трафику (например, при перегрузке сети мо!
дуль передает только трафик со значением Precedence
выше определенного порогового значения).
Бит 3 Delay. Задержка. Значение 0 соответствует нормальной
задержке при обработке, значение 1 — низкому значению
задержки.
Бит 4 Throughput. Скорость передачи. Значение 0 соответству!
ет нормальной скорости передачи, значение 1 — высокой
скорости.
Бит 5 Reliability. Надежность. Значение 0 соответствует нор!
мальной надежности, значение 1 — высокой надежности.
Биты 6—7 Зарезервированы для последующего использования.
Поле Type of Service определяет обработку датаграммы при передаче
через различные сети от источника к получателю. В большинстве случаев
может оказаться невозможным удовлетворение сразу всех требований по
www.books-shop.com
396 Глава 6. сети в системе UNIX
обработке, предусмотренных полем Type of Service. Например, удовле!
творение требования низкого значения задержки, может сделать невоз!
можным повышение надежности передачи. Фактическое отображение па!
раметров Type of Service на процедуры обработки конкретной сети за!
висит от архитектуры этой сети. Примеры возможных отображений можно
найти в RFC 795 "Service mappings".
Поле Total Length содержит общий размер в октетах. Размер
поля (16 бит) ограничивает максимальный размер 65535
октетами.
Следующее 32!битное слово используется при фрагментации и последую!
щем реассемблировании датаграммы. Фрагментация необходима, напри!
мер, когда датаграмма отправляется из сети, позволяющей передачу паке!
тов, размер которых превышает максимальный размер пакета какой!либо
из сетей по пути следования датаграммы к получателю. В этом случае IP!
модуль, вынужденный передать "большую" датаграмму в сеть с малым раз!
мером кадра, должен разбить ее на несколько меньшего разме!
ра. Вообще говоря, модуль протокола должен обеспечивать возможность
фрагментации исходной датаграммы на произвольное число частей
(фрагментов), которые впоследствии могут быть полу!
чателем. Получатель фрагментов отличает фрагменты одной датаграммы от
другой по полю Identification. Это поле устанавливается при форми!
ровании исходной датаграммы и должно быть уникальным для каждой па!
ры источник!получатель на протяжении жизни датаграммы в сети. Поле
Fragment указывает получателю на положение данного фрагмента
в исходной датаграмме.
Поле Flags содержит следующие флаги:
Бит 0 Зарезервирован
Бит 1 DF. Значение 0 позволяет фрагментировать датаграмму. Зна!
чение 1 запрещает фрагментацию. Если в последнем случае
передача исходной датаграммы невозможна, модуль протоко!
ла просто уничтожает исходную датаграмму без уведомления
Бит 2 MF. Значение 0 указывает, что данный фрагмент является по!
следним в исходной датаграмме (в исходной датаграмме зна!
чение равно 0). Значение 1 сообщает реассемблирующему
модулю о том, что данный фрагмент исходной датаграммы не
последний
Для фрагментации датаграммы большого размера модуль протокола фор!
мирует две или более новых датаграмм и копирует содержимое заголовка
исходной датаграммы в заголовки вновь созданных. Флаг MF устанавлива!
ется равным 1 для всех датаграмм, кроме последней, для которой значение
этого флага копируется из исходной датаграммы. Данные разбиваются на
www.books-shop.com
IP 397
необходимое число частей с сохранением 64!битной границы. Соответст!
вующим образом устанавливаются значения полей Total Length и
Fragment Offset.
Получатель фрагментов, например хост, производит реассемблирование,
объединяя с равными значениями четырех полей:
Identification, адрес источника (Source Address), адрес получателя
(Destination Address) и Protocol. При этом положение фрагмента в
объединенной определяется полем Fragment
Следующее поле заголовка называется и определяет
"время жизни" датаграммы в сети. Если значение этого поля становится
равным 0, уничтожается. Каждый модуль протокола, обрабаты!
вающий датаграмму, уменьшает значение этого поля на число секунд, за!
траченных на обработку. Однако поскольку обработка датаграммы в боль!
шинстве случаев занимает гораздо меньшее время, a TTL все равно умень!
шается на 1, то фактически это поле определяет максимальное количество
хопов (число промежуточных передач через шлюзы), которое датаграмма
может совершить. Смысл этой функции — исключить возможность засо!
рения сети "заблудившимися"
Поле Protocol определяет номер протокола верхнего уровня, которому
предназначена датаграмма. Значения этого поля для различных протоко!
лов приведены в RFC 1700 "Assigned numbers", некоторые из них показаны
в табл. 6.2.
Таблица 6.2. Некоторые номера протоколов
Номер
1
2
4
6
17
46
75
Протокол
Internet Control Message Protocol,
Internet Group Management Protocol,
Инкапсуляция IP в IP
Transmission Control Protocol, TCP
User Datagram Protocol, UDP
Resource Reservation Protocol, RSVP
Packet Video Protocol, PVP
Завершает третье 32!битное слово заголовка его 16!битная контрольная
сумма/поле Header Checksum.
Поля Source Address и Destination Address содержат соответственно
адреса источника датаграммы и ее получателя. Это адреса сетевого уровня,
или IP!адреса, размер которых составляет 32 бита каждый.
Поле Options содержит различные опции протокола, а поле Padding слу!
жит для выравнивания заголовка до границы 32!битного слова.
www.books-shop.com
398 Глава 6. сети в операционной системе UNIX
Адресация
Каждый IP!адрес можно представить состоящим из двух частей: адреса
(или идентификатора) сети и адреса хоста в этой сети. Существует пять
возможных форматов IP!адреса, отличающихся по числу бит, которые от!
водятся на адрес сети и адрес хоста. Эти форматы определяют классы адре!
сов, получивших названия от А до D. Определить используемый формат
адреса позволяют первые три бита, как это показано на рис. 6.7.
сеть хост Класс А
!14! %16%
сеть хост Класс В
1 1 0 сеть хост Класс С
1 1 1 0
'
групповой адрес Класс D
Рис. 6.7. Форматы IP%адресов
Взаимосвязанные сети (internet), должны обеспечивать общее адресное
пространство. IP!адрес каждого хоста этих сетей должен быть уникальным.
На практике это достигается с использованием иерархии, заложенной в
базовый формат адреса. Некий центральный орган отвечает за назначение
номеров сетей, следя за их уникальностью, в то время как администраторы
отдельных сетей могут назначать номера хостов, также следя за уникаль!
ностью этих номеров в рамках собственной сети. В итоге — каждый хост
получит уникальный адрес. В случае глобальной сети Internet уникаль!
ность адресов также должна выполняться глобально. За назначение адре!
сов сетей отвечает центральная организация IANA, имеющая региональ!
ные и национальные представительства. При предоставлении зарегистри!
рованного адреса сети вам гарантируется его уникальность.
Адреса класса А позволяют использовать 7 бит для адресации сети, ограни!
чивая таким образом количество сетей этого класса числом Этот фор!
Вообще!то 7 бит позволяют адресовать 128 сетей, но адреса сетей 0 и 127 являются заре!
зервированными. Это же правило для адреса сети, состоящего из всех нулей или всех
единиц (в двоичном виде), справедливо и для остальных классов.
www.books-shop.com
IP 399
мат адреса напоминает формат, используемый в предтече современной гло!
бальной сети Internet — сети В те времена мало кто мог предви!
деть столь бурное развитие этих технологий и число 126 не казалось малым.
Число уникальных сетей класса В значительно больше — поскольку
адрес сети состоит из 14 бит. Однако сегодня и этого недостаточно — по!
этому адреса сетей этого класса больше не
В настоящее время выделяются сети класса С. Сетей такого класса в
Internet может быть не более 150. Но и это число сегодня нельзя на!
звать большим. При этом в каждой сети класса С может находиться не
более 254 хостов.
Популярность локальных сетей в середине 80!х годов и стремительный
рост числа пользователей Internet в последнее десятилетие привели к зна!
чительному "истощению" адресного пространства. Дело в том, что если
ваша организация использует только четыре адреса сети класса С, то ос!
тальные 250 адресов "потеряны" для сообщества Internet и использоваться
не могут. Для более эффективного распределения адресного пространства
была предложена дополнительная иерархия IP!адреса. Теперь адрес хоста
может в свою очередь быть разделен на две части — адрес подсети
(subnetwork) и адрес хоста в подсети.
Заметим, что подсети по!прежнему являются отдельными сетями для про!
токола IP, требующими наличия маршрутизатора для передачи датаграмм
из одной подсети в другую.
Для определения фактической границы между адресом подсети и хоста
используется маска сети, представляющая собой 32!битное число, маски!
рующее единицами (в двоичном виде) номера сети и подсети и содержа!
щее нули в позициях номера хоста. Модуль протокола IP производит ло!
гическую операцию "И" между маской и конкретным адресом, и таким
образом определяет, предназначена ли эта данному хосту (для
модуля протокола хоста), или датаграмма адресована непосредственно
подключенной подсети, или ее необходимо передать другому шлюзу для
последующей доставки. Использование маски сети показано на рис. 6.8.
Если хост или шлюз "не знает", какую маску использовать, он формирует
сообщение ADDRESS MASK REQUEST (запрос маски адреса) протокола
ICMP и направляет его в сеть, ожидая сообщения ADDRESS MASK
REPLY от соседнего шлюза.
Ряд IP!адресов имеют специальное значение и не могут присваиваться се!
тевым элементам (хостам, шлюзам и т. д.). Эти значения приведены в
табл. 6.3.
Конечно, в изолированной сети (или сетях), не имеющей выхода в глобальную
Internet, вы вольны использовать адреса любого класса.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
400 Глава 6. сети операционной системе UNIX
Рис. 6.8. Подсети
Адрес
Сеть:0, Хост:0
Сеть:0, Хост:Н
Сеть:1111...1
Подсеть :S
Хост:1111...1
127
Пример
Адрес:
Маска: 255.255.255.240
0.0.0.0
0.0.0.5
255.255.255.255
192.85.160.255
192.85.160.47
127.0.0.1
Таблица 6.3. Специальные IP%адреса
Интерпретация
Адрес сети: 192.85.160.0
Адрес подсети: 2
Адрес хоста: 4
Данный хост в данной сети
Определенный хост в данной сети
(только для адреса источника)
Групповой адрес всех хостов данной
подсети
Групповой адрес всех хостов всех под%
сетей сети N
Групповой адрес всех хостов подсети S
сети N
Адрес внутреннего логического хоста
Протоколы транспортного уровня
В соответствии с моделью DARPA, рассмотренной нами ранее, протоколы
транспортного уровня работают исключительно на хостах, являющихся
www.books-shop.com
транспортного уровня
точками обмена информацией — источниках или получателях датаграмм.
Поскольку основная функция шлюзов заключается в выборе пути и после!
дующей передаче которые непосредственно шлюзу не адресо!
ваны, протоколы этого уровня обычно не задействованы в шлюзах.
Два протокола этого уровня — TCP и UDP обеспечивают транспорт дан!
ных с заданными характеристиками между источником и получателем.
Поскольку на каждом хосте как правило существует несколько процессов!
получателей данных, протоколы этого уровня должны располагать необхо!
димой информацией для доставки данных требуемому протоколу уровня
приложений.
Как было показано, каждый уровень протоколов DARPA имеет собствен!
ную систему адресации. Например, для уровня сетевого интерфейса
(соответствующего физическому уровню и уровню канала данных модели
OSI) в локальных сетях используется физический адрес интерфейса. Он
представляет собой 48!битный адрес, как правило, записанный в память
платы. Для отображения физического адреса в адрес протокола верхнего
уровня (Internet) используется специальный протокол трансляции адреса
Address Resolution Protocol (ARP).
Уровень Internet (или сетевой уровень модели OSI) в качестве адресов ис!
пользует уже рассмотренные нами IP!адреса. Для адресации протокола
верхнего уровня используется поле Protocol заголовка
Протоколы транспортного уровня замыкают систему адресации DARPA.
Адреса, которые используются протоколами этого уровня и называются
номерами портов (port number), служат для определения процесса (при!
ложения), выполняющегося на данном хосте, которому адресованы дан!
ные. Другими словами, для передачи сообщения от источника к получате!
лю требуется шесть адресов — по три с каждой стороны (физический ад!
рес адаптера, IP!адрес и номер порта) — для однозначного определения
пути. Номер порта адресует конкретный процесс (приложение) и содер!
жится в заголовке TCP! или UDP!пакета. IP!адрес определяет сеть и хост,
на котором выполняется процесс, и содержится в заголовке IP!
Адрес сетевого адаптера определяет расположение хоста в фи!
зической сети.
Номера портов занимают 16 бит и стандартизированы в соответствии с их
назначением. Полный список стандартных номеров портов приведен в
RFC 1700 "Assigned Numbers". Часть из них в качестве примера приведена
в табл. 6.4.
Таблица 6.4. Некоторые стандартные номера портов
Номер порта Название Назначение (протокол уровня приложений)
7 echo Echo
20 ftp%data Передача данных по протоколу FTP
21 ftp Управляющие команды протокола FTP
www.books-shop.com
402 Глава 6. сети в операционной системе UNIX
Таблица 6.4 (продолжение)
Номер порта
23
25
53
67
68
69
70
80
110
119
123
161
179
Название
telnet
domain
bootps
bootpc
gopher
рорЗ
nntp
ntp
bgp
Назначение (протокол уровня приложений)
Удаленный доступ (Telnet)
Электронная почта (Simple Mail Transfer Protocol)
Сервер доменных имен (Domain Name Server)
Сервер загрузки Bootstrap Protocol
Клиент загрузки Bootstrap Protocol
Передача файлов (Trivial File Transfer Protocol)
Информационная система Gopher
World Wide Web (HyperText Transfer Protocol)
Электронная почта (POP версии З)
Телеконференции (Network News Transfer Protocol)
Синхронизация системных часов (Network Time
Protocol)
Менеджмент/статистика (Simple Network Manage%
ment Protocol)
Маршрутизационная информация (Border Gateway
Protocol)
User Datagram Protocol (UDP)
является протоколом транспортного уровня и, как следует из назва!
ния, обеспечивает логический коммуникационный канал между источни!
ком и получателем данных без предварительного установления связи.
Другими словами, сообщения, обрабатываемые протоколом не имеют друг
к другу никакого отношения с точки зрения Для передачи датаграмм
использует протокол IP и так же, как и последний, не обеспечивает
надежности передачи. Поэтому приложения, использующие этот транс!
портный протокол, должны при необходимости самостоятельно обеспе!
чить надежность доставки, например, путем обмена подтверждениями и
повторной передачей недоставленных сообщений.
Однако благодаря минимальной функциональности протокола UDP, пере!
дача данных с его использованием вносит гораздо меньшие накладные
расходы по сравнению, скажем, с парным ему транспортным протоколом
TCP. Размер заголовка UDP, показанного на рис. 6.9, составляет всего 8
октетов.
Первые два поля, каждое из которых занимает по 2 октета, адресуют соот!
ветственно порты источника и получателя. Указание порта источника яв!
www.books-shop.com
Протоколы транспортного уровня 403
ляется необязательным и это поле может быть заполнено нулями. Поле
Length содержит длину которая не может быть меньше 8 ок!
тетов. Поле Checksum используется для хранения контрольной суммы и
используется только если протокол верхнего уровня требует этого. Если
контрольная сумма не используется, это поле заполняется нулями. В про!
тивном случае она вычисляется по псевдозаголовку, содержащему IP!адреса
источника и получателя датаграммы и поле Protocol из IP!заголовка. Вид
псевдозаголовка представлен на рис. 6.10. То, что вычисление контроль!
ной суммы включает IP!адреса, гарантирует, что полученная
доставлена требуемому адресату. Заметим, что для протокола UDP значе!
ние поля Protocol равно 17.
Рис. 6.10. Псевдозаголовок UDP
В качестве примеров протоколов уровня приложений, которые используют
в качестве транспортного протокол UDP, можно привести:
Протокол взаимодействия с сервером доменных имен DNS, порт 53.
Протокол синхронизации времени Network Time Protocol, порт 123.
Протокол удаленной загрузки ВООТР, порты 67 и 68 для клиента и
сервера соответственно.
www.books-shop.com
404 Глава 6. сети в системе UNIX
Протокол удаленного копирования Trivial FTP порт 69.
Удаленный вызов процедур RPC, порт
Для всех перечисленных протоколов и соответствующих им приложений
предполагается, что в случае недоставки сообщения необходимые действия
предпримет протокол верхнего уровня (приложение). Как правило, прило!
жения, использующие протокол UDP в качестве транспорта, обмениваются
данными, имеющими статистический повторяющийся характер, когда поте!
ря одного сообщения не влияет на работу приложения в целом. Приложе!
ния, требующие гарантированной надежной доставки данных, используют
более сложный протокол транспортного уровня, в значительной степени
дополняющего функциональность протокола IP, — протокол TCP.
Transmisson Control Protocol (TCP)
TCP является протоколом транспортного уровня, поддерживающим на!
дежную передачу потока данных с предварительным установлением связи
между источником информации и ее получателем. На базе протокола TCP
реализованы такие протоколы уровня приложений, как Telnet, FTP или
HTTP.
Протокол TCP характеризуется следующими возможностями, делающими
его привлекательным для приложений:
Перед фактической передачей данных необходимо установление свя!
зи, т. е. запрос на начало сеанса передачи данных источником и под!
тверждение получателем. После обмена данными сеанс передачи
должен быть явно завершен.
Доставка информации является надежной, не допускающей дублиро!
вания или нарушения очередности получения данных.
Возможность управления потоком данных для избежания перепол!
нения и затора.
Доставка экстренных данных.
Эти возможности протокола позволяют протоколам верхнего уровня и,
соответственно, приложениям, их реализующим, не заботиться о надежно!
сти, последовательности доставки и т. д. Таким образом, протоколы при!
ложений, использующие TCP, могут быть значительно упрощены. С дру!
гой стороны, это ведет к сложности самого транспортного протокола и,
как следствие, к значительным накладным расходам при передаче данных.
TCP!канал представляет собой двунаправленный поток данных между со!
ответствующими объектами обмена — источником и получателем. Данные
могут передаваться в виде пакетов различной длины, называемых сегмен!
тами. Каждый TCP!сегмент предваряется заголовком, за которым следуют
www.books-shop.com
Протоколы транспортного уровня 405
данные, инкапсулирующие протоколы уровня приложения. Вид заголовка
TCP!сегмента представлен на рис.
Рис. 6.11. Формат
Положение каждого сегмента в потоке фиксируется порядковым номером
(Sequence Number), представленным соответствующим полем заголовка и
обозначающим номер первого октета сегмента в потоке TCP. Порядковые
номера также используются для подтверждения получения: каждый ТСР!
сегмент содержит номер подтверждения (Acknowledgement Number), со!
общающий отправителю количество полученных от него последовательных
данных. Номер подтверждения определяется как номер первого непод!
твержденного октета в потоке.
И порядковый номер, и номер подтверждения занимают по 32 бита в за!
головке TCP!сегмента, таким образом, их максимальное значение состав!
ляет ! 1), за которым следует 0. При установлении связи стороны до!
говариваются о начальных значениях порядковых номеров (Inintial
Sequence Number, ISN) в каждом из направлений. Впоследствии первый
октет переданных данных будет иметь номер (ISN+1).
Управление потоком осуществляется с помощью метода скользя!
щего окна (sliding window). Каждый TCP!заголовок содержит также поле
Window, которое указывает на количество данных, которое адресат готов
принять, начиная с октета, указанного в поле Acknowledgement Number.
Заголовок TCP!сегмента занимает как минимум 20 октетов. Помимо рас!
смотренных нами порядковых номеров и анонсируемого окна, он содер!
жит ряд других важных полей. Заголовок начинается с двух номеров пор!
тов, адресующих логические процессы на обоих концах виртуального ка!
нала. Далее следуют порядковый номер и номер подтверждения.
Поле смещения указывает начало данных сегмента. Это поле не!
обходимо, поскольку размер TCP!заголовка имеет переменную величину.
www.books-shop.com
Глава 6. сети в системе UNIX
Значение этого поля измеряется в 32!битных словах. Таким образом, при
минимальном размере заголовка поле будет равно 5.
Далее заголовок содержит шесть управляющих флагов Flags, каждый из
которых занимает отведенный ему бит:
Указывает, что сегмент содержит экстренные данные, и поле
Urgent pointer заголовка определяет их положение в сегменте.
Указывает, что заголовок содержит подтверждение полученных дан%
ных В поле Acknowledgement Number.
PSH Указывает, что данные должны быть переданы
немедленно, не ожидая заполнения сегмента максимального раз%
мера.
Указывает на необходимость уничтожения канала.
SYN Указывает, что сегмент представляет собой управляющее сообще%
ние, являющееся частью "тройного рукопожатия" для синхронизации
порядковых номеров при создании канала.
Указывает, что сторона прекращает передачу данных и желает за%
крыть виртуальный канал.
Поле контрольной суммы Checksum используется для защиты от ошибок.
Контрольная сумма вычисляется на основании псевдозаго!
ловка, содержащего, в частности IP!адреса источника и получателя, а так!
же номер протокола. Цель включения в контрольную сумму части заго!
ловка IP та же, что и для протокола UDP — дополнительно защитить дан!
ные от получения не тем адресатом.
Поле Urgent Pointer позволяет указать расположение экстренных дан!
ных внутри сегмента. Это поле используется при установленном флаге URG
и содержит порядковый номер октета, следующего за экстренными дан!
ными.
В конце заголовка располагается поле Options переменной длины, кото!
рое может содержать различные опции, например, максимальный размер
сегмента (MSS). Это поле дополняется нулями (Padding) для того, чтобы
заголовок всегда заканчивался на границе 32 бит.
Состояния TCP[сеанса
Как уже говорилось, передача данных с использованием протокола TCP
предусматривает предварительное установление связи, или создание логи!
ческого TCP!канала. Эта предварительная фаза призвана усилить надеж!
ность протокола. В процессе этой фазы определяется начало TCP!потоков
в обоих направлениях, их характеристики (например, максимальный раз!
мер окна), в это же время могут быть обнаружены "полуразрушенные"
TCP!каналы прошлых сеансов передачи, некорректно закрытые, напри!
www.books-shop.com
Протоколы транспортного уровня 407
мер, ввиду аварийного останова одной из сторон. Стороны выбирают про!
извольные начальные порядковые номера потоков, чтобы уменьшить ве!
роятность обработки сегментов, принадлежащих "старым"
Начальная фаза сеанса передачи получила название "тройное рукопожа!
тие" (three!way handshake), которое достаточно точно отражает процесс
обмена служебными сегментами между сторонами. Этот процесс является
— одна из сторон, называемая клиентом, инициирует на!
чало сеанса, посылая другой стороне — серверу сегмент Как правило
этот сегмент является числом служебным, т. е. не содержит полезных дан!
ных, его заголовок определяет номер порта и начальный порядковый но!
мер потока клиент!сервер. Если сервер готов принять данные от клиента,
он создает логический канал (размещая соответствующие структуры дан!
ных) и отправляет клиенту сегмент с установленным начальным порядко!
вым номером потока сервер!клиент и флагами SYN и АСК, подтверждаю!
щий получение сегмента SYN и выражающего готовность сервера к полу!
чению данных. Наконец, и это третье рукопожатие, клиент отвечает сег!
ментом с установленным флагом АСК, подтверждающим получение ответа
от сервера и тем самым завершающим фазу создания TCP!канала. Процесс
установления связи в TCP!сеансе представлен на рис.
После этого обе стороны начинают передачу TCP!сегментов, каждый из
которых содержит подтверждение полученных данных и новое значение
окна. Начиная с подтвержденного октета, источник может передать, не
дожидаясь количество данных, определенных значением
окна. Если отправитель не получает подтверждения на посланные данные
в течение определенного промежутка времени, он полагает, что данные
утеряны, и их передача повторяется, начиная с последнего подтвержден!
ного октета. Поскольку надежность передачи гарантируется протоколом,
для данных приложения, переданных, но не подтвержденных, протокол
хранит копию, которая уничтожается после получения подтверждения или
вновь передается при отсутствии такового. Получение дублированных
данных также подтверждается, хотя сами данные уничтожаются, поскольку
дублирование могло быть вызвано неполучением подтверждения. Если од!
на из сторон получает неупорядоченные данные, они, как правило, сохра!
няются до получения недостающих последовательных сегментов. Разуме!
ется, получение таких неупорядоченных данных не подтверждается, по!
В условиях модули TCP хранят последние использованные порядковые номера.
Поэтому при создании нового канала (сеанса) модуль выбирает следующее из ад!
ресного пространство порядковых номеров (которое составляет При скорости
2 Мбит/с потребуется 4,5 часа для передачи данных, адресуемых этими номерами (поряд!
ковыми и подтверждений). Это время на несколько порядков превышает время жизни ТСР!
сегмента в сети, по умолчанию составляет 2 секунды. Это гарантирует, что новые
номера не "догонят" номера старых сегментов. Даже при скорости 100 Мбит/с полный цикл
использования порядковых номеров составляет чуть больше 5 минут.
Сегмент SYN имеет установленный флаг SYN в заголовке — отсюда и его название.
www.books-shop.com
408 Глава 6. сети в операционной системе UNIX
скольку подтверждение отправляется только на полученный непрерывный
последовательный поток октетов.
Рис. 6.12. Установ%
ление связи, переда%
ча данных и заверше%
ние TCP%сеанса
Завершение сеанса в TCP происходит в несколько этапов. Любая из сто!
рон может завершить передачу данных, отправив сегмент с установленным
флагом FIN (рис. 6.12). Получение такого сегмента подтверждается другой
стороной и эквивалентно достижению конца файла при его чтении. Одна!
ко другая сторона может продолжать передавать данные, также впоследст!
вии завершив передачу сегментом FIN. Подтверждение этого сегмента
полностью разрушает канал и завершает сеанс. Для того чтобы гарантиро!
вать синхронизацию завершения сеанса, сторона, отправившая подтвер!
ждение на последний сегмент FIN, должна поддерживать сеанс достаточно
долго, чтобы иметь возможность вновь подтвердить повторные сегменты
FIN данного сеанса в случае, когда подтверждение не было получено дру!
гой стороной.
www.books-shop.com
Протоколы транспортного уровня
На рис. также проиллюстрированы состояния коммуникационных уз!
лов TCP!канала.
Как видно из рисунка, начальное состояние узла (сервера или клиента) —
состояние CLOSED. Готовность сервера к обработке инициирующих запро!
сов от клиента определяется переходом его в состояние LISTEN. С этого
момента сервер может принимать и обрабатывать инициирующие сеанс сег!
менты SYN. При отправлении такого сегмента клиент переходит в состояние
SYN!SENT и ожидает ответного запроса от сервера. Сервер при получении
сегмента также отправляет сегмент SYN с подтверждением АСК и переходит в
состояние SYN!RECEIVED. Подтверждение от клиента завершает
"рукопожатие" и сеанс переходит в состояние ESTABLISHED. После завер!
шения обмена данными одна из сторон (например, клиент) отправляет сег!
мент FIN, переходя при этом в состояние Приняв этот сегмент
другая сторона (например, сервер) отправляет подтверждение АСК и перехо!
дит в состояние CLOSE!WAIT, при этом канал становится симплексным —
передача данных возможна только в направлении от сервера к клиенту. Ко!
гда клиент получает подтверждение он переходит в состояние FIN!WAIT!2,
в котором находится до получения сегмента FIN. После подтверждения по!
лучения этого сегмента канал окончательно разрушается.
Расшифровка состояний приведена в табл. 6.5.
Таблица 6.5. Состояния TCP%сеанса
LISTEN Готовность узла к получению запроса на соединение от лю%
бого удаленного узла.
SYN%SENT Ожидание ответного запроса на соединение.
SYN%RECEIVED Ожидание подтверждения получения ответного запроса на
соединение.
ESTABLISHED Состояние канала, при котором возможен дуплексный обмен
данными между клиентом и сервером.
CLOSE%WAIT Ожидание запроса на окончание связи от локального про%
цесса, использующего данный коммуникационный узел.
LAST%ACK Ожидание подтверждения запроса на окончание связи, от%
правленного удаленному узлу. Предварительно от удаленно%
го узла уже был получен запрос на окончание связи и канал
стал симплексным.
FIN%WAIT%1 Ожидание подтверждения запроса на окончание связи, от%
правленного удаленному узлу (инициирующий запрос, канал
переходит в симплексный режим).
FIN%WAIT%2 Ожидание запроса на окончание связи от удаленного узла
CLOSING Ожидание подтверждения от удаленного узла на запрос
окончания связи.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
4/0 Глава 6. в операционной системе UNIX
Таблица 6.5 (продолжение)
TIME%WAIT Таймаут перед окончательным разрушением канала, доста%
точный для того, чтобы удаленный узел получил подтвержде%
ние своего запроса окончания связи. Величина тайм%аута
составляет 2 MSL (Maximum Segment
CLOSED Фиктивное состояние, при котором коммуникационный узел и
канал фактически не существуют.
Для обеспечения правильной обработки данных для каждого логического
TCP!канала хранится полная информация о его состоянии, различных
таймерах и о текущих порядковых номерах переданных и принятых окте!
тов. Это необходимо, например, для корректной обработки служебных
сегментов SYN и
Передача данных
После создания виртуального канала взаимодействующие процессы полу!
чают возможность обмениваться данными в дуплексном режиме.
Хотя фактически передача данных осуществляется в виде сегментов, ее
логический вид представляет собой последовательный поток октетов, каж!
дый из которых адресуется порядковым номером. Каждый сегмент хранит
в заголовке порядковый номер первого октета данных. Данные буферизи!
руются обоими коммуникационными узлами TCP!канала. Как правило,
модуль TCP самостоятельно принимает решение, когда именно сформиро!
вать сегмент для отправки и когда передать полученные данные процессу!
адресату.
В случае, когда требуется немедленная передача данных, без ожидания за!
полнения сегмента определенного размера, протокол верхнего уровня
(приложение) устанавливает флаг PSH, который указывает модулю TCP на
необходимость немедленной доставки данных, находящихся в очереди на
отправление. Это может потребоваться, например, при передаче пользова!
тельского ввода при удаленном доступе (протокол Telnet).
Как уже говорилось, протокол TCP обеспечивает надежный последова!
тельный виртуальный канал передачи данных между приложениями.
Значение MSL, рекомендованное в RFC 793 "Transmission Control Protocol", составляет
2 минуты. Однако в реальных системах типичными значениями MSL являются 30 секунд,
1 или 2 минуты.
Эта информация представлена соответствующими структурами данных, называемыми ТСВ
(Transmission Control Block). Как правило, коммуникационный узел, представляющий се!
тевой интерфейс для взаимодействующих процессов, хранит указатель на эти управляю!
щие данные. Более подробно архитектура сетевых интерфейсов UNIX описана в следую!
щих разделах.
www.books-shop.com
транспортного уровня
скольку нижележащий сетевой протокол IP является по определению не!
надежным, а среда передачи вносит дополнительные ошибки, переданные
данные могут быть утеряны, продублированы или испорчены, при этом
порядок их доставки может быть нарушен. В случае ошибочности полу!
ченного сегмента модуль TCP узнает об этом, проверив контрольную сум!
му. Другие ошибки являются более сложными, и TCP должен обеспечить
их определение и исправление.
Рассмотренные выше порядковый номер и номер подтверждения играют
ключевую роль в обеспечении надежности доставки. По существу поряд!
ковый номер адресует каждый октет логического потока данных между
источником и получателем, позволяя последнему определить правильность
доставки (порядок доставки и потерю отдельных октетов). TCP является
протоколом с позитивным подтверждением и повторной передачей
(Positive Acknowledgement and Retransmission, PAR). Это означает, что если
данные доставлены без ошибок, получатель подтверждает это сегментом
АСК. Если отправитель не получает подтверждения в течение некоторого
времени, он повторно посылает данные. В любом случае отсутствует нега!
тивное подтверждение (NAK).
В качестве примера рассмотрим передачу данных между двумя хостами
сети А и В, проиллюстрированную на рис. 6.13. Для простоты предполо!
жим симплексную передачу большого количества данных от хоста А к В.
Начиная с хост А посылает хосту В 200 октетов. Первый послан!
ный сегмент доставлен без ошибок и подтвержден хостом В
(АСК=301). Следующий сегмент передан с ошибкой и не доставлен полу!
чателю. Таким образом, хост А не получает подтверждения на второй сег!
мент и повторно посылает его после определенного В конеч!
ном итоге все данные, переданные хостом А будут получены и подтвер!
ждены хостом В.
Говоря об управлении потоком данных, следует отметить, что TCP пред!
ставляет собой протокол со скользящим окном. Окно определяет объем
данных, который может быть послан (send window — окно передачи) или
получен (receive window — окно приема) TCP!модулем. Размеры окон
фактически отражают состояние буферов приема коммуникационных уз!
лов. Так окно приема свидетельствует о количестве данных, которое при!
нимающая сторона готова получить, а окно передачи определяет количе!
ство данных, которое отправителю позволяется послать, не ожидая под!
тверждения о получении. Несомненно, между этими двумя параметрами
существует связь — окно передачи одного узла отражает состояние буфе!
На самом деле ситуация, скорее всего, окажется более печальной, поскольку хост А про!
должит отправку последующих сегментов в пределах окна отправки, не дожидаясь под!
тверждений. Не получив подтверждения на второй сегмент, хост А по вынужден
будет повторно передать все сегменты, начиная со второго. Более подробно мы рассмот!
рим этот аспект в разделе "Стратегии реализации TCP" далее в этой главе.
www.books-shop.com
412 Глава 6. в операционной системе UNIX
ров другого (его окно приема) и наоборот. Принимающая сторона имеет
возможность изменять окно передачи отправителя помощью подтвер!
ждения или явного обновления значения окна в поле Window заголовка
передаваемого сегмента), и, таким образом, регулировать трафик.
Рис. 6.13. Повторная передача
Интерпретация отправителем окна передачи показана на рис. 6.14. Размер
окна передачи отправителя в данном случае покрывает с 4 по 8 байт. Это
означает, что отправитель получил подтверждения на все байты, включая
3, а получатель анонсировал размер окна равным 5 байтам. Это также оз!
начает, что отправитель может еще передать 2 байта (7 и 8). По мере под!
тверждения получения данных окно будет смещаться вправо, открывая
новые "горизонты" для передачи. Однако окно может изменять свои раз!
меры, при этом имеет значение, смещение какого края окна (правого или
левого) приводит к изменению размера.
Окно закрывается по мере смещения левого края вправо. Это проис!
ходит при отправлении данных.
Окно открывается по мере смещения правого края вправо. Это про!
исходит в соответствии с освобождением буфера приема получателя
данных.
www.books-shop.com
Протоколы транспортного уровня 413
Окно сжимается, когда правый край смещается влево. Хотя такое
поведение не рекомендуется, модуль TCP должен быть готов к обра!
ботке этой ситуации.
Если левый край окна достигает правого, размер окна становится равным
нулю, что запрещает дальнейшую передачу данных.
Рис. 6.14. Окно передачи TCP
Суммируя вышесказанное, можно отметить, что размер окна, сообщаемый
получателем данных отправителю, является предлагаемым окном (offered
window), которое в случае равно размеру свободного места в
буфере приема. При получении этого значения отправитель данных вы!
числяет фактическое, доступное для окно (usable window), ко!
торое равно предлагаемому за вычетом объема отправленных, но не под!
твержденных данных. Таким образом, доступное для использования, или
просто доступное, окно меньше или равно предлагаемому. Неэффективная
стратегия подтверждений может привести к чрезвычайно малым значени!
ям доступного окна и, как следствие, к низкой производительности пере!
дачи данных. Это явление, известное под названием синдром "глупого окна"
(Silly Window Syndrome, SWS), будет рассмотрено ниже.
Стратегии реализации TCP
Рассмотренный стандарт протокола TCP определяет взаимодействие между
удаленными объектами, достаточное для обеспечения совместимых реали!
заций. Другими словами, модуль протокола, в точности следующий спе!
цификации стандарта, является гарантированно совместимым с модулями
TCP, разработанными другими производителями. Тем не менее ряд во!
просов функционирования протокола остается за рамками стандарта и
допускает различные реализации, в конечном итоге влияющие не на со!
вместимость, а на производительность приложений, использующих этот
протокол. В данном разделе мы рассмотрим различные подходы к реали!
зации TCP, направленные на повышение его производительности.
www.books-shop.com
Глава 6. в операционной системе UNIX
Синдром "глупого окна"
Механизм подтверждения получения данных является ключевым в прото!
коле TCP. Стандарт указывает, что подтверждение должно быть передано
без задержки, но не определяет конкретно, насколько быстро данные
должны быть подтверждены, и объем подтверждаемых данных. К сожале!
нию, корректная с точки зрения спецификации протокола, но неопти!
мальная реализация стратегии подтверждения приводит к неудовлетвори!
тельной работе механизма управления потоком данных (оконного меха!
низма), что приводит к синдрому "глупого окна" (SWS).
Для иллюстрации этого явления рассмотрим передачу файла большого
размера между двумя приложениями, использующими протокол TCP. До!
пустим, что модуль протокола осуществляет передачу сегментами, размер
которых составляет 200 октетов. В начале передачи предлагаемое окно от!
правителя — 1000 октетов. Он полностью использует этот кредит, послав
пять сегментов по 200 октетов каждый. После обработки первого получен!
ного сегмента адресат отправляет подтверждение (сегмент которое
также содержит обновленное значение предлагаемого окна. Предположим,
что адресат передал полученные данные приложению, и таким образом его
буфер приема вновь содержит 1000 байтов свободного места. Поэтому об!
новленное значение окна будет также равным 1000 октетов. Эта ситуация
показана на рис. 6.15.
При получении подтверждения отправитель вычисляет доступное окно.
Поскольку получение 800 октетов данных еще не подтверждено, значение
доступного окна получается равным 200.
Рассмотрим теперь процесс возникновения SWS. Предположим, что от!
правитель вынужден передать сегмент размером 50 октетов (например, ес!
ли приложение указало флаг PSH). Таким образом, он отправляет 50 бай!
тов, и вслед за этим следующий сегмент, размером 150 октетов (поскольку
размер доступного окна равен 200). Через некоторое время адресат полу!
чит 50 байтов, обработает их и подтвердит получение, не изменяя значе!
ния предлагаемого окна (1000 октетов). Однако теперь при вычислении
доступного окна, отправитель обнаружит, что не подтверждены 950 бай!
тов, и, таким образом, его окно равняется всего 50 октетам. В результате
отправитель вновь вынужден будет передать всего 50 байтов, хотя прило!
жение этого уже не требует.
Если мы продолжим анализировать передачу данных, то заметим, что ри!
сунок транзакций будет периодически повторяться, т. е. отправитель будет
вынужден периодически передавать сегмент необоснованно малого разме!
ра. Этот порочный круг не может быть разорван естественным образом.
Происхождение сегментов малого размера очевидно: периодически у от!
правителя возникает необходимость разделить доступное окно на несколь!
ко мелких сегментов. При непрерывной передаче больших объемов дан!
ных такие ситуации будут время от времени возникать, оставляя неизгла!
www.books-shop.com
Протоколы транспортного уровня
след на характере транзакций. В результате это может привести к
"засорению" сети множеством мелких пакетов в одну сторону и множест!
вом подтверждений в другую.
6.15. Возникновение SWS
Описанный синдром может также порождаться и принимающей стороной,
которая анонсирует чересчур маленькие окна. Таким образом, для преодо!
ления этих ситуаций, необходима модификация алгоритмов TCP как для
отправления, так и для приема данных. К легко избежать,
обязав модули выполнять следующие правила:
1. Принимающая сторона не должна анонсировать маленькие окна. Го!
воря более конкретно, адресат не должен анонсировать размер окна,
www.books-shop.com
416 Глава 6. сети в операционной системе UNIX
больший текущего (который скорее всего равен 0), пока последний не
может быть увеличен либо на размер максимального сегмента
(Maximum Segment Size, MSS), либо на 1/2 размера буфера приема, в
зависимости от того, какое значение окажется меньшим.
2. Отправитель должен воздержаться от передачи, пока он не сможет пе!
редать сегмент максимального размера или сегмент, размер которого
больше половины максимального размера окна, который когда!либо
анонсировался принимающей стороной.
Однако как мы уже заметили, анализируя причины возникновения SWS,
поспешные подтверждения полученных данных сыграли не последнюю
роль в этом процессе. С одной стороны, немедленное подтверждение по!
зволяет постоянно держать отправителя "в курсе дела", тем самым избегая
ненужных повторных передач. Подтверждение также приводит к смеще!
нию окна, и таким образом, позволяет отправителю продолжить передачу
данных. С другой стороны, немедленное подтверждение может привести к
возникновению SWS и дополнительным накладным расходам.
Хорошим компромиссом между немедленным и отложенным подтвержде!
нием можно считать следующую схему. При получении сегмента адресат
не отправляет подтверждение, если, во!первых, сегмент не содержит флага
PSH (дающего основание полагать, что вслед за полученным сегментом
вскоре последуют дополнительные данные), и, во!вторых, отсутствует не!
обходимость отправки обновленного значения окна.
Тем не менее получатель должен установить таймер, который позволит
послать подтверждение, если в передаче данных произошел определенный
перерыв, что может быть вызвано, например, потерей сегментов.
Медленный старт
Старые реализации TCP начинали передачу, отправляя сегменты в преде!
лах предлагаемого окна, не дожидаясь подтверждения. Это вызывало
рост трафика в сети и могло привести к переполнению, в
результате которого часть сегментов отбрасывалась и требовалась повтор!
ная передача.
Алгоритм, направленный на избежание подобной ситуации, получил на!
звание медленного старта (slow start). Основная идея, лежащая в основе
этого алгоритма, заключается в том, что на начальном этапе передачи сег!
менты должны отправляться со скоростью, пропорциональной скорости
получения
Реализация этого алгоритма предусматривает использование дополнитель!
ного к рассмотренным ранее окна отправителя — окна переполнения
(congestion window). При установлении связи с адресатом значение этого
окна устанавливается равным одному сегменту (значению MSS,
анонсированному адресатом, или некоторому значению по умолчанию,
www.books-shop.com
Протоколы транспортного уровня 417
обычно 536 или 512 байтов). При вычислении доступного окна отправи!
тель использует меньшее из предлагаемого окна и окна переполнения.
Каждый раз, когда отправитель получает подтверждение полученного сег!
мента, его окно переполнения увеличивается на величину этого сегмента.
Легко заметить, что предлагаемое окно служит для управления потоком со
стороны получателя, в то время как окно переполнения служит для управ!
ления со стороны отправителя. Если первое из них связано с наличием
свободного места в буфере приема адресата, то второе — с представлением
о загрузке сети у отправителя данных.
Обычно предлагаемое окно больше одного сегмента, поэтому отправитель
передает один сегмент и ожидает подтверждения. Когда подтверждение
приходит, он увеличивает значение окна переполнения до двух сегментов,
таким образом, два сегмента разрешены к передаче. После того как полу!
чение каждого из этих сегментов подтверждено, размер окна переполне!
ния становится равным четырем сегментам. Можно показать, что по мере
отправления сегментов и получения подтверждений размер окна перепол!
нения растет экспоненциально, соответственно растет и эффективная ско!
рость
Начиная с некоторого значения скорость передачи достигнет эффективной
пропускной способности виртуального канала между источником и полу!
чателем, и ее дальнейший рост приведет к потере данных. Начиная с этого
момента, включается механизм устранения заторов, который будет обсуж!
ден ниже.
Устранение затора
Переполнение, или затор, может возникнуть в сети по многим причинам.
Например, если данные поступают к шлюзу по высокоскоростному каналу
и должны быть переданы в низкоскоростной канал. Или данные несколь!
ких каналов мультиплексируются в один канал, пропускная способность
которого меньше суммы входящих. Во всех этих случаях неизбежна потеря
пакетов.
Алгоритмы, позволяющие избежать заторов, основываются на предполо!
жении, что потеря данных, вызванная ошибками передачи по физической
среде, пренебрежимо мала (гораздо меньше 1%). Следовательно, потеря
вывести формулу изменения размера окна, предполагая, что время передачи данных
от отправителя к получателю и обратно (Round Trip Time, гораздо больше времени пе!
редачи сегмента отправителем. Здесь параметр sz равен размеру сегмента (например,
cwndo = sz
= cwndo + =
= =
www.books-shop.com
Глава 6. в операционной UNIX
данных свидетельствует о заторе, произошедшем где!то на пути следова!
ния пакета. В свою очередь, о потере данных отправитель может судить по
двум событиям: значительной паузе в получении подтверждения или полу!
чении дубликата(ов) подтверждения.
Хотя устранение затора и медленный старт являются независимыми меха!
низмами, каждый из которых имеет свою цель, обычно они реализуются
совместно. Для их работы необходимо два дополнительных параметра вир!
туального окно переполнения cwnd и порог медленного старта
ssthresh. Работа комбинированного алгоритма определяется следующим
правилам:
1. Начальные значения cwnd и ssthresh инициализируются равными
размеру одного сегмента и 65535 байтов соответственно.
2. Максимальное количество данных, которое может передать отправи!
тель, не превышает меньшего из значений окна переполнения и пред!
лагаемого окна.
При возникновении затора (что определяется по тайм!ауту или полу!
чению дубликатов подтверждений) параметр ssthresh устанавливает!
ся равным половине текущего окна, но не меньше размера двух сег!
ментов. Если же свидетельством затора является тайм!аут, то дополни!
тельно размер cwnd устанавливается равным одному сегменту, или,
другими словами, включается медленный старт.
4. Когда отправитель получает подтверждение, он увеличивает размер
cwnd, однако новый размер зависит от того, выполняет ли модуль
медленный старт или устранение затора.
Если значение cwnd меньше или равно ssthresh, то TCP находится в фа!
зе медленного старта, в противном случае производится устранение затора.
Таким образом, режим медленного старта продолжается до тех пор, пока
эффективная скорость передачи не достигнет половины скорости, при ко!
торой был обнаружен После этого включается процедура устране!
ния затора.
Как мы только что видели, медленный старт начинается с отправления
одного сегмента, затем двух, затем четырех и т. д., что порождает экспо!
ненциальный рост размера окна. В фазе устранения затора вычисление
Для простоты мы рассматриваем несимметричный виртуальный канал, в котором данные
передаются в одну сторону, а управляющие сообщения (подтверждения, обновления окна
и т. д.) передаются в обратную сторону. Эти рассуждения легко могут быть распростране!
ны и на случай полнодуплексного канала, когда каждая из сторон одновременно является
и получателем и отправителем данных.
Поскольку скорость передачи определяется текущим окном, половина размера окна, со!
храненная в ssthresh, определяет 1/2 скорости, при которой произошел затор.
www.books-shop.com
Протоколы уровня 419
нового значения cwnd производится по следующей формуле при каждом
подтверждении
= +
Таким образом, формула дает зависимость роста размера окна, при кото!
рой максимальная скорость приращения составит не более одного сегмен!
та за время передачи данных туда и обратно (Round Trip Time, неза!
висимо от того, сколько подтверждений было получено. Это утверждение
легко доказать. Допустим, в какой!то момент времени размер окна состав!
лял Тогда отправитель может передать максимум сегмен!
тов размером sz, на которые он получит такое же число подтверждений.
Можно показать, что
cwndn+i cwndn + = + sz
На рис. 6.16 показан рост окна переполнения при медленном старте и по!
следующем устранении затора. Заметим, что переход в фазу устранения
затора происходит при превышении размером окна порогового значения
ssthresh.
Рис. 6,16. Рост окна переполне%
ния при медленном старте и устра%
нении затора
Повторная передача
До сих пор рассматривалось получение дублированных подтверждений как
свидетельство потери сегментов и затора в сети. Однако согласно RFC
"Requirements for Internet Hosts — Communication Layers", модуль TCP
Предполагается, что получатель подтверждает каждый сегмент. На самом деле это не так, и в
этом случае приращение производится фактически на число подтвержденных сегментов.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
420 Глава 6. сети в операционной системе UNIX
может отправить немедленное подтверждение при получении неупорядо!
ченных сегментов. Цель такого подтверждения — уведомить отправителя,
что был получен неупорядоченный сегмент, и указать порядковый номер
ожидаемых данных. Поскольку ожидаемый порядковый номер остался
прежним (получение неупорядоченного сегмента не изменит его значе!
ние), данное подтверждение может явиться дубликатом уже отправленного
ранее.
Таким образом, получение дублированных подтверждений может быть вы!
звано двумя причинами: потерей сегмента, как следствием затора в сети, и
получением неупорядоченного сегмента. Чтобы установить истинную при!
чину, модуль TCP ждет получения еще нескольких дублированных под!
тверждений. Если причина в получении неупорядоченного сегмента, вы!
званном буферизацией на промежуточных шлюзах или различными путя!
ми передачи датаграмм, то, вероятнее всего, вскоре ожидаемый сегмент
будет получен и порядок будет восстановлен, что выразится в получении
нового (уже не дубликата) подтверждения. Если получено три или более
дубликатов, следует полагать, что произошла потеря данных. В этом слу!
чае отправитель совершает повторную передачу утраченного сегмента. Эта
процедура получила название быстрой повторной передани (fast retransmit).
При этом, включается механизм устранения затора, но не медленный
старт. Причиной такого поведения является то, что получение сегмента,
хотя и не упорядоченного, свидетельствует об относительно невысоком
уровне переполнения в сети, и необходимость в столь радикальных мерах,
как медленный старт, отсутствует.
Однако потеря данных может вызвать ответное молчание. Для обработки
подобной ситуации отправитель должен установить таймер и повторно пе!
редать данные по тайм!ауту, начиная с последнего подтверждения. Дан!
ный механизм является запасным и гарантирует повторную передачу, хотя
и вызывает довольно большие задержки.
Программные интерфейсы
Программный интерфейс сокетов
Вы уже познакомились с интерфейсом сокетов при обсуждении реализа!
ции межпроцессного взаимодействия в BSD UNIX. Поскольку сетевая
поддержка впервые была разработана именно для BSD UNIX, интерфейс
сокетов и сегодня является весьма распространенным при создании сете!
вых приложений. В разделе "Поддержка сети в BSD UNIX" мы вновь вер!
немся к сокетам, когда будем рассматривать внутреннюю архитектуру се!
тевой подсистемы в UNIX ветви BSD. Сейчас же рассмотрим простой
пример приложения клиент!сервер, который демонстрирует возможности
сокетов при обеспечении взаимодействия между удаленными процессами.
Несмотря на то что взаимодействие затрагивает передачу данных по сети,
www.books-shop.com
Программные интерфейсы
приведенная программа мало отличается от примера, рассмотренного в
разделе "Межпроцессное взаимодействие в BSD UNIX. главы 3.
Логика приложения сохранена — клиент отправляет серверу сообщение,
сервер передает его обратно, а клиент, в свою очередь, выводит получен!
ное сообщение на экран. Наиболее существенным отличием является
коммуникационный домен сокетов — в данном случае AF_INET. Соответ!
ственно изменилась и схема адресации коммуникационного узла. Соглас!
но схеме адресации TCP/IP, коммуникационный узел однозначно иденти!
фицируется двумя значениями: адресом хоста (IP!адрес) и адресом про!
цесса (адрес порта). Это отражает и структура которая явля!
ется конкретным видом общей структуры адреса сокета sockaddr. Струк!
тура sockaddr_in имеет следующий вид:
struct {
short
u_short Номер порта
struct IPадрес хоста
char
Адрес порта должен быть предварительно оговорен между клиентом и сер!
вером.
В заключение, прежде чем перейти непосредственно к текстам программы,
заметим, что интерфейс сокетов также поддерживается и в UNIX System
V, наряду с другим программным интерфейсом — ТЫ, который будет рас!
смотрен в следующем разделе.
Приведенный пример в качестве транспортного протокола использует
TCP. Это значит, что перед передачей прикладных данных клиент должен
установить соединение с сервером. Эта схема, приведенная на рис. 6.17,
несколько отличается от рассмотренной в разделе "Межпроцессное взаи!
модействие в BSD UNIX. Сокеты", где передача данных осуществлялась
без предварительного установления связи и в данном случае соответство!
вала бы использованию протокола UDP.
В соответствии с этой схемой сервер производит связывание с портом,
номер которого предполагается известным для клиентов и сооб!
щает о готовности приема запросов При получении запроса он с
помощью функции accept(2) создает новый сокет, который и обслуживает
обмен данными между клиентом и сервером. Для того чтобы сервер мог
продолжать обрабатывать поступающие запросы, он порождает отдельный
процесс на каждый поступивший запрос. Дочерний процесс, в свою оче!
редь, принимает сообщения от клиента и передает их обратно
Клиент не выполняет связывания, поскольку ему безразлично, какой адрес
будет иметь его коммуникационный узел. Эту операцию выполняет систе!
www.books-shop.com
422 Глава 6. сети в операционной UNIX
ма, выбирая свободный адрес порта и установленный адрес хоста. Далее
клиент направляет запрос на установление соединения указы!
вая адрес сервера (IP!адрес и номер порта). После установления соедине!
ния ("тройное рукопожатие") клиент передает сообщение прини!
мает от сервера ответ и выводит его на экран.
Рис. 6.17. Схема установления связи и передачи данных между клиентом и сервером
В программе используются несколько функций, которые не рассматрива!
лись. Эти функции значительно облегчают жизнь программисту, выпол!
няя, например, такие действия, как трансляцию доменного имени хоста в
его IP!адрес приведение в соответствие порядка следо!
вания байтов в структурах данных, который может различаться для хоста и
сети а также преобразование IP!адресов и их составных частей
в соответствии с привычной "человеческой" нотацией, например
Мы не будем подробнее останавливаться на этих функци!
www.books-shop.com
Программные интерфейсы 423
ях, предоставляя читателю самостоятельно обратиться к соответствующим
разделам электронного справочника
Ниже приведены тексты программ сервера и клиента.
Сервер
ftinclude
linclude
ftinclude <stdio.h>
<fcntl.h>
<netdb.h>
/*Номер порта сервера, известный
#define 1500
argv)
int
char
{
int s, ns;
int pid;
int nport;
struct sockaddr_in serv_addr,
struct hostent
char
/*Преобразуем порядок следования байтов к сетевому
nport = PORTNUM;
nport =
/*Создадим сокет, использующий протокол
SOCK_STREAM,
{
вызова
}
/*3ададим адрес коммуникационного
=
=
=
/*Свяжем сокет с этим
sockaddr
{
вызова
}
сообщение с указанием адреса
"Сервер
/*Сервер готов принимать запросы на установление соединения.
Максимальное число запросов, ожидающих обработки 5. Как правило,
www.books-shop.com
424 Глава 6. сети в операционной системе UNIX
этого числа достаточно, чтобы успеть выполнить и
породить дочерний
{
вызова
}
цикл получения запросов и их
while (1)
{
int addrlen;
addrlen =
/*Примем запрос. Новый сокет ns становится коммуникационным узлом
созданного виртуального
(struct sockaddr
{
вызова accept
}
информацию о
"Клиент =
/*Создадим процесс для работы с
{
вызова
}
{
int nbytes;
int
этот сокет нам не Он попрежнему
используется для получения
close
/*Получим сообщение от клиента и передадим его
while = recv(ns, buf,
!=0)
{
buf, 0);
}
exit (0)
}
этот сокет нам не нужен. Он используется
дочерним процессом для обмена
}
www.books-shop.com
интерфейсы 425
Клиент
ttinclude
<stdio.h>
<fcntl.h>
<netdb.h>
порта, который обслуживается
idefine 1500
argv)
char
int
{
int s
int
int ;
struct sockaddr_in
struct hostent
char
/*B качестве аргумента клиенту передается доменное имя хоста, на
котором запущен сервер. Произведем трансляцию доменного имени в
{
вызова
}
=
=
/*Создадим сокет*/
{
вызова
}
"Адрес
/*Создадим виртуальный
if (struct sockaddr
{
вызова
}
/*0тправим серверу сообщение и получим его
buf,
www.books-shop.com
426 Глава 6. в UNIX
if (recv(s, buf, sizeof(buf), 0) <0)
{
вызова
}
полученное сообщение на
от сервера:
close
завершил работу
}
Программный интерфейс TLI
При обсуждении реализации сетевой поддержки в BSD UNIX был рас!
смотрен программный интерфейс доступа к сетевым ресурсам, основан!
ный на В данном разделе описан интерфейс транспортного уровня
(Transport Layer Interface, TLI), который обеспечивает взаимодействие
прикладных программ с транспортными протоколами.
ТЫ был впервые представлен в UNIX System V Release 3.0 в 1986 году.
Этот программный интерфейс тесно связан с сетевой подсистемой UNIX,
основанной на архитектуре STREAMS, изолируя от прикладной програм!
мы особенности сетевой архитектуры. Вместо того чтобы непосредственно
пользоваться общими функциями STREAMS, рассмотренными в преды!
дущей главе, ТЫ позволяет использовать специальный набор вызовов,
специально предназначенных для сетевых приложений. Для преобразова!
ния вызовов ТЫ в функции интерфейса STREAMS используется библио!
тека ТЫ, которая в большинстве систем UNIX имеет название libnsl.a или
Схема использования функций ТЫ во многом сходна с рассмотренным
интерфейсом сокетов и зависит от типа используемого протокола —
с предварительным установлением соединения (например, TCP) или без
него (например, UDP).
На рис. 6.18 и 6.19 представлены схемы использования функций ТЫ для
транспортных протоколов с предварительным установлением соединения
и без установления соединения. Можно отметить, что эти схемы очень
похожи на те, с которыми мы уже встречались в разделе "Межпроцессное
взаимодействие в BSD UNIX. главы 3 при обсуждении сокетов.
Некоторые различия отмечены ниже при описании функций ТЫ.
Прежде чем перейти к обсуждению функций ТЫ, остановимся на опреде!
лении адреса коммуникационного узла. ТЫ не накладывает никаких огра!
ничений на формат адреса, возлагая интерпретацию на протоколы
нижнего уровня. Благодаря этому, один и тот же интерфейс может быть
использован при работе с различными семействами сетевых протоколов.
www.books-shop.com
Программные интерфейсы 427
Для определения адреса ТЫ предоставляет общую структуру данных
netbuf, имеющую вид:
struct netbuf {
unsigned int maxlen;
unsigned int len;
char
}
Рис. 6.18. Схема вызова функций TLI для протокола с предварительным установ%
лением соединения
Поле buf указывает на буфер, в котором может передаваться адрес узла,
maxlen определяет его размер, a len — количество данных в буфере, т. е.
размер адреса. Эта структура по своему назначению похожа на структуру
sockaddr, которая является общим определением адреса коммуникацион!
ного узла для Далее рассматривается пример сетевого приложе!
www.books-shop.com
428 Глава 6. сети в операционной UNIX
ния, основанного на ТЫ, где показано, как netbuf используется при пе!
редаче адреса для протоколов TCP/IP.
Рис. 6.19. Схема вызова функций TLI для протокола без предварительного
установления соединения
Структура netbuf используется в ТЫ для хранения не только адреса, но и
другой информации — опций протокола и прикладных данных. Эта струк!
тура является составной частью более сложных структур данных, исполь!
зуемых при передаче параметров в функциях ТЫ. Для упрощения дина!
мического размещения этих структур библиотека ТЫ предоставляет две
функции: для размещения структуры и для освобож!
дения памяти. Эти функции имеют следующий вид:
char fd, int int fields ) ;
int *ptr, int
Аргумент struct_type определяет, для какой структуры данных выделя!
ется память. Он может принимать следующие значения:
www.books-shop.com
Программные интерфейсы 429
Значение поля struct_type Структура данных
T_BIND struct t_bind
T_CALL struct t_call
T_DIS struct t_discon
T_INFO struct t_info
struct
struct t_unitdata
T_UDERROR struct t_uderr
Co структурами, приведенными в таблице, мы познакомимся при обсуж!
дении функций ТЫ. Большинство из них включают несколько элементов
Поскольку в некоторых случаях может отсутствовать необходи!
мость размещения всех элементов поле fields позволяет указать,
какие конкретно буферы необходимо разместить для данной структуры:
Значение поля fields Размещаемые и инициализируемые поля
Все необходимые поля
T_ADDR Поле addr В структурах t_bind, t_call, t_unitdata,
t_uderr
Поле opt в структурах t_call, t_uderr,
Поле udata в структурах t_call, t_unitdata,
Отметим одну особенность. Фактический размер буфера и, соответствен!
но, структуры netbuf зависят от значения поля maxlen этой структуры. В
свою очередь, этот параметр зависит от конкретного поставщика транс!
портных услуг — именно он определяет максимальный размер адреса, оп!
ций и прикладных данных. Чуть позже мы увидим, что эта информация
ассоциирована с транспортным узлом и может быть получена после его
создания с помощью функции Поэтому для определения фак!
тического размера размещаемых структур в функции необходим
аргумент d, являющийся дескриптором транспортного узла, который воз!
вращается процессу функцией
Перейдем к основным функциям ТЫ.
Как видно из рис. 6.18 и в качестве первого этапа создания коммуни!
кационного узла используется функция Как и системный вы!
зов она возвращает дескриптор, который в дальнейшем адресует
узел в функциях ТЫ. Функция имеет вид:
<tiuser.h>
<fcntl.h>
int char int struct
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
430 Глава 6. сети в операционной UNIX
Аргумент path является именем специального файла устройства, являю!
щегося поставщиком транспортных услуг, например, /dev/tcp или
Аргумент of lags определяет флаги открытия файла и соответст!
вует аналогичному аргументу системного вызова ореп(2). Приложение мо!
жет получить информацию о поставщике транспортных услуг в структуре
info, имеющей следующие поля:
addr
options
connect
discon
servtype
Определяет максимальный размер адреса транспортного протоко%
ла. Значение %1 говорит, что размер не ограничен, %2 означает, что
прикладная программа не имеет доступа к адресам протокола.
Протокол TCP устанавливает размер этого адреса (адрес порта)
равным
Определяет размер опций для данного протокола. Значение %1
свидетельствует, что размер не ограничен, %2 означает, что при%
кладная программа не имеет возможности устанавливать опции
протокола.
Определяет максимальный размер пакета данных протокола
(Transport Service Data Unit, TSDU). Нулевое значение означает, что
протокол не поддерживает пакетную передачу (т. е. не сохраняет
границы записей). Значение %1 свидетельствует, что размер не ог%
раничен, %2 означает, что передача обычных данных не поддержи%
вается. Поскольку протокол TCP обеспечивает передачу неструкту%
рированного потока данных, значение tsdu для него равно 0. На%
против, UDP поддерживает пакетную передачу.
Определяет максимальный размер пакета экстренных данных про%
токола (Expedited Transport Service Data Unit, ETSDU). Нулевое зна%
чение означает, что протокол не поддерживает пакетную передачу
(т. е. не сохраняет границы записей). Значение %1 свидетельствует,
что размер не ограничен, %2 означает, что передача экстренных
данных не поддерживается. TCP обеспечивает такую поддержку, а
UDP % нет.
Некоторые протоколы допускают передачу прикладных данных
вместе с запросом на соединение. Поле connect определяет мак%
симальный размер таких данных. Значение %1 свидетельствует, что
размер не ограничен, %2 означает, что данная возможность не под%
держивается. И TCP и UDP не поддерживают этой возможности.
Определяет то же, что и connect, но при запросе на прекращение
соединения. И TCP и UDP не поддерживают этой возможности.
Определяет тип транспортных услуг, предоставляемых протоколом.
Значение означает передачу с предварительным установ%
лением соединения, T_COTS_ORD — упорядоченную передачу с
предварительным установлением соединения, — передачу
без предварительного установления соединения. Протокол TCP
обеспечивает услугу T_COTS_ORD, a UDP — т CLTS.
www.books-shop.com
Программные интерфейсы
Прежде чем передача данных будет возможна, транспортному узлу должен
быть присвоен адрес. Эта фаза называется операцией связывания и мы уже
сталкивались с ней при разговоре о в главе 3 и при обсуждении
сетевой поддержки в BSD UNIX ранее в этой главе. В рассмотренных слу!
чаях связывание выполнял вызов В ТЫ для этого служит функция
имеющая вид:
int const struct t_bind *req,
struct t_bind
Аргумент fd адресует коммуникационный узел. Аргумент req позволяет
программе явно указать требуемый адрес, а через аргумент ret возвраща!
ется значение, установленное протоколом.
Два последних аргумента описываются структурой t_bind, имеющей сле!
дующие поля:
struct addr Адрес
unsigned Максимальное число запросов на установление связи, ко%
торые могут ожидать обработки. Имеет смысл только для
протоколов с предварительным установлением соединения
Рассмотрим три возможных формата аргумента req:
req == NULL Позволяет поставщику транспортных услуг самому вы%
брать подходящий адрес
req != NULL Позволяет поставщику транспортных услуг самому
== 0 брать подходящий адрес, но определяет максимальное
число запросов на установление связи, которые могут
ожидать обработки
req ! = NULL Явно указывает требуемый адрес и максимальное число
len > 0 запросов на установление связи, которые могут ожидать
обработки
Во всех случаях фактическое значение адреса возвращается в структуре
ret. Даже если программа явно указала требуемый адрес, необходимо
проверить, совпадает ли он с адресом, указанным в ret.
Для протоколов с предварительным установлением соединения програм!
ме!клиенту необходимо использовать функцию отправляю!
щую запрос на создание соединения с удаленным транспортным узлом.
Функция имеет вид:
<tiuser.h>
int fd, const struct t_call
struct t_call
Аргумент содержит информацию, необходимую поставщику
транспортных услуг для создания виртуального канала. Формат этой ин!
формации описывается структурой t call, имеющей следующие поля:
www.books-shop.com
432 Глава 6. сети в операционной системе UNIX
struct netbuf Адрес удаленного транспортного узла
struct netbuf opt Требуемые опции протокола
struct netbuf udata Прикладные данные, отправляемые вместе с управляю%
щей информацией (запрос на установление соединения
или подтверждение)
int sequence в данном случае не имеет смысла
Через аргумент программе возвращается информация о виртуаль!
ном канале после его создания: адрес удаленного узла, опции и приклад!
ные данные, переданные удаленным узлом. Как уже отмечалось, ни TCP,
ни UDP не позволяют передавать данные вместе с управляющей инфор!
мацией. Программа может установить значение rcvcall равным NULL,
если информация о канале ее не интересует.
Обычно возврат из функции происходит после окончатель!
ного установления соединения, когда виртуальный канал готов к передаче
данных (конечно, в случае успешного завершения).
Для протоколов с предварительным установлением соединения програм!
ма!сервер вызывает функцию блокируя свое выполнение до
получения запроса на создание виртуального канала.
#include <tiuser.h>
int fd, struct
Информация, возвращаемая транспортным протоколом в аргументе call,
содержит параметры, переданные удаленным узлом с помощью соответст!
вующего вызова его адрес, установленные опции протокола,
а также, в ряде случаев, прикладные данные, переданные вместе с запро!
сом. Поле sequence аргумента call содержит уникальный идентификатор
данного запроса.
Хотя t_listen(3N), несмотря на название, напоминает функцию accept(2),
используемую для сокетов, сервер должен выполнить вызов другой функ!
ции — для того, чтобы фактически принять запрос и устано!
вить соединение. Функция имеет вид:
ftinclude <tiuser.h>
int fd, int connfd, struct t_call
Аргумент fd адресует транспортный узел, принявший запрос (тот же, что
и для функции Аргумент connfd адресует транспортный узел,
для которого будет установлено соединение с удаленным узлом. За созда!
ние нового транспортного узла отвечает сама программа (т. е. необходим
явный вызов функции при этом fd может по!прежнему ис!
пользоваться для обслуживания поступающих запросов.
Как и в случае через аргумент передается информация об
удаленном транспортном узле.
www.books-shop.com
Программные интерфейсы 433
После возврата из функции t_accept(3N) между двумя узлами и
удаленным узлом!клиентом) образован виртуальный канал, готовый к пе!
редаче прикладных данных.
Для обмена прикладными данными после установления соединения ис!
пользуются две функции: для получения и t_snd(3N) для переда!
чи. Они имеют следующий вид:
ttinclude <tiuser.h>
int t_rcv(int char *buf, unsigned nbytes, int
int t_snd(int fildes, char *buf, unsigned nbytes, int flags);
Первые три аргумента соответствуют аналогичным аргументам системных
вызовов и Аргумент flags функции t_snd(3N) может со!
держать следующие флаги:
T_EXPEDITED Указывает на отправление экстренных данных
T_MORE Указывает, что данные составляют логическую запись, продолже%
ние которой будет передано последующими вызовами
Напомним, что TCP обеспечивает неструктурированный поток и,
следовательно, не поддерживает данной возможности
Эту информацию принимающий узел получает с помощью t_rcv(3N) также
через аргумент flags.
Для протоколов без предварительного установления соединения исполь!
зуются функции и для получения и передачи
соответственно. Функции имеют следующий вид:
ttinclude
int fildes, struct t_unitdata *unitdata,
int *
int fildes, struct t_unitdata
Для передачи данных используется структура unitdata, имеющая сле!
дующие поля:
struct netbuf addr Адрес удаленного транспортного узла
struct netbuf opt Опции протокола
struct netbuf udata Прикладные данные
Созданный транспортный узел может быть закрыт с помощью функции
t_close(3N). Заметим, что при этом соединение, или виртуальный канал, с
которым ассоциирован данный узел, в ряде случаев не будет закрыт.
Функция t_close(3N) имеет вид:
ttinclude
int
где f d определяет транспортный узел. Вызов этой функции приведет к ос!
вобождению ресурсов, связанных с транспортным узлом, а последующий
www.books-shop.com
434 Глава 6. сети в системе UNIX
системный вызов close(2) освободит и файловый дескриптор. Судьба вир!
туального канала (если таковой существует) зависит от того, является ли
транспортный узел, адресующий данный канал, единственным. Если это
так, соединение немедленно разрывается. В противном случае, например,
когда несколько файловых дескрипторов адресуют один и тот же транс!
портный узел, виртуальный канал продолжает существовать.
Завершая разговор о программном интерфейсе ТЫ, необходимо упомянуть
об обработке ошибок. Для большинства функций ТЫ свидетельством
ошибки является получение !1 в качестве возвращаемого значения. На!
против, в случае нормального завершения эти функции возвращают 0. Как
правило, при неудачном завершении функции ТЫ код ошибки сохраняет!
ся в переменной t_errno, подобно тому, как переменная errno хранит
код ошибки системного вызова. Для вывода сообщения, расшифровываю!
щего причину ошибки, используется функция
void char
При вызове t_error(3N) после неудачного завершения какой!либо функции
ТЫ будет выведено сообщение errmsg, определенное разработчиком
программы, за которым последует расшифровка ошибки, связанной с ко!
дом t_errno. Если значение t_errno равно TSYSERR, то расшифровка
представляет собой стандартное сообщение о системной ошибке, связан!
ной с переменной errno.
В заключение в качестве иллюстрации программного интерфейса ТЫ при!
ведем пример приложения клиент!сервер. Как и в предыдущих примерах,
сервер принимает сообщения от клиента и отправляет их обратно. Клиент,
в свою очередь, выводит полученное сообщение на экран. В качестве со!
общения, как и прежде, выступает жизнерадостное приветствие
"Здравствуй,
Сервер
tinclude
finclude
<arpa/inet.h>
iinclude <fcntl.h>
/*Номер порта, известный
ttdefine 1500
int
char
www.books-shop.com
Программные 435
транспортных узлов
int tn,
int pid, flags;
int nport;
транспортных узлов сервера и
struct sockaddr_in
struct
struct
struct t_call
узел. В качестве поставщика транспортных услуг
выберем модуль
{
вызова
адрес транспортного узла — он должен быть известен клиенту */
nport =
/*Приведем в соответствие порядок следования байтов для хоста и
nport =
= AF_INET;
=
=
=
=
= (char
число запросов, обработки, установим равным
=
узел с
(struct *)0) < 0)
{
вызова exit
}
"Адрес сервера:
/*Поскольку в структуре t call нам понадобится только буфер для хранения
адреса клиента, разместим ее
if =
(struct t_alloc(tn,
{
вызова
}
=
=
= 0;
= 0;
www.books-shop.com
436 Глава 6. сети в операционной системе UNIX
цикл получения и обработки
{
поступления запроса на установление
(t_listen(s, call) <0)
{
вызова
}
информацию о клиенте, сделавшем
clnt_addr = (struct
транспортный узел для обслуживания
=
(struct t_info *) <0)
{
вызова
}
/*Пусть система сама свяжет его с подходящим
if (struct t_bind
(struct *)0) <0)
{
вызова
}
запрос и переведем его обслуживание на новый транспортный
if ntn, call) <0)
{
вызова
новый процесс для обслуживания запроса. При этом родительский
процесс продолжает принимать запросы от
{
t вызова
}
{
int nbytes;
этот транспортный узел уже не нужен, он используется
родителем* /
while = buf,
sizeof(buf), !=0)
{
t_snd(ntn, buf,
)
t
www.books-shop.com
Программные интерфейсы
}
процесс: этот транспортный узел не нужен, он используется
дочерним процессом для обмена данными с
}
}
Клиент
ttinclude
ttinclude
ttinclude
ttinclude <fcntl.h>
ttinclude
1500
argv)
char
int
{
int tn;
iht
struct sockaddr_in
struct hostent
char
struct t_call
/*B качестве аргумента клиенту передается доменное имя хоста, на котором
запущен сервер. Произведем трансляцию доменного имени в
{
вызова
}
транспортный узел. В качестве поставщика транспортных услуг
выберем модуль
{
вызова
}
системе самостоятельно связать узел с подходящим
(struct t_bind (struct t_bind *}0) < 0}
{
вызова exit
}
"Адрес клиента:
inet
www.books-shop.com
438 Глава 6. сети в операционной системе UNIX
/*Укажем адрес сервера, с которым мы будем
=
в соответствие порядок следования байтов для хоста и
=
/*Поскольку в структуре t_call нам понадобится только буфер для хранения
адреса сервера, разместим ее
if ( (call =
(struct t_alloc(tn,
{
вызова
}
=
=
= (char *)
= 0;
= 0;
соединение с
call, (struct t_call *)0)==1)
{
вызова
}
сообщение и получим ответ */
buf,
if (t_rcv(tn, buf, <0)
{
вызова exit
}
полученное сообщение на
от сервера:
завершил
}
В рассмотренном примере большая часть исходного текста посвящена соз!
данию транспортных узлов и установлению соединения, в то время как
завершение сеанса связи представлено скупыми вызовами t_close(3N). На
самом деле, вызов t_close(3N) приводит к немедленному разрыву соедине!
ния, запрещая дальнейшую передачу или прием данных. Однако вирту!
альный канал, обслуживаемый протоколом TCP, является полнодуплекс!
ным и, как было показано, TCP предусматривает односторонний разрыв
связи, позволяя другой стороне продолжать передачу данных. Действиям,
предписываемым TCP, больше соответствуют две функции и
t_rcvrel(3N), которые обеспечивают прекращение связи (orderly
release). Разумеется, эти рассуждения справедливы лишь для транспорт!
ного протокола, обеспечивающего передачу данных с предварительным
установлением связи, каковым, в частности, является протокол TCP.
www.books-shop.com
Программные 439
Функции и t_rcvrel(3N) имеют вид:
ttinclude
;
t fd);
Вызывая функцию процесс отправляет другой стороне уве!
домление об одностороннем прекращении связи, это означает, что про!
цесс не намерен больше передавать данные. В то же время процесс
принимать данные — файловый дескриптор f d доступен для чтения.
Другая сторона подтверждает получение уведомления вызовом функции
t_rcvrel(3N). Однако поскольку получение такого уведомления носит асин!
хронный характер, процесс должен каким!то образом узнать, что запрос
поступил. Такой индикацией является завершение с ошибкой попытки
получения данных от удаленного узла, например, с помощью функции
В этом случае вызов функции t_rcv(3N) завершится с ошибкой
TLOOK.
Эта ошибка свидетельствует, что произошло событие, связанное с комму!
никационным узлом, анализ которого позволяет получить дополнительную
информацию о причине неудачи. Текущее событие может быть получено с
помощью функции
Функция возвращает идентификатор, соответствующий одному из собы!
тий, перечисленных в табл. 6.6.
Таблица 6.6. События, связанные с коммуникационным узлом
Событие Значение
Узлом получено подтверждение создания соединения
Узлом получен запрос на разрыв соединения
Узлом получены данные
Узлом получены экстренные данные
Узлом получен запрос на установление соединения
T_ORDREL Узлом получен запрос на корректное прекращение связи
T_ERROR Свидетельствует о фатальной ошибке
T_UDERR Свидетельствует об ошибке
Если в рассматриваемом случае событием, связанным с ошибкой
является это означает, что удаленный узел завершил передачу
данных и более не нуждается в соединении. Если узел, получивший запрос
на прекращение связи, не возражает против полного прекращения сеанса,
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
440 Глава 6. сети в операционной системе UNIX
он вызывает функцию Впрочем, при необходимости, комму!
никационный узел может продолжить передачу данных. Единственное, от!
чего ему следует воздержаться, это от попытки получения данных, или,
другими словами, от вызова поскольку в этом случае выполне!
ние процесса будет навсегда заблокировано, т. к. данные от удаленного
узла поступать не будут.
Проиллюстрируем описанную процедуру фрагментом программы, обраба!
тывающей корректное прекращение связи:
обработку принятых
if == T_LOOK ==
{
получен запрос на корректное прекращение Мы
согласны на завершение сеанса, поэтому также корректно
exit
t получения данных (t
exit
Программный интерфейс высокого уровня. Удаленный вызов
процедур
В предыдущих разделах рассматривался программный интерфейс доста!
точно низкого уровня — по существу программа взаимодействовала непо!
средственно с транспортным протоколом, самостоятельно реализуя неко!
торый протокол верхнего уровня при обмене данными. В приведенных
примерах легко заметить, что значительная часть кода этих программ по!
священа созданию коммуникационных узлов, установлению и завершению
связи.
С точки зрения разработчика программного обеспечения, более перспек!
тивным является подход, когда используется прикладной программный
интерфейс более высокого уровня, изолирующий программу от специфики
сетевого взаимодействия. В данном разделе мы рассмотрим один из таких
подходов, на базе которого, в частности, разработана файловая система
NFS, получивший название удаленный вызов процедур (Remote Procedure
Call,
www.books-shop.com
Программные интерфейсы
Использование подпрограмм в программе — традиционный способ струк!
турировать задачу, сделать ее более ясной. Наиболее часто используемые
подпрограммы собираются в библиотеки, где могут использоваться раз!
личными программами. В данном случае речь идет о локальном (местном)
вызове, т. е. и и вызываемый объекты работают в рамках
одной программы на одном компьютере.
В случае удаленного вызова процесс, выполняющийся на одном компью!
тере, запускает процесс на удаленном компьютере (т. е. фактически запус!
кает код процедуры на удаленном компьютере). Очевидно, что удаленный
вызов процедуры существенным образом отличается от традиционного ло!
кального, однако с точки зрения программиста такие отличия практически
отсутствуют, т. е. архитектура удаленного вызова процедуры позволяет
сымитировать вызов локальной.
Однако если в случае локального вызова программа передает параметры в
вызываемую процедуру и получает результат работы через стек или общие
области памяти, то в случае удаленного вызова передача параметров пре!
вращается в передачу запроса по сети, а результат работы находится в
пришедшем отклике.
Данный подход является возможной основой создания при!
ложений, и хотя многие современные системы не используют этот меха!
низм, основные концепции и термины во многих случаях сохраняются. При
описании механизма RPC мы будем традиционно называть вызывающий
процесс — клиентом, а удаленный процесс, реализующий процедуру, —
Удаленный вызов процедуры включает следующие шаги:
1. Программа!клиент производит локальный вызов процедуры, называе!
мой заглушкой (stub). При этом клиенту "кажется", что, вызывая за!
глушку, он производит собственно вызов процедуры!сервера. И дейст!
вительно, клиент передает заглушке необходимые параметры, а она
возвращает результат. Однако дело обстоит не совсем так, как это себе
представляет клиент. Задача заглушки — принять аргументы, предна!
значаемые удаленной процедуре, возможно, преобразовать их в некий
стандартный формат и сформировать сетевой запрос. Упаковка аргу!
ментов и создание сетевого запроса называется сборкой (marshalling).
2. Сетевой запрос пересылается по сети на удаленную систему. Для этого
в заглушке используются соответствующие вызовы, например, рас!
смотренные в предыдущих разделах. Заметим, что при этом могут быть
использованы различные транспортные протоколы, причем не только
семейства TCP/IP.
На удаленном хосте все происходит в обратном порядке. Заглушка
сервера ожидает запрос и при получении извлекает параметры — ар!
гументы вызова процедуры. может включать
www.books-shop.com
442 Глава 6. сети в операционной системе UNIX
необходимые преобразования (например, изменения порядка распо!
ложения байтов).
4. Заглушка выполняет вызов настоящей процедуры!сервера, которой ад!
ресован запрос клиента, передавая ей полученные по сети аргументы.
5. После выполнения процедуры управление в заглушку
сервера, передавая ей требуемые параметры. Как и заглушка
заглушка сервера преобразует возвращенные процедурой
формируя сетевое сообщение!отклик, который передается по сети сис!
теме, от которой пришел запрос.
6. Операционная система передает полученное сообщение заглушке кли!
ента, которая, после необходимого преобразования, передает значения
(являющиеся значениями, возвращенными удаленной процедурой) кли!
енту, воспринимающему это как нормальный возврат из
Таким образом, с точки зрения клиента, он производит вызов удаленной
процедуры, как он это сделал бы для локальной. То же самое можно ска!
зать и о сервере: вызов процедуры происходит стандартным образом, не!
кий объект (заглушка сервера) производит вызов локальной процедуры и
получает возвращенные ею значения. Клиент воспринимает заглушку как
вызываемую процедуру!сервер, а сервер принимает собственную заглушку
за клиента.
Таким образом, заглушки составляют ядро системы RPC, отвечая за все
аспекты формирования и передачи сообщений между клиентом и удален!
ным сервером (процедурой), хотя и клиент и сервер считают, что вызовы
происходят локально. В этом!то и состоит основная концепция —
полностью спрятать распределенный (сетевой) характер взаимодействия в
коде заглушек. Преимущества такого подхода очевидны: и клиент и сервер
являются независимыми от сетевой реализации, оба они работают в рам!
ках некой распределенной виртуальной машины, и вызовы процедур име!
ют стандартный
Передача параметров
Передача параметров!значений не вызывает особых трудностей. В
случае заглушка клиента размещает значение параметра в сетевом запросе.
возможно, выполняя преобразования к стандартному виду (например, из!
меняя порядок следования байтов). Гораздо сложнее обстоит дело с
' Кроме прочего, благодаря такому подходу, достигается независимость компо!
распределенного приложения (клиента и сервера) не только от сетевой
ции, но и от типа операционных систем, под управлением которых они и
от языка программирования, на котором написаны сами компоненты. Скажем,
может быть создан в виде программы на языке С, выполняющейся пол управлением
в то в качестве клиента может выступать разработанная на
языке Pascal, выполняющаяся в среде Windows NT!
www.books-shop.com
Программные интерфейсы 443
дачей указателей, когда параметр представляет собой адрес данных, а не
их значение. Передача в запросе адреса лишена смысла, так как удаленная
выполняется в совершенно другом адресном пространстве. Са!
мым простым решением, применяемым в RPC, является запрет клиентам
передавать параметры иначе, как по значению, хотя это, безусловно на!
кладывает серьезные
Связывание (binding)
Прежде чем клиент сможет вызвать удаленную процедуру, необходимо
связать его с удаленной системой, располагающей требуемым сервером.
Таким образом, задача связывания распадается на две:
Нахождение удаленного хоста с требуемым сервером
Нахождение требуемого серверного процесса на данном хосте
Для нахождения хоста могут использоваться различные подходы. Возмож!
ный вариант — создание некоего централизованного справочника, в кото!
ром хосты анонсируют свои серверы, и где клиент при желании может
выбрать для него хост и адрес процедуры.
Каждая процедура RPC однозначно определяется номером программы и
процедуры. Номер программы определяет группу удаленных процедур,
каждая из которых имеет собственный номер. Каждой программе также
присваивается номер версии, так что при внесении в программу незначи!
тельных изменений (например, при добавлении процедуры) отсутствует
необходимость менять ее номер. Обычно несколько функционально сход!
ных процедур реализуются в одном программном модуле, который при
запуске становится сервером этих процедур, и который идентифицируется
номером программы.
Таким образом, когда клиент хочет вызвать удаленную процедуру, ему не!
обходимо знать номера программы, версии и процедуры, предоставляю!
щей требуемый сервис.
Для передачи запроса клиенту также необходимо знать сетевой адрес хоста
и номер порта, связанный с программой!сервером, обеспечивающей тре!
буемые Для этого используется демон (в некото!
рых системах он называется Демон запускается на хосте, ко!
торый предоставляет сервис удаленных процедур, и использует общеизве!
стный номер порта. При инициализации процесса!сервера он регистриру!
ет в свои процедуры и номера портов. Теперь, когда клиенту
требуется знать номер порта для вызова конкретной процедуры, он посы!
лает запрос на сервер который, в свою очередь, либо возвра!
Более сложные (например лишены
подобных и рядом дополнительных возможностей, что с
их создавать распределенные системы.
www.books-shop.com
444 Глава 6. сети в операционной UNIX
номер порта, либо перенаправляет запрос непосредственно серверу
удаленной процедуры и после ее выполнения клиенту отклик.
В любом случае, если требуемая процедура клиент получает от
сервера номер порта процедуры, и дальнейшие запросы может
делать уже непосредственно на этот порт.
Обработка особых ситуаций
Обработка особых ситуаций при вызове локальных процедур не представ!
ляет особой проблемы. UNIX обеспечивает обработку ошибок процессов,
таких как деление на ноль, обращение к недопустимой области памяти и
т. д. В случае вызова удаленной процедуры вероятность возникновения
ошибочных ситуаций увеличивается. ошибкам сервера и заглушек до!
бавляются ошибки, связанные, например, с получением ошибочного сете!
вого сообщения.
Например, при использовании UDP в качестве транспортного протокола
производится повторная передача сообщений после определенного тайм!
аута. Клиенту возвращается ошибка, если, спустя определенное число по!
отклик от сервера так и не был получен. В случае, когда использу!
ется протокол TCP, клиенту возвращается ошибка, если сервер оборвал
TCP!соединение.
Семантика вызова
Вызов локальной процедуры однозначно приводит к ее выполнению, по!
сле чего управление возвращается в головную программу. Иначе дело об!
стоит при вызове удаленной процедуры. Невозможно установить, когда
конкретно будет выполняться процедура, будет ли она выполнена вообще,
а если будет, то какое число раз? Например, если запрос будет получен
удаленной системой после аварийного завершения программы сервера,
процедура не будет выполнена вообще. Если клиент при неполучении от!
клика после определенного промежутка времени (тайм!аута) повторно по!
сылает запрос, то может создаться ситуация, когда отклик уже передается
по сети, повторный запрос вновь принимается на обработку удаленной
процедурой. В этом случае процедура будет выполнена несколько раз.
Таким образом, выполнение удаленной процедуры можно характеризовать
следующей семантикой:
Один и только раз. Данного поведения (в некоторых случаях наибо!
лее желательного) трудно требовать ввиду возможных аварий сервера.
Максимум раз. Это означает, что процедура либо не была вы!
полнена, либо была выполнена только один раз. Подобное
можно сделать при получении ошибки вместо нормального отклика.
Хотя бы раз. Процедура наверняка была выполнена один раз, но воз!
и больше. Для работы в такой ситуации
www.books-shop.com
Программные 445
процедура должна обладать свойством
Этим обладает многократное вы!
которой не вызывает кумулятивных изменений. Например,
чтение файла а добавление текста в файл — нет.
Представление данных
Когда клиент и сервер выполняются в одной системе на одном компьюте!
ре, проблем с несовместимостью данных не возникает. И для клиента и
для сервера данные в двоичном виде представляются одинаково. В случае
удаленного вызова дело осложняется тем, что клиент и сервер могут вы!
полняться на системах с различной архитектурой, имеющих различное
представление данных (например, представление значения с плавающей
точкой, порядок следования байтов и т. д.)
Большинство реализаций системы RPC определяют некоторые стандарт!
ные виды представления данных, к которым должны быть преобразованы
все значения, передаваемые в запросах и откликах.
Например, формат представления данных в RPC фирмы Sun Microsystems
следующий:
Порядок следования байтов Старший — последний
Представление значений с плавающей точкой IEEE
Представление символа ASCII
Сеть
По своей функциональности система RPC занимает промежуточное место
между уровнем приложения и транспортным уровнем. В соответствии с
моделью этому положению соответствуют уровни представления и се!
анса. Таким образом, RPC теоретически независим от реализации сети, в
частности, от сетевых протоколов транспортного уровня.
Программные реализации системы, как правило, поддерживают один или
два протокола. система разработки фирмы Sun
Microsystems поддерживает передачу сообщений с использованием прото!
колов TCP и Выбор того или иного протокола зависит от требова!
ний приложения. Выбор протокола UDP оправдан для обла!
дающих следующими характеристиками:
Вызываемые процедуры
Размер передаваемых аргументов и возвращаемого результата мень!
ше размера пакета — 8 Кбайт.
О Сервер обеспечивает работу с несколькими сотнями клиентов. По!
скольку при работе с протоколами TCP сервер вынужден поддержи!
вать соединение с каждым из активных клиентов, это занимает
www.books-shop.com
446 Глава 6. сети в системе
часть его ресурсов. Протокол в этом отношении яв!
ляется менее ресурсоемким
С другой стороны, TCP обеспечивает эффективную работу приложений со
следующими характеристиками:
Приложению требуется надежный протокол передачи
Вызываемые процедуры
Размер аргументов или возвращаемого результата превышает 8 Кбайт
Выбор протокола обычно остается за клиентом, и система по!разному ор!
ганизует формирование и передачу сообщений. Так, при использовании
протокола TCP, для которого передаваемые данные представляют собой
поток байтов, необходимо отделить сообщения друг от друга. Для этого,
например, применяется протокол записей, описанный в
Remote Procedure Call Protocol version 2", при
котором в начале каждого сообщения помещается 32!разрядное целое чис!
ло, определяющее размер сообщения в байтах.
По!разному обстоит дело и с семантикой вызова. Например, если
выполняется с использованием ненадежного транспортного протокола
система выполняет повторную передачу сообщения через короткие
промежутки времени (тайм!ауты). Если приложение!клиент не получает
отклик, то с уверенностью можно сказать, что процедура была выполнена
ноль или большее число раз. Если отклик был приложение мо!
жет сделать вывод, что процедура была выполнена хотя бы однажды. При
использовании надежного транспортного протокола (TCP) в случае полу!
чения отклика можно сказать, что процедура была выполнена один раз.
Если же отклик не получен, определенно сказать, что процедура выполне!
на не была,
Как это работает?
По собственно система RPC является встроенной в программу!
клиент и программу!сервер. Отрадно, что при разработке распределенных
приложений, не придется вникать в подробности протокола RPC или
программировать обработку сообщений. Система предполагает существо!
вание соответствующей среды разработки, которая значительно облегчает
жизнь создателям прикладного программного обеспечения. Одним из
ключевых моментов в RPC является то, что разработка распределенного
приложения начинается с определения интерфейса — формаль!
ного описания функций сервера, сделанного на специальном языке. На
основании этого интерфейса затем автоматически создаются заглушки
Даже при использовании надежных транспортных протоколов в случае аварийного
шения работы требуются связи
и повторная В этом случае также меняется.
www.books-shop.com
Программные 447
клиента и сервера. Единственное, что необходимо сделать после этого, —
написать фактический код процедуры.
В качестве примера рассмотрим RPC фирмы Sun Microsystems.
Система состоит из трех основных частей:
rpcgen(l) — который на основании описания ин!
терфейса удаленной процедуры генерирует заглушки клиента и сер!
вера в виде программ на языке С.
Библиотека XDR Data Representation), которая содержит
функции для преобразования различных типов данных в машинно!
независимый вид, позволяющий производить обмен информацией
между разнородными системами.
Библиотека модулей, обеспечивающих работу системы в целом.
Рассмотрим пример простейшего распределенного приложения для веде!
ния журнала событий. Клиент при запуске вызывает удаленную процедуру
записи сообщения в файл журнала удаленного компьютера.
Для этого придется создать как минимум три файла: спецификацию ин!
терфейсов удаленных процедур (на языке описания интерфейса),
собственно текст удаленных процедур и текст головной программы
клиента main — (на языке С) .
Компилятор на основании спецификации log.x создает три фай!
ла: текст заглушек клиента и сервера на языке С и и
файл описаний используемый обеими заглушками.
Итак, рассмотрим исходные тексты программ.
log.x
В этом файле указываются регистрационные параметры удаленной про!
цедуры — номера программы, версии и процедуры, а также определяется
интерфейс вызова — входные аргументы и возвращаемые значения. Таким
образом, определена процедура RLOG, в качестве аргумента принимаю!
щая строку (которая будет записана в журнал), а значение
стандартно указывает на успешное или неудачное выполнение заказанной
операции.
program LOG_PROG {
version LOG_VER (
RLOG (string) 1;
} = i;
} =
Компилятор rpcgen(l) создает файл заголовков log.h, где, в частности, оп!
ределены процедуры:
www.books-shop.com
448 Глава 6. сети в операционной системе UNIX
/*
* Please do not edit this file.
* It was generated using rpcgen.
ttifndef
<rpc/rpc.h>
ftdefine
ftdefine
RLOG long)
extern int
/*Внутренняя процедура — нам ее использовать не
extern int
/* */
Рассмотрим этот файл внимательно. Компилятор транслирует имя RLOG,
определенное в файле описания интерфейса, в заменяя пропис!
ные символы на строчные и добавляя номер версии программы с подчер!
киванием. Тип возвращаемого значения изменился с на int Таково
правило — RPC позволяет передавать и получать только адреса объявлен!
ных при описании интерфейса параметров. Это же правило касается и пе!
редаваемой в качестве аргумента строки. Хотя из файла это не сле!
дует, на самом деле в качестве аргумента функции также пере!
дается адрес строки.
Помимо файла заголовков компилятор создает модули заглушки
клиента и заглушки сервера. По в тексте этих файлов заключен
весь код удаленного вызова.
Заглушка сервера является головной программой, все
сетевое взаимодействие с клиентом (точнее, с его заглушкой). Для выпол!
нения операции заглушка сервера производит локальный вызов функции,
текст которой необходимо написать:
log. с
<rpc/rpc.h>
#include
<sys/stat.h>
значение должно определяться как
static int result;
int дескриптор
int
www.books-shop.com
Программные интерфейсы 449
result =
файл журнала если он не в
случае неудачи вернем код ошибки result ==
! ,
j ! 0 APPEND); < 0! return
=
if != len!
result =
else
result 0;
результат — адрес
}
Заглушка клиента принимает аргумент, передаваемый удаленной
ре, делает необходимые преобразования, формирует запрос на сервер
обменивается данными с сервером удаленной процедуры и,
наконец, передает возвращаемое значение клиенту. Для клиента вызов
удаленной процедуры сводится к вызову заглушки и ничем не отличается
от обычного локального вызова.
client.c
argc, char
{
CLIENT
char*server,
time t
server =
В случае неудачи — сообщим о
невозможности установления связи с
if (
r
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
450 Глава 6. Поддержка сети в операционной системе UNIX
/*Выделим буфер для строки*/
mystring = (char *)malloc(100);
/*0пределим время события*/
bintime = time((time_t *)NULL);
clnttime = ctime(&bintime );
sprintf (mystring, "%s — Клиент запущен", clntime);
/*Передадим сообщение для журнала — время начала работы клиента.
В случае неудачи — сообщим об ошибке*/
if ((result = rlog_l(&mystring, cl)) == NULL) {
fprintf(stderr, "error2\n");
clnt_perror(cl, server);
exit (3) ;
}
/*B случае неудачи на удаленном компьютере сообщим об ошибке*/
if (*result !=0 )
fprintf(stderr, "Ошибка записи в журнал\п"!;
/"Освободим дескриптор*/
clnt_destroy(cl);
exit(0);
Заглушка клиента компилируется с модулем для получе!
исполняемой программы клиента.
о
Заглушка сервера и компилируются для получе!
ния исполняемой программы сервера.
о log svc.e
Теперь на некотором хосте server.nowhere.ru необходимо запустить сервер!
ный
$ logger
После чего при запуске клиента Hog на другой машине сервер добавит со!
ответствующую запись в файл журнала.
Схема работы RPC в этом случае приведена на рис. 6.20. Модули взаимо!
действуют следующим образом:
1. Когда запускается серверный процесс, он создает сокет и связы!
вает любой локальный порт с этим сокетом. Далее сервер вызывает
библиотечную функцию для регистрации номеров
программы и ее версии. Для этого функция к
и передает требуемые значения. Сервер 1М) обыч!
но запускается при инициализации системы и связывается с
рым общеизвестным портом. Теперь знает номер порта
www.books-shop.com
Программные интерфейсы
для нашей программы и версии. Сервер же ожидает получения запро!
са. Заметим, что все описанные действия производятся заглушкой сер!
вера, созданной компилятором
2. Когда запускается программа первое, что она делает, — вызывает
библиотечную функцию указывая ей адрес удаленной сис!
темы, номера программы и версии, а также транспортный протокол.
Функция направляет запрос к серверу удаленной системы
server.nowhere.ru и получает номер удаленного порта для сервера журнала.
3. Клиент вызывает процедуру rlog_l определенную в заглушке
ента, и передает заглушке. Та, в свою очередь, формирует
запрос (преобразуя аргументы в формат XDR) в виде пакета и
направляет его на удаленный порт, полученный от сервера
Затем она некоторое время ожидает отклика и в случае
неполучения повторно отправляет запрос. При благоприятных обстоя!
тельствах запрос принимается сервером logger (модулем заглушки сер!
вера). Заглушка определяет, какая именно функция была вызвана (по
номеру процедуры), и вызывает функцию rlog_l модуля По!
сле возврата управления обратно в заглушку преобразует
возвращенное функцией значение в формат XDR, и форми!
рует отклик также в виде пакета UDP. После получения отклика
глушка клиента извлекает возвращенное значение, преобразует его и
в головную программу клиента.
Рис. 6.20. Работа системы RPC
www.books-shop.com
Глава 6. в операционной UNIX
Поддержка сети в BSD UNIX
Перейдем теперь к обсуждению внутренней архитектуры сетевого
в UNIX. Разговор начнем с ветви UNIX, в которой реализация TCP/IP
появилась впервые — BSD UNIX.
Сетевая подсистема UNIX может быть представлена состоящей из трех уров!
ней, каждый из которых отвечает за выполнение определенных функций:
Транспортный уровень Обмен данными между процессами
Сетевой уровень Маршрутизация сообщений
Уровень сетевого интерфейса Передача данных по физической сети
Два верхних уровня представляют собой модули коммуникационных про!
токолов, а нижний уровень по существу является драйвером устройства.
Легко заметить, что представленные уровни соответствуют транспортному,
сетевому уровням и уровню канала данных модели OSI.
Транспортный уровень является самым верхним в системе и призван
обеспечить необходимую адресацию и требуемые характеристики передачи
данных, определенных коммуникационным узлом процесса, которым яв!
ляется сокет. Например, сокет потока предполагает надежную последова!
тельную доставку данных, и в семействе TCP/IP модуль данного уровня
реализует протокол TCP. Следующий, сетевой, уровень обеспечивает пе!
редачу данных, адресованных удаленному сетевому или транспортному
модулю. Для этого модуль данного уровня должен иметь доступ к инфор!
мации о маршрутах сети (таблице маршрутизации). Наконец, последний
уровень отвечает за передачу данных хостам, подключенным к одной фи!
зической среде передачи (например, находящимся в одном сегменте
Ethernet).
Внутренняя структура сетевой подсистемы изолирована от непосредствен!
ного доступа прикладных процессов. Единым (и единственным) интер!
фейсом доступа к сетевым услугам является интерфейс сокетов, рассмот!
ренный в главе 3 в разделе "Межпроцессное взаимодействие в BSD UNIX.
Для обеспечения возможности работы с конкретным коммуника!
ционным протоколом соответствующий модуль экспортирует интерфейсу
сокетов функцию пользовательского запроса. При этом данные от при!
кладного процесса передаются от интерфейса сокетов требуемым транс!
портным модулям с помощью соответствующих вызовов экспортирован!
ных функций. И наоборот, данные, полученные из сети, проходят обра!
ботку в соответствующих модулях протоколов и помещаются в очередь
приема сокета!адресата.
Движение данных вниз (т. е. от верхних уровней к нижним) обычно ини!
циируется системными вызовами и может иметь синхронный характер.
Принимаемые данные из сети поступают в случайные моменты времени и
передаются сетевым драйвером в очередь приема соответствующего прото!
www.books-shop.com
сети в BSD UNIX 453
кола. При этом функции модуля протокола и обработка данных не вызы!
ваются непосредственно сетевым драйвером. Вместо этого последний ус!
танавливает бит соответствующего программного прерывания, в контексте
которого система позднее и запускает необходимые функции. Если данные
предназначены протоколу верхнего уровня (транспортному), его функция
обработки будет вызвана непосредственно модулем сетевого уровня. Если
же сообщение предназначено другому хосту, и система выполняет функ!
ции шлюза, сообщение будет передано уровню сетевого интерфейса для
последующей передачи.
Прежде чем более подробно ознакомиться со взаимодействием различных
модулей сетевой подсистемы BSD UNIX, рассмотрим сначала структуры
данных, определяющие сокет, коммуникационный протокол и сетевой ин!
терфейс.
Структуры данных
Структура данных socket, описывающая сокет, представлена на рис. 6.21.
В этой структуре хранится информация о типе сокета его те!
кущем состоянии и используемом протоколе (so_proto).
Рис. Структуры данных сокета
www.books-shop.com
454 Глава д. сети в операционной системе UNIX
Сокет является коммуникационным узлом и обеспечивает буферизацию
получаемых и отправляемых данных. Как только данные попадают в рас!
поряжение сокета в результате системного вызова (например, или
сокет немедленно передает их модулю протокола для последую!
щего отправления. Данные передаются в виде связанного списка специ!
альных буферов mbuf, структура которых также показана на рис. 6.21. Мо!
дуль протокола может ожидать подтверждения получения отправленных
данных или отложить их отправку. В обоих случаях сообщения остаются в
буфере передачи сокета до момента окончательной отправки или получе!
ния подтверждения. Аналогично, данные, полученные из сети, в конечном
итоге в приемной очереди сокета!адресата, пока не будут
извлечены оттуда системным вызовом (например, read(2) или
Для избежания переполнения буфер (структура хранит параметр
— значение верхней ватерлинии. Модуль коммуникационного
протокола может использовать это значение для управления потоком дан!
ных. Например, модуль TCP устанавливает максимальное значение окна
приема равным этому параметру.
используемые для приема и обработки запросов на установление
связи (зарегистрированные с помощью системного вызова адре!
суют два связанных списка: список сокетов, связь для которых не полно!
стью установлена, и список сокетов, обеспечивающих доступ к созданным
каналам передачи данных.
Следующая структура данных, которую мы рассмотрим, относится к ком!
муникационным протоколам. Каждый модуль протокола представляет
бой набор функций обработки и структур данных и описывается структу!
рой данных, называемой коммутатором протокола. Коммутатор протокола
хранит адреса стандартных функций протокола, например, функций ввода
и вывода и выполняет ту же роль, что и
элемент коммутатора устройств, рассмотренный в главе 5. Поле
сокета содержит адрес этой структуры для соответствующего протокола.
Вид коммутатора протокола показан на рис. 6.22.
Рис. 6.22. Коммутатор прото%
кола
www.books-shop.com
сети в BSD UNIX 455
Перед первым использованием модуля вызывается функция его инициали!
зации pr_init После этого система будет вызывать функции таймера
модуля протокола pr_fasttimo каждые 200 миллисекунд и
каждые 500 миллисекунд, если протокол определил эти
функции. Например, модуль протокола TCP использует функции таймера
для обработки тайм!аутов при установлении связи и повторных передачах.
Функция pr_drain вызывается системой при недостатке свободной па!
мяти и позволяет модулю уничтожить некритичные сообщения для осво!
бождения места.
С помощью функции модулю протокола передаются сооб!
щения от прикладного процесса. Таким образом, эта функция определяет
интерфейс взаимодействия между сокетом и протоколом нижнего уровня.
Одним из параметров этой функции является номер запроса, зависящий
от произведенного системного вызова. Интерфейс взаимодействия сокета с
прикладными процессами является стандартным интерфейсом системных
вызовов и преобразует вызовы и т. д. в
соответствующие запросы функции Некоторые из них при!
ведены в табл. 6.7.
Таблица 6.7. Запросы функции pr_usrreq()
Системный вызов Значение Запрос
close(2)
accept(2)
bind(2)
listen(2)
send(2),
fstat(2)
getsockname(2)
ioctl(2)
Прекратить обмен данными
Обработать запрос на установление связи
Связать сокет с адресом
Установить связь
Разрешить обслуживание запросов
Отправить данные
Определить состояние сокета
Получить адрес локального сокета
Получить адрес удаленного сокета
Передать команду модулю протокола
PRU ABORT
ACCEPT
PRU BIND
PRU CONNECT
PRU LISTEN
PRU_SENSE
PRU SOCKADDR
PRU PEERADDR
PRU CONTROL
Функции pr_input и pr_output определяют интерфейс взаимодей!
ствия и служат для передачи данных между модулями
соседних уровней. Аналогично для обмена управляющими командами
между модулями протоколов используются функции pr_ctlinput и
pr_ctloutput Цепочка взаимодействующих протоколов производит
размещение и освобождение памяти при обмене сообщениями, которые пе!
редаются посредством рассмотренных структур mbuf: при передаче сообще!
ний от сети прикладному процессу за освобождение буферов mbuf отвечает
модуль верхнего уровня и наоборот, при передаче сообщений в сеть память,
занимаемая сообщением, освобождается на самом нижнем уровне.
www.books-shop.com
456 Глава 6. сети в операционной системе UNIX
Поле pr_flags определяет некоторые характеристики протокола и режим
его функционирования, которые в основном относятся к уровню сокетов.
Например, протоколы, предусматривающие предварительное установление
связи, указывают это с помощью флага не позволяя
тем самым функциям передавать данные модулю до создания вир!
туального канала. Если установлен флаг соответствующие
функции сокета будут уведомлять модуль протокола, когда прикладной
процесс получает данные из буфера приема. Это может служить сигналом
протоколу для отправления подтверждения о получении, а также для об!
новления значения окна в соответствии с освободившимся местом.
Заметим, что каждый модуль протокола имеет собственные очереди сооб!
щений, используемые для приема и передачи данных.
Каждый сетевой интерфейс системы представлен структурой данных, по!
казанной на рис. 6.23. Сетевой интерфейс обычно связан с соответствую!
щим сетевым адаптером, хотя это не является обязательным условием.
Например, внутренний сетевой интерфейс loopback представляет собой
псевдоустройство, используемое для унифицированного взаимодействия
сетевых процессов в рамках одного хоста, отладки и т. п.
Рис. 6.23. Сетевой интерфейс
Решение об использовании того или иного сетевого интерфейса для пере!
дачи сообщения базируется на таблице маршрутизации и производится
www.books-shop.com
сети в BSD
модулем сетевого уровня. Интерфейс может обслуживать протоколы раз!
личных коммуникационных доменов. Соответственно, один и тот же ин!
терфейс может иметь несколько адресов, определенных для каждого се!
мейства протоколов. Структуры, определяющие локальный и широкове!
щательный (broadcast) адреса интерфейса, а также сетевую маску, хранятся
в виде связанного списка.
Каждый сетевой интерфейс имеет очередь, в которую помещаются сооб!
щения для последующей передачи, выполняемой функцией
Интерфейс также может определить процедуры инициализации
if_init сброса if_reset и обработки таймера По!
следняя может использоваться для управления потенциально ненадежны!
ми устройствами или для периодического сбора статистики устройства.
Состояние интерфейса характеризуется флагами, хранящимися в поле
lags. Возможные флаги приведены в табл. 6.8.
Таблица 6.8. Состояния интерфейса
Флаг Значение
Интерфейс доступен для использования
IFF_BROADCAST Интерфейс поддерживает широковещательные адреса
Интерфейс поддерживает групповые адреса
Интерфейс обеспечивает возможность отладки
IFF_LOOPBACK Программный внутренний интерфейс
Интерфейс для канала точка%точка
Ресурсы интерфейса успешно размещены
IFF_NOARP Интерфейс не использует протокол трансляции адреса
Флаг IFF_UP свидетельствует о готовности интерфейса передавать сооб!
щения. Если сетевой интерфейс подключен к физической сети, поддержи!
вающей широковещательную адресацию (broadcast), например, Ethernet,
для интерфейса будет установлен флаг IFF_BROADCAST и определен широ!
ковещательный адрес (поле структуры адресов для
соответствующего коммуникационного домена). Если же интерфейс ис!
пользуется для канала точка!точка, будет установлен флаг
и определен адрес хоста (интерфейса), расположенного
на противоположном конце (поле ifa_dstaddr). Заметим, что эти два
флага являются взаимоисключающими, a и ifa_dstaddr
являются различными именами одного и того же поля. Интерфейс уста!
навливает флаг IFF_RUNNING после размещения необходимых структур
данных и отправления начального запроса на чтение устройству (напри!
мер, сетевому адаптеру), с которым он ассоциирован.
www.books-shop.com
458 Глава 6. сети операционной системе UNIX
Состояние интерфейса и ряд других параметров можно просмотреть с по!
мощью команды
$
1500
inet netmask ffffffOO broadcast
Легко заметить, что команда выводит значение следующих полей структу!
ры для интерфейса leO if_flags, if_mtu (Maximum
Transmission Unit, MTU) определяющее максимальный размер пакета, ко!
торый может быть передан по физической сети, а также значения полей
структуры адрес интерфейса inet маску netmask
и широковещательный адрес broadcast (ifa_broadaddr).
Интерфейс хранит статистическую информацию, которая может быть ис!
пользована при мониторинге сети. В частности, эта информация включает
число полученных пакетов уровня канала (if_ipackets), количество
ошибок при приеме (if_ierrors), число отправленных пакетов уровня
канала количество ошибок при передаче (if_oerrors) и
число коллизий (if_collisions). Команда позволяет полу!
чить эту информацию для сконфигурированных интерфейсов в системе:
$ in
Name Mtu Net/Dest Address Opkts Oerrs Collis
823 127.0.0.0 127.0.0.1 168761 0 168761 О О
leO 1500 194.85.160.0 1624636 1042 110166 1933 382604
Маршрутизация
Сетевая подсистема предназначена для работы в коммуникационной сре!
де, представляющей собой набор сетевых сегментов, связанных между со!
бой. Связь между отдельными сегментами достигается путем подключения
их к хостам, имеющим несколько различных сетевых интерфейсов, как
показано на рис. 6.24. Такие хосты при необходимости выполняют переда!
чу данных от одного сегмента к другому Для сетей пакетной
коммутации, о которых идет речь, выполнение этой задачи непосредст!
венно связано с выбором маршрута прохождения пакетов данных (routing).
Для этого система хранит таблицы маршрутизации, которые используются
протоколами сетевого уровня (например, IP) для выбора требуемого ин!
терфейса для передачи пакета адресату.
информация хранится в виде двух таблиц, одна из
которых предназначена для маршрутов к хостам, а другая — для маршру!
тов к сетям. Такой подход позволяет использовать универсальные меха!
Заметим, что каждый интерфейс такого хоста!шлюза имеет собственный адрес, соответст!
вующий той сети, к которой он непосредственно подключен. Например, для сетей с раз!
деляемой средой передачи сетевая часть этого адреса равна адресу сети.
www.books-shop.com
сети в BSD UNIX 459
определения маршрута как для сетей с разделяемой средой переда!
чи (например, Ethernet), так и для сетей с каналами типа точка!точка. На!
пример, для доставки пакета удаленному хосту, подключенному к сети
первого типа, достаточно знать адрес этой сети, в то время как для кана!
лов точка!точка необходимо явно задать адрес интерфейса противополож!
ного конца
Рис. 6.24. Коммуникационная среда UNIX (internetwork)
При определении маршрута модуль сетевого протокола (IP) сначала про!
сматривает элементы таблицы для хостов, а затем для сетей. Если оба по!
иска не дают результата, используется маршрут по умолчанию (если такой
установлен), определенный как маршрут в сеть с адресом 0. Обычно ис!
пользуется первый найденный маршрут. Таким образом, порядок поиска
обеспечивает приоритетность маршрутов к хостам по отношению к мар!
шрутам к сетям, что естественно, поскольку первые представлены более
конкретными адресами.
Каждый элемент таблицы маршрутизации, показанный на рис. 6.25, со!
держит адрес получателя (это может быть адрес сети получателя или адрес
Вспомним, что IP!адрес состоит из двух частей — адреса сети и адреса хоста в этой сети.
Для интерфейса, подключенного к разделяемой среде, каковой является большинство ло!
кальных сетей, существенным является лишь первая часть адреса!получателя, поскольку
через этот интерфейс непосредственно доступны все хосты с данным адресом сети. На!
против, через сетевой интерфейс типа точка!точка непосредственный доступ осуществля!
ется к единственному расположенному на другом конце канала, и, таким образом,
необходимо определение полного адреса удаленного интерфейса.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
460 Глава 6. сети в операционной UNIX
конкретного хоста). Это значение хранится в поле rt_dst. Следующее по!
ле, rt_gateway, определяет следующий шлюз, которому необходимо на!
править пакет, чтобы последний в конечном итоге достиг адресата. Поле
rt_flags определяет тип маршрута (к хосту или к сети), а также его со!
стояние. В поле rt_use хранится число переданных по данному маршруту
пакетов, a rt_refcnt определяет использование маршрута сетевыми про!
цессами (виртуальными каналами). Наконец, поле rt_ifp адресует сете!
вой интерфейс, которому необходимо направить пакет для дальнейшей
передачи по данному маршруту.
Рис. 6.25. Элемент таблицы мар%
шрутизации
Различают не только маршруты к хостам и сетям, но также маршруты пря!
мые (direct) и косвенные (indirect). Первое различие определяет критерий
сравнения адреса получателя пакета с полем rt_dst элемента таблицы
маршрутизации. Если маршрут к сети, то сравнивается только сетевая
часть адреса, в противном случае требуется полное совпадение адресов.
Определение маршрута как прямого или косвенного зависит от того, име!
ется ли непосредственная связь между получателем, указанным в поле
и сетевым интерфейсом, обслуживающим данный маршрут. На!
пример, маршрут в сеть, непосредственно подключенную к сетевому ин!
терфейсу, является прямым. Напротив, маршрут по умолчанию является
косвенным маршрутом, поскольку всегда адресует получателя, располо!
женного вне непосредственно доступных сетевых сегментов. Эта инфор!
мация необходима при формировании кадра уровня канала данных. Если
пакет адресован хосту или сети, которые непосредственно не подключены
к сетевому интерфейсу, то, хотя сетевой адрес этого пакета будет равен
сетевому адресу фактического получателя данных, заголовок уровня канала
данных будет адресовать соседний шлюз, используемый для дальнейшей
передачи пакета. Если пакет не выходит за пределы непосредственно под!
ключенной сети, адреса и сетевого уровня и уровня канала будут совпадать
с соответствующими адресами фактического получателя.
www.books-shop.com
в BSD UNIX
Данный аспект проиллюстрирован на рис. 6.26. Здесь мы рассмотрели
процесс передачи хосту, расположенному в удаленном се!
тевом сегменте Ethernet. Поскольку доставка предполагает ис!
пользование промежуточного шлюза, передача данных на канальном уров!
не требует соответствующей адресации: на первом "перегоне" в качестве
адреса получателя используется шлюза, и только затем —
фактического адресата.
Рис. 6.26. Инкапсуляция пакетов для косвенных маршрутов
На то, что маршрут является косвенным, указывает флаг RTF_GATEWAY
элемента таблицы маршрутов. В этом случае МАС!адрес получателя при
формировании кадра канального уровня, будет определяться исходя из се!
тевого адреса шлюза, хранящегося в поле
Модуль протокола имеет возможность доступа к ин!
формации с помощью трех функций: rtalloc для получения маршрута,
для его освобождения и rtredirect для обработки управ!
ляющих сообщений о перенаправлении маршрута REDIRECT).
Для определения соответствия между IP!адресами интерфейсов и их ис!
пользуется протокол ARP (Address Resolution Protocol), позволяющий производить форми!
рование адреса кадра уровня канала данных.
www.books-shop.com
462 Глава 6. сети в операционной системе UNIX
Функция rtalloc позволяет модулю протокола определить маршрут к
требуемому адресату. В результате модуль размещает структуру route,
имеющую следующие поля:
struct rtentry *ro_rt Указатель на соответствующий элемент табли
цы маршрутизации
struct Адрес получателя данных
Возвращаемый функцией () маршрут может быть освобожден с
помощью функции (это не означает, что маршрут будет удален
из таблицы маршрутизации). Время жизни маршрута зависит от протокола
верхнего уровня. Например, модуль протокола TCP хранит маршрут на
протяжении жизни виртуального канала.
Функция rtredirect обычно вызывается модулем протокола в ответ на
получение от соседних шлюзов управляющих сообщений о перенаправле!
нии Шлюз генерирует такое сообщение в случае, когда обна!
ружен более предпочтительный маршрут для передаваемого пакета.
Например, если хосты А и В находятся в одной и той же сети, и хост А
направляет пакеты В через шлюз С, последний отправит А сообщение о
перенаправлении маршрута, информирующее, что А в дальнейшем должен
посылать данные В непосредственно. Этот процесс показан на рис. 6.27.
Рис. 6.27. Пере%
направление мар%
шрутов
В семействе протоколов TCP/IP для этих целей служит протокол Сообщения о
перенаправлении маршрутов ICMP REDIRECT формируются IP!модулем шлюза и инфор!
мируют IP!модули соседних хостов (шлюзов) о существовании более выгодного маршрута
к данному адресату.
www.books-shop.com
сети в BSD
Данная возможность может использоваться для упрощения процедуры
формирования таблицы маршрутизации. Например, рабочие станции мо!
гут хранить только маршрут по умолчанию (в сеть 0), адресующий сосед!
ний шлюз. При передаче данных хостам той же сети, что и источник,
шлюз будет информировать последний о перенаправлении маршрутов, по!
зволяя тем самым заполнить элементы таблицы.
Функция вызывается с параметрами, указывающими на
адрес получателя, новый адрес шлюза, который необходимо миновать для
достижения адресата, а также источник перенаправления маршрута. Заме!
тим, что сообщения о перенаправлении маршрута принимаются только от
текущего шлюза для данного получателя. Если существует маршрут, от!
личный от маршрута по умолчанию, то для него изменяется поле
rt_gateway согласно указанному в сообщении новому адресу шлюза.
В противном случае создается новая запись таблицы маршрутизации.
Вопросы определения маршрутов в UNIX являются прерогативой специ!
альных прикладных процессов, а не ядра операционной системы. Ядро
размещает и хранит необходимую информацию, а
также обеспечивает интерфейс доступа к этой информации. Процесс име!
ет возможность добавить или удалить маршрут с помощью системного вы!
зова ioctl(2). Для добавления маршрута используется команда а
для удаления — SIOCDELRT.
В качестве процессов, отвечающих за заполнение таблиц маршрутизации и
ее динамическое обновление, можно назвать стандартный демон
использующий протокол RIP (Routing Information Protocol) для
динамического определения и обновления маршрутов, а также демон
поддерживающий работу нескольких протоколов обмена мар!
шрутизационной информацией (RIP, OSPF, BGP).
Текущую таблицу маршрутизации можно увидеть, воспользовавшись ко!
мандой
$
Routing Table:
Destination Gateway Flags Ref Use Interface
127
default
0
3
0
5054
30926
47150
Первая запись таблицы показывает маршрут для псевдохоста (localhost)
логической сети операционной системы. Следующий маршрут адресует
непосредственно подключенную к интерфейсу (его адрес 194.85.160.50)
сеть (194.85.160.0). Наконец, последняя запись определяет маршрут по
умолчанию, направляя все пакеты, адресованные получателям "внешнего
мира", для которых наш хост не знает конкретных маршрутов, на шлюз с
адресом который обладает большей информацией о возмож!
ных маршрутах.
www.books-shop.com
464 Глава 6. сети в операционной UNIX
Реализация TCP/IP
Прежде чем перейти к описанию функционирования модулей протоколов
TCP/IP, рассмотрим еще одну структуру данных, называемую управляющим
блоком протокола (Protocol Control Block, PCB), который в случае TCP/IP
называется Internet PCB, и представлен структурой inpcb, определенной в
файле Вид структуры inpcb показан на рис. 6.28.
Рис. 6.28. Структуры данных протоколов TCP/IP
Эта структура создается для каждого активного сокета TCP или UDP и
содержит информацию, необходимую для текущих транзакций протокола,
такую как IP!адреса источника и получателя (inp_laddr и
номера портов и
www.books-shop.com
сети в BSD UNIX 465
ции TCP создает дополнительный управляющий блок, где
хранятся данные, необходимые для работы этого протокола (такие как по!
рядковые номера, номера подтверждений и т. д.)
Управляющие блоки размещаются в виде связанного списка, отдельного
для TCP и UDP. Модули протокола имеют в своем распоряжении набор
функций для создания, поиска и удаления управляющего блока. Модуль
IP демультиплексирует сообщения на основании номера протокола, ука!
занного в заголовке а протокол транспортного уровня, в свою
очередь, производит поиск требуемого управляющего блока для доставки
данных протоколам более высокого уровня (приложений).
Перейдем теперь к описанию взаимодействия рассмотренных модулей в
сетевой подсистеме BSD UNIX (рис. 6.29).
Рис. 6.29. Сетевая подсистема BSD UNIX
www.books-shop.com
466 Глава 6. сети в операционной системе UNIX
Модуль IP
Сетевой интерфейс получает пакеты данных из сети и передает их соот!
ветствующему модулю сетевого уровня на основании информации, содер!
жащейся в заголовке кадра уровня канала. В данном разделе мы не будем
рассматривать поддержку различных сетевых протоколов, а остановимся
только на взаимодействии с протоколом IP. В этом случае полученные па!
кеты помещаются в очередь приема модуля IP. После этого с помощью
программного прерывания вызывается процедура ip_input которая
поочередно извлекает пакеты из очереди и обрабатывает их. После обра!
ботки на основании информации заголовка данные либо
передаются протоколу транспортного уровня, либо уничтожаются, если в
данных обнаружена ошибка, либо передаются другому интерфейсу для по!
следующей отправки фактическому адресату. В последнем случае система
выполняет роль шлюза.
считается адресованной данному хосту, если адрес получателя
совпадает с одним из адресов интерфейса данного хоста, или адрес полу!
чателя является широковещательным (или групповым) адресом данной
сети. В случае получения фрагментированной модуль произ!
водит ее реассемблирование. Для этого отдельные фрагменты собираются
в специально организованной очереди, пока не будет сформирована ис!
ходная После этого данные передаются транспортному прото!
колу. Для демультиплексирования модуль IP использует поле Protocol
заголовка, которое по существу является индексом таблицы, каждый эле!
мент которой представлен коммутатором рассмотренного ранее
в этой главе. Соответственно модуль IP имеет возможность непосредст!
венно вызвать функцию pr_input требуемого протокола следующего
уровня.
В случае, когда полученная датаграмма не содержит ошибок, но не адре!
сована данному хосту, она, возможно, должна быть передана на другой
сетевой интерфейс для последующей передачи фактическому адресату. Эта
процедура носит название шлюзования (forwarding) и включает выполнение
следующих шагов:
О Производится проверка разрешения В случае отрица!
тельного результата хост не может выполнять функции шлюза и
данные уничтожаются.
Возможность передачи на другой интерфейс определяется установкой соответствующего
флага при конфигурации сетевой подсистемы (модуля IP). Например, в операционной
системе SCO UNIX за это отвечает настраиваемый параметр ядра
www.books-shop.com
сети в BSD UNIX
Производится проверка адреса получателя. Если адрес
не принадлежит адресному пространству сетей класса А, В или С,
такие данные не могут быть
Определяется маршрут передачи датаграммы.
Если дальнейший путь датаграммы проходит через тот же интер!
фейс, с которого она была получена, и хост!отправитель расположен
в той же сети, ему отправляется сообщение REDIRECT.
Производится вызов функции ip_output выполняющей передачу
датаграммы хосту!адресату или соседнему шлюзу для дальнейшей
передачи.
При выполнении этих функций модуль IP может обнаружить несколько
ошибочных ситуаций, например, отсутствие маршрута для датаграммы или
невозможность передачи данных из!за переполнения в сети. В этих случа!
ях модуль формирует соответствующее сообщение ICMP и передает его
отправителю датаграммы. Эти сообщения ICMP и причины их отправки
приведены в табл. 6.9.
Таблица 6.9. Сообщения ICMP
Сообщение Причина
DESTINATION UNREACHABLE Невозможно доставить Причин может
быть несколько:
Отсутствует маршрут к сети
2. Отсутствует маршрут к хосту
3. Для передачи необходима фрагментация, но в
заголовке установлен флаг (Don't Fragment)
SOURCE QUENCH Переполнение сети. Шлюз передает это сообще%
ние, запрашивая отправителя на уменьшение ско%
рости передачи данных
TIME EXCEEDED Тайм%аут. Причины могут быть две:
Истекло время жизни датаграммы в сети
2. Произошел тайм%аут реассемблирования, т. е.
через определенный промежуток времени полу%
чены не все фрагменты датаграммы
При вызове функции ей передается которую
необходимо отправить, указатель на маршрут (структура route, хранящая!
ся в управляющем блоке), а также флаги (например, указание не исполь!
зовать таблицы). Передача маршрута не является обя!
Адреса сетей класса D — групповые (multicast) адреса — используются для создания специ!
альных наложенных сетей (Multicast backbone, предназначенных для таких при!
ложений, как видео!, аудиоконференции и т. п. Обработка таких датаграмм выполняется,
как правило, специальными демонами отдельно от стандартных функций шлюзования.
Если в системе включена поддержка групповых адресов, данные с указанными адресами
будут передаваться этим демонам, которые и выполнят логическое шлюзование/передачу.
www.books-shop.com
468 Глава 6. Поддержка в операционной системе UNIX
зательной. Если функции не передан указатель на маршрут, будет исполь!
зован маршрут из таблицы маршрутизации. В противном случае будет
произведена проверка переданного маршрута, и при необходимости его
значение будет обновлено для последующего использования.
Функция может быть вызвана и модулем транспортного
протокола (UDP или TCP). Каким образом это происходит, описано в
следующем разделе.
Модуль UDP
Вернемся к рассмотрению ситуации, когда адресована нашему
хосту, не содержит ошибок (по крайней мере, с точки зрения IP) и должна
быть передана транспортному протоколу. Поскольку целью данного разде!
ла является иллюстрация схемы взаимодействия между модулями, рас!
смотрим более простой протокол UDP.
Итак, IP!модуль направляет модулю UDP, вызывая функцию
udp_input адрес которой был получен из соответствующего коммутатора
протокола. Сначала функция проверяет правильность кон!
трольной суммы и допустимость установленных полей заголовка. Если ука!
занные проверки закончились неудачно, пакет "молчаливо" уничтожается.
Далее определяется получатель пакета. Для этого на основании адресов и
номеров портов отправителя и получателя производится поиск соответст!
вующего управляющего блока В системе могут существовать
несколько управляющих блоков с одинаковым номером локального порта,
но с различными адресами и/или номерами портов отправителя. В этом
случае выбирается блок, для которого найдено лучшее совпадение по всем
четырем параметрам. Конечно, лучшим является точное совпадение, но если
такового не найдено, будет выбран блок с совпадающим номером локаль!
ного порта, но неуказанным адресом и/или номером порта отправителя. Та!
ким образом, управляющий блок, у которого не указаны часть или все четы!
ре параметра, является получателем всех пакетов, для которых не найдено
лучшего
Если управляющий блок найден, данные и адрес отправителя помещаются
в буфер приема сокета, связанного с управляющим блоком. В противном
случае генерируется сообщение PORT UNREACHABLE.
Функции udp_input передается целиком датаграмма, включающая заголовок заго!
ловок и данные протоколов верхнего уровня (приложений). Помимо того что эта
информация необходима для определения адресата, по заголовку IP вычисляется кон!
трольная сумма UDP. Такой подход гарантирует максимальную точность доставки данных
нужному приложению.
Возможность создания таких получателей "по умолчанию" используется в сетевом супер!
сервере inetd, который прослушивает все запросы и при необходимости запускает требуе!
мый сервис (например FTP или Telnet). Это позволяет избежать запуска серверов без не!
обходимости и тем самым сократить потребление ресурсов.
www.books-shop.com
сети в BSD UNIX 469
Передача данных от приложения инициируется системным вызовом
sendto(2), который на уровне сокета преобразуется в вызов функции
с запросом PRU_SEND. Если передача инициирована сис!
темным вызовом то вместе с данными передается адрес получате!
ля. Если же данные были переданы с помощью системного вызова send(2),
то адрес получателя определяется из управляющего блока, где он был со!
хранен предшествующим вызовом
Фактическая передача осуществляется функцией которая
формирует заголовок пакета, устанавливает значения его полей и вычисля!
ет контрольную сумму. После этого производится вызов уже рассмотрен!
ной ранее функции ip_output
Как следует из предшествующего описания TCP, этот транспортный про!
токол обеспечивает гораздо более высокое качество передачи, чем UDP.
Соответственно, его реализация также является гораздо более сложной. В
предыдущих разделах уже встречались различные алгоритмы, используе!
мые при реализации протокола. В этом разделе мы остановимся на одном
важном механизме TCP — его таймерах.
Поскольку корректное функционирование протокола во многом зависит
от порядка обмена управляющими сегментами, каждый канал обслужива!
ется набором таймеров, позволяющих восстановить работу по тайм!ауту в
случае потери управляющих пакетов. Эти таймеры хранятся в соответст!
вующем управляющем блоке протокола TCP и, при их установке, обслу!
каждые 500 миллисекунд функцией
Для обеспечения передачи данных используются два таймера. Первый из
них — таймер повторной передачи (retransmit timer). Этот таймер запуска!
ется при передаче сегмента, если он уже не был запущен. Если подтвер!
ждение получено, и отсутствуют неподтвержденные данные — таймер ос!
танавливается. Если же такие данные существуют, значение таймера при!
сваивается равным начальному, и таймер запускается снова. Если значе!
ние таймера становится равным нулю, наиболее старые неподтвержденные
данные передаются повторно (как минимум один полный сегмент), а тай!
мер запускается снова, но уже с большим значением. Скорость увеличения
значения таймера (timer backoff) определяется по специальной таблице и
имеет экспоненциальный характер.
Протокол не предусматривает предварительного установления связи с получателем
данных. Поэтому, в отличие от TCP, вызов не приводит к формированию
управляющих сообщений и обмену ими между сторонами. В данном случае он служит
лишь для сохранения адреса получателя в управляющем блоке.
Обслуживание таймера заключается в уменьшении установленного значения и уведомле!
нии модуля, когда значение таймера становится равным нулю.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
470 Глава 6. сети в операционной UNIX
Второй таймер — это (таймер сохранения). Этот таймер обеспе!
чивает защиту от потери управляющих сообщений, содержащих
значения окна. В случае, если отправитель готов передать данные, но анонси!
рованное получателем окно слишком мало (равно нулю или меньше опреде!
ленного значения), и отсутствуют неподтвержденные данные (т. е. таймер по!
вторной передачи не включен), включается таймер сохранения. Если таймер
срабатывает (его значение становится равным нулю), а обновленное значение
так и не получено, отправитель передает максимально допустимый объем
данных, определяемый текущим окном. Если же в этом случае значение те!
кущего окна равно нулю (нулевое окно), то передается пробный сегмент
(window probe), содержащий один октет данных, и таймер запускается снова.
Если сообщение с обновленным значением окна было утеряно, или получа!
тель по!прежнему отказывается изменить его размер, будет получено под!
тверждение, содержащее текущее значение окна. Такая ситуация, когда полу!
чатель не может принимать дополнительные данные, может продлиться доста!
точно долго. Например, пользователь может приостановить терминальный
вывод и уйти на обед. В этом случае отправитель будет периодически посы!
лать пробные сегменты, а его окно будет по!прежнему закрыто.
Следующий таймер, который мы рассмотрим, — Этот
таймер предназначен для мониторинга каналов, по которым не передают!
ся данные, и которые возможно в действительности прекратили свое су!
ществование, например, из!за аварийного останова одной из систем. Если
за определенный промежуток времени данные по каналу переданы не были,
модуль TCP отправляет пробный сегмент keepalive, ожидая в ответ либо
подтверждения (это означает, что задержка в передаче данных временная),
либо сообщения сброса канала (RST). Если получен сегмент RST, канал
будет закрыт. Если после нескольких попыток, не будет получен отклик,
канал будет уничтожен.
Последний таймер из рассматриваемых, это (2MSL — двойное
максимальное время жизни сегмента в сети). Модуль TCP запускает этот
таймер, когда производится завершение связи, и уже отправлено подтвер!
ждение полученному сегменту FIN. При этом отправитель не знает, получе!
но ли его подтверждение. Поэтому он некоторое время ждет возможного
повторного получения сегмента FIN, чтобы в свою очередь повторить под!
тверждение. Таймер запускается при переходе коммуникационного узла ка!
нала в состояние TIME!WAIT, и после его срабатывания соответствующий
управляющий блок удаляется. Заметим, что это ожидание не блокирует про!
цесс, выполнивший системный вызов close(2) сокета, отвечающего за дан!
ный канал. Другими словами, управляющий блок может существовать еще
некоторое время после закрытия дескриптора сокета.
Поддержка сети в UNIX System V
Многие из аспектов реализации поддержки сети в BSD UNIX справедли!
вы и для архитектуры сетевых протоколов UNIX System V. Однако сам ме!
www.books-shop.com
сети в UNIX System V 471
ханизм обеспечения взаимодействия модулей существенно отличается. Для
поддержки сети в UNIX System V используется подсистема STREAMS,
рассмотренная в главе 5.
Подсистема ввода/вывода, основанная на архитектуре STREAMS, позволяет
в полной мере отразить уровневую структуру коммуникационных протоко!
лов, когда каждый уровень имеет стандартные интерфейсы взаимодействия
с другими (верхним и нижним) уровнями, и может работать независимо от
конкретной реализации протоколов на соседних уровнях. Архитектура
STREAMS полностью соответствует этой модели, позволяя создавать драй!
веры, которые являются объединениями независимых модулей.
Обмен данными между модулями STREAMS также соответствует характеру
взаимодействия отдельных протоколов: данные передаются в виде сообще!
ний, а каждый модуль выполняет требуемую их обработку. На рис. 6.30 при!
ведена схема реализации протоколов TCP/IP в UNIX System V. Используя
терминологию предыдущей главы, можно отметить, что модуль IP является
гибридным мультиплексором, позволяя обслуживать несколько потоков,
приходящих от драйверов сетевых адаптеров (в данном случае Ethernet и
FDDI), и несколько потоков к модулям транспортных протоколов (TCP и
UDP), а модули TCP и UDP — верхними мультиплексорами, обслуживаю!
щими прикладные программы, такие как сервер маршрутизации
сервер удаленного терминального доступа сервер FTP a
также программы!клиенты пользователей (например
Рис. 6.30. Реализация протоколов TCP/IP на основе архитектуры STREAMS
Анализ программного обеспечения сетевой поддержки показывает, что как
правило сетевые и транспортные протоколы, составляющие базовый стек
TCP/IP, поставляются одним производителем, в то время как поддержка
www.books-shop.com
472 Глава 6. сети в операционной системе UNIX
уровней сетевого интерфейса и приложений может осуществляться продук!
тами различных разработчиков. Соответственно, можно выделить два ос!
новных интерфейса взаимодействия, которых позволяет
обеспечить совместную работу различных компонентов программного обес!
печения. Первый интерфейс определяет взаимодействие транспортного
уровня и уровня приложений и называется интерфейсом поставщика транс!
портных услуг (Transport Provider Interface, TPI). Второй интерфейс устанав!
ливает правила и формат сообщений, передаваемых между сетевым уровнем
и уровнем сетевого интерфейса, и называется интерфейсом поставщика услуг
канала данных (Data Link Provider Interface,
Вообще говоря, сетевая архитектура, основанная на архитектуре
STREAMS, позволяет обеспечить поддержку любого стека протоколов, со!
ответствующего модели OSI. Поэтому выражаясь более точно, перечис!
ленные интерфейсы определяют взаимодействие транспортного уровня и
уровня сеанса, и уровня канала и сетевого уровня, соответственно. Эти
рассуждения проиллюстрированы на рис.
TCP/IP
процесс
telnetd, talk
% *
Модули TCP,
Т
Модуль IP
Л
Т
Драйвер сетевого
FDDI
TPI
OSI
Уровень
приложений
Уровень
представления
Уровень
Транспортный
уровень
Сетевой
уровень
канала данных
Физический
Рис. 6.31. Интерфейсы взаи%
модействия модулей протоко%
лов
Интерфейс TPI
TPI представляет собой интерфейс предоставления услуг транспортного
уровня OSI модели как с предварительным установлением соединения
(connection mode), так и без установления соединения (connectionless
mode). Стандартизация этого интерфейса позволяет изолировать особен!
ности реализации транспортного уровня от потребителя этих услуг и, тем
самым, предоставить возможность разработки программного обеспечения,
независимо от конкретного протокола и услуг им предоставляемых.
Говоря еще более строго, данные интерфейсы самой моделью OSI. Однако в
данной главе мы остановимся на практической реализации этих интерфейсов в подсисте!
ме STREAMS.
www.books-shop.com
сети в UNIX System V 473
TPI определяет набор и формат сообщений, с помощью которых протоко!
лы верхнего уровня взаимодействуют с модулем транспортного протокола.
Таким образом, TPI является интерфейсом между поставщиком транс!
портных услуг (transport provider) и пользователем этих услуг (transport user).
Эти сообщения определяют транспортные примитивы (transport primitive),
или команды, и могут иметь следующий формат:
Сообщение состоит из блока типа за которым может сле!
довать несколько блоков Блок содержит управ!
ляющую информацию, включая тип команды и ее аргументы. В бло!
ках передаются ассоциированные с командой данные при!
кладной программы.
Сообщение состоит из одного блока который содержит
управляющую информацию, включая тип команды и ее аргументы.
Сообщение состоит из одного или более блоков в которых
передаются данные прикладной программы.
Таблица 6.10. Основные управляющие сообщения TPI
Транспортный
примитив
Тип со[
общения
Значение
т BIND REQ м PROTO Запрос на связывание.
Этот примитив инициируется пользователем транс%
портных услуг и запрашивает связывание потока с
адресом протокола. Сообщение состоит из одного
блока который содержит значение адреса и
заказанное максимальное число запросов, ожидаю%
щих обслуживания со стороны пользователя. Послед%
ний параметр игнорируется для транспортных услуг
без предварительного установления связи.
Блок содержит следующие поля:
Тип —
ADDR_length Размер адреса протокола
f set Смещение адреса в блоке
Максимальное число запросов, ожи%
дающих обслуживания
T_BIND_ACK Подтверждение получения запроса на связывание.
Этот примитив отправляется пользователю транс%
портных услуг и означает, что поток был связан с
адресом протокола, заказанное максимальное чис%
ло ожидающих запросов допустимо и поток был ак%
тивизирован. Сообщение состоит из одного блока
M_PCPROTO, содержащего значения указанных па%
раметров. Заметим, что возвращаемый адрес может
не совпадать с адресом, указанным в запросе
T_BIND_REQ.
Блок M_PROTO содержит следующие поля:
Тип примитива — T_BIND_ACK
Размер адреса протокола
f set Смещение адреса в блоке
Максимальное число запросов,
ожидающих обслуживания
www.books-shop.com
474 Глава 6. сети в операционной системе UNIX
Таблица (продолжение)
Транспортный Тип со[ Значение
примитив общения
Т UNBIND REQ M PROTO Запрос на уничтожение связывания.
Этот примитив инициируется пользователем
транспортных услуг и запрашивает у поставщика
уничтожение ранее созданного связывания пото%
ка с адресом протокола и потока.
Т CONN REQ M PROTO Запрос на установление связи.
Этот примитив применим только для транспортных
услуг с предварительным установлением связи. Он
инициируется пользователем транспортных услуг и
запрашивает установление связи с указанным ад%
ресатом. Сообщение состоит из одного блока
за которым может следовать один или
несколько блоков типа M_DATA, содержащих при%
кладные данные, определенные пользователем.
Заметим, что протокол TCP не позволяет переда%
вать прикладные данные вместе с запросом. Блок
содержит значение адреса получателя и
опции, связанные с этим примитивом.
Блок содержит следующие поля:
Тип примитива —
DEST_length Размер адреса протокола
Смещение адреса получателя в бло%
ке
Размер опций
ОРТ offset опций в PROTO
Т CONN M PROTO Индикация установления связи.
Этот примитив применим только для транспорт%
ных услуг с предварительным установлением свя%
зи и свидетельствует о том, что удаленным поль%
зователем с указанным адресом был сделан за%
прос на установление связи. Сообщение состоит
из одного блока м за которым может сле%
довать один или несколько блоков типа M_DATA,
содержащих прикладные данные, определенные
пользователем. Блок содержит значение
адреса удаленного пользователя, отправившего
запрос на установление связи, а также опции,
связанные с этим примитивом.
Блок содержит следующие поля:
Тип примитива —
SRC_length Размер адреса протокола
Смещение адреса отправителя в
блоке
OPT_length Размер опций
OPT_offset Смещение опций в блоке
Идентификатор соединения
www.books-shop.com
сети в UNIX System V 475
Таблица 6.10 (продолжение)
примитив
Тип со[
общения
Значение
Ответ на запрос на установление связи.
Этот примитив применим только для транспорт%
ных услуг с предварительным установлением свя%
зи и свидетельствует о том, что поставщик транс%
портных услуг принимает предшествующий за%
прос на установление связи. Сообщение состоит
из одного блока за которым может сле%
довать один или несколько блоков типа
содержащих прикладные данные, определенные
пользователем. Блок PROTO содержит указа%
тель на очередь чтения потока, который будет
обрабатывать запрос.
Блок содержит следующие поля:
PRIM_type Тип примитива —
Указатель на очередь потока, который
должен быть использован в качестве
узла созданного соединения
OPT_length Размер опций
f set Смещение опций в блоке
Идентификатор соединения
T_CONN_CON Подтверждение установления связи.
Этот примитив применим только для транспорт%
ных услуг с предварительным установлением свя%
зи. Он отправляется пользователю транспортных
услуг в качестве подтверждения установления
связи с удаленным пользователем. Сообщение
состоит из одного блока за которым
может следовать один или несколько блоков типа
содержащих прикладные данные, опре%
деленные пользователем. Блок содер%
жит значение размера адреса, сам адрес удален%
ного пользователя, обслуживающего соединение,
а также опции, связанные с этим примитивом.
Блок содержит следующие поля:
Тип примитива — T_CONN_CON
RES_length Размер адреса протокола
set Смещение адреса удаленного узла в
блоке
OPT_length Размер опций
ОРТ offset Смещение опций в блоке PROTO
www.books-shop.com
476 Глава 6. сети в операционной системе UNIX
Таблица 6.10 (продолжение)
Транспортный
примитив
Тип
общения
Значение
Т DISCON REQ M_PROTO Запрос на разрыв связи.
Этот примитив применим только для транспортных
услуг с предварительным установлением связи. Он
инициируется пользователем транспортных услуг и
свидетельствует либо об отказе пользователем в
установлении связи, либо о желании пользователя
разорвать уже существующее соединение для дан%
ного потока. Сообщение состоит из одного блока
за которым может следовать один или
несколько блоков типа M_DATA, содержащих при%
кладные данные, определенные
Блок M_PROTO содержит следующие поля:
PRIM_type Тип примитива —
Идентификатор соединения
Т DISCON IND
Т ORDREL REQ
Т ORDREL IND
M_PROTO Индикация разрыва связи.
Этот примитив применим только для транспорт%
ных услуг с предварительным установлением свя%
зи и свидетельствует о том, что удаленный поль%
зователь либо отказывает в установлении связи,
либо желает разорвать существующее соедине%
ние. Сообщение состоит из одного блока
M_PROTO, за которым может следовать один или
несколько блоков типа содержащих при%
кладные данные, определенные пользователем.
Блок M_PROTO содержит следующие поля:
Тип примитива — T_DISCON_IND
Причина разрыва связи
Идентификатор соединения
M_PROTO Запрос на "аккуратное" прекращение связи.
Этот примитив применим только для транспортных
услуг с предварительным установлением связи и
указывает поставщику транспортных услуг, что поль%
зователь завершил передачу данных. При этом со%
единение переходит в симплексный режим, позво%
ляя пользователю принимать данные от удаленного
узла. Сообщение состоит из одного блока
M_PROTO Индикация "аккуратного" прекращения связи.
Этот примитив применим только для транспорт%
ных услуг с предварительным установлением свя%
зи и отправляется пользователю транспортных
услуг, свидетельствуя о том, что удаленный поль%
зователь соединения завершил передачу данных.
При этом соединение переходит в симплексный
режим, позволяя пользователю передавать дан%
ные удаленному узлу. Сообщение состоит из од%
ного блока м PROTO.
www.books-shop.com
сети в UNIX System V 477
Таблица 6.10 (продолжение)
Транспортный
примитив
Тип
общения
Т REQ M PROTO Запрос на передачу данных.
Этот примитив применим только для транспорт%
ных услуг без предварительного установления
связи и отправляется пользователем транспорт%
ных услуг в качестве запроса на передачу дата%
граммы. Сообщение состоит из одного блока
M_PROTO, за которым может следовать один или
несколько блоков типа содержащих при%
кладные данные пользователя. Блок
содержит значение размера адреса и сам адрес
получателя а также опции, связан%
ные с этим примитивом.
Блок содержит следующие поля:
PRIM_type Тип примитива —
DEST_length Размер адреса протокола
Смещение адреса получателя в бло%
ке
Размер опций
ОРТ offset Смещение опций в блоке PROTO
Т M PROTO Индикация получения данных.
Этот примитив применим только для транспорт%
ных услуг без предварительного установления
связи и указывает пользователю, что поставщи%
ком транспортных услуг получена датаграмма от
удаленного узла. Сообщение состоит из одного
блока за которым может следовать
один или несколько блоков типа содер%
жащих прикладные данные пользователя. Блок
содержит значение адреса отправителя
датаграммы, а также опции, связанные с этим
примитивом.
Блок содержит следующие поля:
Тип примитива —
Размер адреса протокола
SRC_offset Смещение адреса отправителя в
блоке
OPT_length Размер опций
ОРТ offset Смещение опций в блоке M PROTO
www.books-shop.com
478 Глава 6. сети в операционной системе UNIX
Таблица 6.10 (продолжение)
Транспортный
примитив
Тип со[
общения
Значение
Т UDERROR M PROTO Сообщение об ошибке
Этот примитив применим только для транспортных
услуг без предварительного установления связи и
указывает пользователю, что датаграмма с указан%
ным адресом получателя и опциями вызвала ошиб%
ку. Сообщение состоит из одного блока
содержащего размер адреса и сам адрес получа%
теля, опции, а также код ошибки, зависящий от
конкретного транспортного протокола.
Блок содержит следующие поля:
Тип примитива — T_UDERROR_IND
DEST_length Размер адреса протокола
DEST_offset Смещение адреса отправителя в
блоке
Размер опций
f set Смещение опций в блоке
ERROR_type Код ошибки
Запрос на передачу данных.
Этот примитив применим только для транспортных
услуг без предварительного установления связи и
информирует поставщика транспортных услуг, что
сообщение содержит пакет данных интерфейса
(Transport Interface Data Unit, Одно или более
таких сообщений формируют пакет данных прото%
кола TSDU. Сообщение состоит из одного блока
за которым может следовать один или
несколько блоков типа содержащих при%
кладные данные пользователя. Блок со%
держит флаг lag, указывающий, является
ли следующее сообщение частью
того же TSDU. На основании этого флага постав%
щик транспортных услуг компонует транспортные
пакеты TSDU. Передача данных с помощью запро%
сов позволяет сохранить границы
записи при передаче. Заметим, что протоколом
TCP данная возможность не поддерживается.
M_PROTO Индикация получения данных.
Этот примитив применим только для транспорт%
ных услуг без предварительного установления
связи и информирует пользователя, что сообще%
ние содержит пакет данных интерфейса TIDU.
Сообщение состоит из одного блока M_PROTO, за
которым может следовать один или несколько
блоков типа содержащих прикладные
данные удаленного пользователя. Блок
содержит флаг позволяющий поль%
зователю определить границы TSDU.
www.books-shop.com
сети в UNIX System V 479
Таблица 6.10 (продолжение)
Транспортный Тип со[
примитив общения
Значение
Т EXDATA REQ M PROTO Запрос на передачу экстренных данных.
Этот примитив аналогичен но слу%
жит для передачи экстренных данных. Протокол
TCP поддерживает передачу экстренных данных с
помощью функции t_snd(3N) с аргументом flags,
содержащим флаг T_EXPEDITED и, возможно,
Т MORE.
Т EXDATA M PROTO Индикация получения экстренных данных.
Этот примитив аналогичен T_DATA_IND, но служит
для передачи пользователю экстренных данных.
Положительное подтверждение.
Этот примитив сообщает пользователю транс%
портных услуг, что предшествующий примитив,
инициированный им, был успешно принят по%
ставщиком транспортных услуг. В то же время,
получение подтверждения не означает, что по%
ставщиком были совершены какие%либо действия,
связанные с предыдущим примитивом. Сообще%
ние состоит из одного блока M_PCPROTO в кото%
ром хранится тип подтвержденного примитива
CORRECT prim.
Т ERROR ACK M PCPROTO Сообщение об ошибке.
Этот примитив сообщает пользователю услуг,
последний примитив, инициированный им, вызвал
ошибку. Получение этого примитива может рассмат%
риваться как отрицательное подтверждение, свиде%
что никаких действий, связанных с
ошибочным примитивом, не было предпринято. Со%
общение состоит из одного блока со%
держащего тип примитива, вызвавшего ошибку, код
TLI и код системной ошибки UNIX.
Блок M_PCPROTO содержит следующие поля:
PRIM_type Тип примитива —
Тип ошибочного примитива
TLI_error Код ошибки TLI
UNIX error Код системной ошибки UNIX
Т INFO REQ M PCPROTO Запрос на получение параметров транспортного
протокола.
Этот примитив служит для запроса пользователем
значений размеров различных параметров прото%
кола, а также информации о текущим состоянии
поставщика транспортных услуг. Сообщение со%
стоит из одного блока PCPROTO.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
480 Глава 6. сети в операционной UNIX
Таблица 6.10 (продолжение)
Транспортный Тип со[ Значение
примитив общения
T_INFO_ACK M_PCPROTO Параметры транспортного протокола.
Этот примитив служит для передачи пользователю
ранее запрошенных с помощью пара%
метров транспортного протокола. Сообщение состо%
ит из одного блока содержащего ин%
формацию, часть из которой возвращается функци%
ей t_open(3N), рассмотренной в разделе "Програм%
мный интерфейс ранее в этой главе.
Блок M_PCPROTO состоит из следующих полей:
TSDU_size
ETSDU_size
CDATA size
DDATA size
ADDR size
OPT size
size
SERV type
CURRENT state
PROVIDER_flag
Тип примитива — T_INFO_ACK
Определяет максимальный раз%
мер пакета данных протокола
TSDU
Определяет максимальный раз%
мер пакета экстренных данных
протокола ETSDU
Определяет максимальный обь%
ем данных, передаваемых при
установлении связи. Соответст%
вует полю connect структуры
функции t_open(3N)
Определяет максимальный
ем данных, передаваемых при
разрыве связи. Соответствует
полю структуры info
функции
Определяет максимальный
ем транспортного протокола.
Соответствует полю addr струк%
туры функции
Определяет размер опций для
данного протокола. Соответству%
ет полю options структуры
функции
Определяет размер пакета дан%
ных интерфейса TIDU
Определяет тип транспортных
услуг, предоставляемых постав%
щиком
Соответствует полю servtype
структуры info функции
t_open(3N)
Определяет текущее состояние
поставщика транспортных услуг
Определяет дополнительные
характеристики поставщика
транспортных услуг
www.books-shop.com
в UNIX System V 481
Таблица 6.10 (окончание)
Транспортный Тип со[
примитив общения
Значение
Т REQ PROTO Управление опциями протокола.
Этот примитив позволяет пользователю получить
или установить опции протокола. Сообщение со%
стоит из одного блока M_PROTO, включающего
следующие поля:
Тип примитива —
OPT_length Размер опций
Смещение опций в блоке
Флаги, определяющие характер
запроса пользователя:
T_NEGOTIATE — установить опции,
указанные пользователем. В ре%
зультате опции, установленные
поставщиком, могут отличаться от
заказанных;
Т_СНЕСК — проверить, поддержи%
ваются ли опции, указанные поль%
зователем, поставщиком;
T_DAFAULT — возвратить значения
опций протокола.
Т OPTMGMT АСК M PCPROTO Положительное подтверждение.
Этот примитив подтверждает завершение опера%
ции с опциями протокола, заказанными пользова%
телем. Сообщение состоит из одного блока
включающего те же поля, что и
Т OPTMGMT REQ.
Взаимодействие с прикладными процессами
Рассмотренный ранее программный интерфейс ТЫ полностью реализует
функциональность TPI. Легко заметить соответствие между отдельными
функциями ТЫ и примитивами TPI, приведенными в табл. Схема
вызова функций ТЫ и обмена соответствующими примитивами TPI между
клиентом и сервером для типичного TCP!сеанса приведена на рис. 6.32.
Программный интерфейс потоков был рассмотрен в главе 5 при обсужде!
нии подсистемы STREAMS. Основными функциями, обеспечивающими
передачу и получение сообщений, являются системные вызовы и
getmsg(2). Таким образом, большинство функций ТЫ, составляющих про!
граммный интерфейс доступа прикладных процессов к транспортным про!
токолам, являются удобной оболочкой (реализованной в виде библиотеки,
например, более фундаментальным системным вызовам
и getmsg(2).
www.books-shop.com
482 Глава 6. сети в операционной UNIX
Рис. 6.32. Функции TLI и примитивы TPI
В качестве примера рассмотрим функцию Ее реализация
может иметь следующий вид:
www.books-shop.com
сети в UNIX System V 483
int struct t_call *sndcall,
struct t_call
{
struct
struct T_conn_con
struct T_ok_ack
struct T_error_ack
struct strbuf connect, ack, confirm,
struct netbuf addr, opt, udata;
char
int
адреса буферов netbuf запроса sndcall*/
addr =
opt =
udata =
поля структуры strbuf для формирования управляющей части
(блок сообщения
= + + opt.len;
= Т conn req) +
+
buf = (char
= buf;
поля заголовка блока M_PROTO сообщения в
соответствии с форматом структуры
connreq = (struct T_conn_req
=
connreq>DEST_length =
connreq>DEST_offset = sizeof (struct
buf +=
=
= +
buf +=
поля структуры strbuf для формирования блока данных (блок
=
=
=
запрос Т CONN REQ поставщику транспортных услуг по потоку
&connect,
к приему Выделим максимальный размер для
получения негативного подтверждения, поскольку Т
занимает больше
=
= (char
является приоритетным, поэтому установим флаг RS HIPRI.
До получения подтверждения не предпринимаем никаких
www.books-shop.com
484 Глава 6. сети в UNIX
flags = RS_HIPRI;
(struct *)0,
okack = (struct T_ok_ack
получено ли положительное или негативное
if ==
{
/*Если подтверждение подготовимся к получению согласия
удаленного пользователя на установление связи (примитив
if (recvcall != NULL)
{
=
opt =
udata =
= T_conn_con) + +
= T_conn_con)
+ +
buf = (char
= buf;
=
=
=
примитив
conncon = (struct T_conn_con
if ==
{
/*Если это действительно согласие, заполним структуру rcvcall для
пользователя
=
=
offset,
закончилось удачно — возвращаем
}
}
else
{
/*В случае отказа мы готовы обработать примитив
else
www.books-shop.com
сети в UNIX System V
/*Если получен примитив — обработаем
errack = (struct T_error_ack
}
}
Подобным образом реализовано большинство функций ТЫ. Заметим, что в
конкретном случае использования транспортного протокола TCP прием и
передача данных осуществляются в виде потока, не содержащего каких!либо
логических записей. В этом случае не требуется формирование примитивов
типа и T_DATA_IND. В то же время, для передачи и получения
экстренных данных будут использованы примитивы T_EXDATA_REQ и
При использовании протокола UDP все данные будут пере!
даваться С ПОМОЩЬЮ примитивов И
Описанная реализация программного интерфейса ТЫ имеет один сущест!
венный недостаток — операции функций не являются атомарными. Дру!
гими словами, выполнение функции может быть прервано
другими процессами, которые могут также связываться с удаленным узлом.
Это возможно, поскольку выполнение значительной части операций про!
исходит в режиме задачи. Если для функции нарушение ато!
марности допустимо, то ряд функций, таких, например, как связывание
получение информации и установка
или получение опций протокола должны быть защищены
от возможного нарушения целостности данных по причине прерывания
операции. Единственным способом гарантировать атомарность является
перевод выполнения критических участков (например, между отправлени!
ем примитива и получением подтверждения от поставщика транспортных
услуг) в режим ядра. Для этого подсистема STREAMS предлагает механизм
обмена управляющими командами с помощью вызова ioctl(2).
Однако с помощью как было показано в разделе "Подсистема
STREAMS" главы 5, можно формировать лишь сообщения типа
Для преобразования этих сообщений в примитивы TPI служит дополни!
тельный модуль встраиваемый в поток между головным и
транспортным модулями. На рис. 6.33 показано местоположение модуля
и схематически отображены его функции.
Для всех сообщений STREAMS, за исключением сообщений ко!
торые генерируются головным модулем в ответ на системный вызов
I_STR, . . . модуль является прозрачным, т. е. он
просто передает эти сообщения следующему модулю вниз по потоку без
какой!либо обработки. Несколько сообщений M_IOCTL обрабатываются
модулем и преобразуются в соответствующие примитивы TPI.
www.books-shop.com
486 Глава 6. сети в операционной UNIX
При этом вызов ioctl(2) имеет следующий формат:
struct strioctl my strioctl;
=
=
= size;
= (char *)buf
Интерфейс
системных
вызовов
Рис. 6.33. Архитектура доступа к транспортным услугам
При вызове ioctl(2) поле size устанавливается равным размеру соответст!
вующего примитива TPI, определенного полем cmd и расположенного в
буфере При возврате из функции поле содержит размер прими!
www.books-shop.com
сети в UNIX System V
тива, возвращенного поставщиком транспортных услуг и расположенного
в буфере
Модуль служит для обработки следующих команд
Значение cmd Обработка модулем
Команда преобразуется в примитив T_BIND_REQ. При успеш%
ном завершении функции ioctl(2) в буфере buf находится при%
митив
TI_UNBIND Команда преобразуется в примитив T_UNBIND_REQ. При ус%
пешном завершении функции в буфере находится
примитив
TI_GETINFO Команда преобразуется в примитив При успеш%
ном завершении функции ioctl(2) в буфере buf находится при%
митив
Команда преобразуется в примитив При ус%
пешном завершении функции ioctl(2) в буфере buf находится
примитив т АСК.
Интерфейс DLPI
DLPI определяет интерфейс между протоколами уровня канала данных
(data link layer) модели OSI, называемыми поставщиками услуг уровня ка!
нала данных и протоколами сетевого уровня, называемыми пользователя!
ми услуг уровня канала данных. В качестве примера пользователей услуг
уровня канала данных можно привести такие протоколы, как IP, IPX или
CLNS. С другой стороны, поставщик услуг уровня канала данных непо!
средственно взаимодействует с различными сетевыми устройствами, обес!
печивающими передачу данных по сетям различной архитектуры
(например, Ethernet, FDDI или ATM) и использующими различные физи!
ческие среды передачи.
Для обеспечения независимости DLPI от конкретной физической сети
передачи драйвер уровня канала данных состоит из двух частей: верхней
аппаратно независимой и нижней аппаратно зависимой. Аппаратно неза!
висимая часть драйвера обеспечивает предоставление общих услуг, опре!
деленных интерфейсом DLPI, а также поддержку ряда потенциальных
пользователей, представляющих семейства протоколов TCP/IP, NetWare и
Аппаратно зависимая часть непосредственно взаимодействует с сете!
вым адаптером.
На рис. 6.34 приведена структура драйвера поставщика услуг уровня кана!
ла данных. Обмен данными между аппаратно независимой частью драйве!
ра и пользователем услуг осуществляется в виде сообщений STREAMS,
формат и назначение которых и определяется спецификацией DLPI (т. н.
примитивы DLPI).
www.books-shop.com
Глава 6. в операционной системе UNIX
Во время инициализации и последующей передачи данных аппаратно не!
зависимая часть драйвера вызывает необходимые функции аппаратно за!
висимой части. Напротив, при поступлении данных из сети, аппаратно
зависимая часть помещает пакеты данных, или кадры, непосредственно в
очередь чтения аппаратно независимой части. Обе части совместно ис!
пользуют набор переменных и флагов для взаимной синхронизации и кон!
троля передачи.
Рис. 6.34. Структура драйвера уровня канала данных
Пользователь получает доступ к услугам поставщика услуг уровня канала
данных через точку доступа к услугам (Service Access Point, SAP), исполь!
зуя сообщения STREAMS для обмена данными. Поскольку один постав!
щик может иметь несколько пользователей, например IP и IPX, в его за!
дачу входит маршрутизация данных, полученных от физической сети, к
нескольким точкам доступа. Для этого каждый пользователь идентифици!
рует себя с помощью адреса SAP, который сообщает поставщику, исполь!
зуя примитив связывания (DL_BIND_REQ) потока с точкой доступа к услу!
гам уровня канала данных.
Поскольку аппаратно зависимая часть драйвера может обслуживать не!
сколько сетевых адаптеров, каждый сетевой интерфейс идентифицируется
точкой физического подключения (Physical Point of Attachment, PPA). При
этом спецификация DLPI определяет два типа поставщиков услуг. По!
ставщик услуг первого типа (style 1) производит назначение РРА, исходя
из старшего и младшего номеров используемого специального файла уст!
ройства (указанного в вызове Обычно каждый адаптер, обслужи!
ваемый драйвером, ассоциирован со старшим номером, а младший номер
используется для создания клонов (см. раздел "Клоны" главы 5). Напро!
www.books-shop.com
в UNIX System V 489
тив, поставщик второго типа (style 2) позволяет пользователю явно указать
РРА уже после открытия потока с помощью примитива присоединения
Использование поставщиков второго типа является бо!
лее предпочтительным, например, когда одна физическая сеть поддержи!
вает создание независимых логических, или виртуальных каналов передачи
данных (например, каналы ISDN В и D). В этом случае идентификатор
РРА, передаваемый примитивом DL_ATTACH_REQ, содержит также иден!
тификатор логического канала. Схема описанных точек доступа приведена
на рис. 6.35.
Пользователь
услуг уровня
канала данных
Пользователь
услуг уровня
канала данных
Пользователь
услуг уровня
канала данных
DLPI
Поставщик
услуг уровня
канала данных
Сетевые адаптеры
Рис. 6.35. Доступ к услугам поставщика услуг уровня канала данных
DLPI определяет три различных режима передачи данных (или типов ус!
луг), позволяющих обеспечить различные требования протоколов верхнего
уровня и поставщиков услуг уровня канала данных:
1. Режим с предварительным установлением связи
2. Режим без предварительного установления связи с подтверждением
3. Режим без предварительного установления связи без подтверждения
В данном разделе мы остановимся только на режиме без предварительного
установления связи без подтверждения. Заметим, что для традиционных
технологий локальных сетей используется именно этот тип услуг уровня
канала данных.
Поскольку дальнейшее обсуждение будет касаться преимущественно ком!
муникационной инфраструктуры локальных сетей, кратко остановимся на
логическом делении уровня канала данных модель OSI в соответствии со
стандартом IEEE 802. Применяемые сегодня технологии локальных сетей
существенно отличаются друг от друга, как по физической среде и топо!
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
490 Глава 6. сети в операционной UNIX
так и по способу передачи данных в этой физической среде и фор!
мату передаваемых данных. Поэтому стандарт IEEE 802 разделяет прото!
колы локальных сетей на два логических подуровня:
Верхний независимый от среды передачи подуровень, названный
уровнем управления каналом (Logical Link Control, LLC),
определенный стандартом IEEE 802.2.
Нижний зависимый от среды передачи подуровень, названный уров!
нем управления доступом к среде передачи (Media Access Control,
MAC), определенный стандартами IEEE 802.3 для протокола
CSMA/CD, IEEE 802.4 для протокола Token Bus и IEEE 802.5 для
Token Ring.
Доступ к среде передачи
Общим в наиболее распространенных технологиях локальных сетей явля!
ется то, что несколько сетевых устройств совместно используют одну и ту
же среду передачи данных, и соответственно делят между собой полосу
пропускания сети. Для корректного и эффективного использования сете!
вых ресурсов необходим механизм контроля доступа к физической среде
передачи, который и обеспечивается протоколами уровня MAC.
Первым по известности в ряду этих протоколов стоит CSMA/CD (Carrier
Sense Multiple Access with Collision Detection). При этом методе доступа
сетевые устройства конкурируют между собой за право передачи по прин!
ципу "кто успел — тот и съел". Основной принцип заключается в том, что
сетевое устройство может начать передачу данных, только если сеть сво!
бодна. Однако при этом возникают ситуации, называемые коллизиями,
когда два сетевых устройства начинают передавать данные одновременно.
Естественно в этом случае данные не могут быть использованы, и на вре!
мя коллизии сеть становится недоступной. Время коллизии может быть
сокращено, если передающее устройство продолжает "слушать" сеть. Мож!
но сформулировать следующие правила работы CSMA/CD:
1. Если сеть свободна, сетевое устройство может начать передачу, в про!
тивном случае, устройство продолжает "слушать" сеть.
2. Если в процессе передачи устройством обнаружена коллизия, устрой!
ство должно передать короткий неформатированный сигнал, чтобы га!
рантировать, что остальными устройствами коллизия также обнаруже!
на, после чего немедленно прекратить передачу.
После передачи неформатированного сигнала устройство ожидает слу!
чайный промежуток времени, после чего начинает передачу, если сеть
свободна.
Передача данных в CSMA/CD осуществляется в виде пакетов, или кадров,
для которых существуют два основных формата в соответствии со специ!
www.books-shop.com
сети в UNIX System V 491
Ethernet 2.0 и стандартом IEEE 802.3. Последний был разрабо!
тан на основе спецификации Ethernet, однако форматы кадров несколько
различаются, как это показано на рис. 6.36 и 6.37.
Рис. 6.36. Формат кадра Ethernet
Рис. 6.37. Формат кадра IEEE 802.3
Существенным различием между двумя форматами является то, что поле
"тип пакета" (Ethertype) кадра Ethernet используется для обозначения раз!
мера кадра в случае IEEE 802.3. В кадре Ethernet это поле идентифицирует
сетевой протокол, использующий данный кадр. К счастью, значения иден!
тификаторов протоколов превышают 1500 — максимальный размер данных
кадра, поэтому драйвер может легко определить используемый формат.
Другой, также часто используемый метод доступа, используемый в кольце!
вых топологиях сетей, заключается в передаче между сетевыми устройст!
вами, подключенными к кольцу, маркера — небольшого пакета, играю!
щего роль эстафетной палочки (например, в сетях Token Ring). Пока ни
одно из устройств не передает данные, маркер, циркулирующий в кольце,
имеет флаг "свободный". При необходимости передачи устройство дожида!
ется свободного маркера, изменяет его флаг на "занятый" и передает пакет
данных сразу же за маркером. Поскольку теперь в сети отсутствует сво!
бодный маркер, все остальные устройства должны воздержаться от переда!
чи. При этом устройство, которому адресованы данные, при получении
скопирует их в свой буфер. Занятый маркер совершает круг и возвращает!
ся к передавшему пакет устройству. Последнее извлекает из сети маркер и
пакет данных, изменяет флаг маркера на "свободный" и вновь передает его
в кольцо. Таким образом, ситуация возвращается к исходной.
Технология FDDI, также использует метод передачи маркера, правда, не!
сколько отличающийся от только что описанного. Основное отличие за!
ключается в том, что устройство сразу же после передачи пакета помещает
www.books-shop.com
492 Глава 6. сети в операционной системе UNIX
свободный маркер. Если какое!либо устройство желает передать данные,
оно может воспользоваться этим маркером, также поместив новый сво!
бодный маркер вслед за переданным пакетом. Таким образом, в кольце
может одновременно существовать несколько пакетов, что повышает эф!
фективность использование пропускной способности сети.
Формат кадров в сетях Token Ring определяется двумя стандартами — IEEE
802.5 и Однако за исключением октета контроля доступа эти форматы
не отличаются друг от друга. Формат кадра IEEE 802.5 приведен на рис. 6.38.
Рис. 6.38. Формат кадра IEEE 802.5
Протокол LLC
Протокол LLC обеспечивает большую часть услуг уровня канала данных.
Этот протокол был разработан на основе другого протокола уровня канала
данных — HDLC, однако обладает меньшей функциональностью по срав!
нению со своим родителем.
Формат кадра LLC представлен на рис. 6.39. Основными полями заголовка
кадра являются DSAP и которые определяют адреса точек доступа (SAP)
соответственно отправителя и получателя данных. Кадр LLC также может со!
держать дополнительный заголовок SNAP (Sub!Network Access Point), также
называемый адресом логической точки доступа (Logical SAP, LSAP).
Рис. 6.39. Формат кадра LLC
www.books-shop.com
сети в UNIX System V 493
Инкапсуляция IP
При работе в локальной сети на базе технологии CSMA/CD возможны два
варианта инкапсуляции датаграмм IP в кадры уровней LLC и MAC.
Первый заключается в использовании кадров Ethernet 2.O. В этом случае
поле данных октетов) полностью принадлежит a SAP
адресуется полем "тип пакета", которое содержит значение параметра
Ethertype — индекса протокола верхнего уровня. В случае IP это значе!
ние равно 0x0800. Значения Ethertype для других протоколов приведены
в табл.
Таблица Значение Ethertype для некоторых протоколов
Поле Length IEEE802.3
0x0800 Internet IP (Ipv4)
0x0806
0x6003 DEC DECNET Phase IV Route
Novell IPX
Второй вариант предполагает использование формата IEEE 802.3. В этом
случае инкапсулируется в кадр а адресация SAP осу!
ществляется в заголовке SNAP с помощью идентификатора Ethertype.
При этом поля DSAP и SSAP не используются, и их значения устанавлива!
ются равными ОхАА. Заметим, что в этом случае максимальный размер IP!
составляет 1492 октета.
При передаче данных TCP/IP в сетях Token Ring используется формат
кадра IEEE 802.5, инкапсулирующий кадр LLC с заголовком SNAP, как
описано выше.
Внутренняя архитектура
Как уже говорилось, драйвер, реализующий поставщика услуг уровня ка!
нала данных, состоит из двух частей: аппаратно зависимой и аппаратно
независимой. Соответственно драйвер хранит отдельные структуры дан!
ных, необходимые для работы этих частей. Архитектура драйвера приведе!
на на рис. 6.40.
Для каждого обслуживаемого драйвером сетевого адаптера создается от!
дельная структура данных ig_t, описывающая характеристики
адаптера и содержащая необходимую для управления адаптером информа!
цию, а также статистику, являющуюся частью (Management
Information Base). Эта структура используется аппаратно независимой и
зависимой частями совместно, в том числе и для передачи определенной
информации между ними.
www.books-shop.com
494 Глава 6. сети в операционной системе UNIX
Рис. 6.40. Архитектура драйвера DLPI
В частности, эта структура содержит следующие поля:
ma j or Старший номер устройства, связанного с данным сетевым адаптером
Адрес начала области
Адрес конца области
Адрес начала базовой памяти
Адрес конца базовой памяти
www.books-shop.com
сети в UNIX System V 495
BOARD DISABLED
TX BUSY
TX QUEUED
Уровень прерывания
Максимальное число точек доступа (SAP)
Флаги состояния адаптера
Список статистических данных
Поле может включать следующие флаги:
Устанавливается драйвером после успешной инициализации
адаптера
Устанавливается драйвером при неудачной инициализации
адаптера. Этот флаг также может быть установлен, если драй%
вер определит нарушения в функционировании адаптера
Указывает на отсутствие ресурсов, например отсутствие необ%
ходимых буферов для передачи кадра
Указывает на наличие кадров, ожидающих передачи
Для каждого подключенного пользователя услуг, или, другими словами,
для каждой активной SAP драйвер создает структуру данных
описывающую тип и характеристики точки доступа. Приведем описание
некоторых полей этой структуры:
state Состояние SAP. Возможные состояния определены интерфейсом
DLPI. Исходное состояние точки доступа
Уникальный адрес (идентификатор) SAP
Флаги, определяющие дополнительные характеристики SAP
read_q Указатель на очередь чтения потока, связанного с SAP
write_q Указатель на очередь записи потока, связанного с SAP
Тип используемого протокола доступа и формат используемого
кадра. Возможные значения включают:
DL_CMACD IEEE 802.3
Ethernet 2.0
IEEE 802.4
IEEE 802.5
DL_HDLC ISO HDLC
Режим передачи данных. В локальных сетях обычно использует%
ся режим без установления связи без подтверждения DL CLDLS
Тип поставщика услуг: или
Указатель на структуру ig_t, связанную с сетевым
адаптером
Указатель на следующую точку доступа в списке активных SAP
Максимальный размер данных, которые могут быть переданы в
кадре
Минимальный размер данных, которые могут быть переданы в
кадре
bd
next_sap
spdu
www.books-shop.com
496 Глава 6. сети в системе UNIX
Дополнительные характеристики SAP хранятся в поле flags, которое мо!
жет включать следующие флаги:
Указывает, что через SAP передаются только кадры формата IEEE 802.3
Указывает, что через SAP передаются кадры формата LLC SNAP
PROMISCUOUS Указывает, что SAP работает в режиме отсутствия фильтрации кад!
ров (promiscuous mode), при котором SAP получает копии всех кад%
ров независимо от адреса точки доступа, которой они предназнача%
ются. Данный режим применяется, например, при создании прило%
жений мониторинга уровня канала данных
PRIVILEGED Указывает, что управление точкой доступа требует привилегий су%
перпользователя
Кроме того, драйвер хранит и обновляет статистическую информацию о
сетевом интерфейсе, представляющую собой набор счетчиков, связанных с
работой адаптера, и ассоциированных с ним точек доступа. Пользователь
может получить интересующую его статистику с помощью соответствую!
щей команды ioctl(2). Приведем в качестве примера описание некоторых
из этих счетчиков:
Общее число октетов, полученных адаптером
ifOutOctets Общее число октетов, переданных адаптером
Число переданных однонаправленных (unicast) пакетов
Число переданных групповых (multicast) и широковещатель%
ных (broadcast) пакетов
Число полученных, но отброшенных правильных пакетов
Число полученных однонаправленных (unicast) пакетов
Число полученных групповых (multicast) и широковещатель%
ных (broadcast) пакетов
Число пакетов, полученных с ошибкой
Число полученных пакетов, которые были отброшены из%за
неправильной SAP адресата
Число пакетов, находящихся в очереди на передачу
ifOutErrors Число пакетов, переданных с ошибкой
Число коллизий
Аппаратно независимая часть драйвера обрабатывает все запросы, посту!
пающие от пользователя услуг уровня канала данных. Для этого в драйвере
определены следующие функции (часть из них являются стандартными
точками входа STREAMS):
Точка входа ххореп Эта функция инициализирует SAP, свя%
занную с данным потоком. Функция проверяет наличие флага
и в случае его отсутствия возвращает ошибку.
Точка входа Эта функция сбрасывает текущее со%
SAP и устанавливает его равным
www.books-shop.com
сети в UNIX System V 497
(продолжение)
DLwput Точка входа xxput для очереди записи. Эта функция интер%
претирует примитивы DLPI и вызывает соответствующие процеду%
ры драйвера. В случае, если примитив содержит команду уровня
канала данных, например, запрос на передачу вызы%
вается функция которая производит формирование
кадра и вызов функции передачи кадра аппаратно зависимой
части драйвера. В случае, когда примитив содержит команду
ioctl(2), вызывается функция
Точка входа для очереди чтения. Функция
помещает каждый кадр, полученный от аппаратно зависимой части
драйвера, в очередь чтения потока, ассоциированного с адресуемой
SAP. В зависимости от формата кадра (протокола MAC) вызывается
соответствующая процедура, извлекающая данные и помещающая
их в сообщение услуги без предварительного
установления связи и без подтверждения), которое направляется
вверх по потоку пользователю услуг. Кроме того, просмат%
ривает список активных SAP для возможного копирования сообще%
ния в очереди потоков, имеющих тот же адрес точки доступа. По%
скольку функция DLrecv помещает кадр в очередь первого най%
денного потока с требуемым адресом SAP (см. описание функции
ниже), описанное поведение (} гарантирует, что все пользо%
ватели услуг уровня канала данных, зарегистрировавшие один и тот
же адрес SAP, получат свою копию пакета данных.
DLrecv Функция обработки полученного пакета. Эта функция определяет
формат пакета и помещает его в очередь потока, ассоциирован%
ную с адресуемой SAP. Обычно эта функция вызывается функци%
ей обработки прерывания при получении очередного кадра дан%
ных от сетевого адаптера.
Примитивы DLPI
Как и в случае предоставления транспортных услуг, обмен данными между
пользователем и поставщиком происходит в виде сообщений, несущих
примитивы DLPI. Ниже рассмотрены некоторые из этих примитивов, от!
носящиеся к режиму передачи без предварительного установления связи и
без подтверждения. Именно такой режим обычно используется в традици!
онных локальных сетях.
Несмотря на то что рассматриваемая услуга не предусматривает установ!
ления связи, фактической передаче данных предшествует обмен примити!
вами для инициализации потока и подключения его к поставщику услуг
уровня канала данных. Во!первых, пользователь должен создать точку дос!
тупа к поставщику услуг, для чего необходимо произвести операцию свя!
зывания. Во!вторых, в случае использования поставщика услуг второго
типа (style 2), пользователь также должен подключиться к требуемой
Наконец, пользователю может потребоваться произвести ряд действий,
включающих получение информации о созданном потоке, регистрацию
www.books-shop.com
498 Глава 6. сети в операционной системе UNIX
специфического группового адреса для потока или включение режима от!
сутствия фильтрации кадров, при котором пользователь сможет получать
копии всех пакетов, полученных поставщиком
После этого пользователь может передавать данные, учитывая, однако, что
в обсуждаемом режиме поставщик не гарантирует надежную доставку дан!
ных адресату (удаленному пользователю услуг уровня канала данных). На!
пример, отсутствие управления передачей может привести к переполне!
нию буферов, и, как следствие, к потере кадров. Неправильные кадры,
полученные из сети, также будут отбрасываться без уведомления пере!
дающей стороны. Однако преимуществом является отсутствие необходи!
мости установления связи и связанных с этим накладных расходов.
Итак, приведем некоторые управляющие сообщения DLPI, используемые
в режиме без предварительного установления связи и без подтверждения.
В табл. приведено их краткое описание.
Таблица 6.12. Примитивы DLPI
Примитив DLPI Тип сообщения Значение
DL_BIND_REQ Запрос на связывание.
Этот примитив инициируется пользовате%
лем услуг и запрашивает связывание пото%
ка с точкой доступа и его активизацию.
Следует иметь в виду, что активным счита%
ется поток, для которого поставщик услуг
может передавать или принимать пакеты
данных. Таким образом, РРА, ассоцииро%
ванная с данным потоком, должна быть
инициализирована до завершения обра%
ботки запроса на связывание (другими
словами, поставщик гарантирует, что при
получении пользователем подтверждения
связывания инициализация
РРА завершилась успешно. Сообщение
состоит из одного блока который
содержит значение адреса SAP, тип услуги
и ряд других параметров, обсуждение ко%
торых выходит за рамки данной книги.
Подтверждение получения запроса на
связывание.
Этот примитив отправляется пользовате%
лю услуг и означает, что поток был свя%
зан с адресом SAP и был активизирован.
Сообщение состоит из одного блока
M_PCPROTO, в частности, содержащего
значение адреса SAP.
этого режима и преиму!
щественно в приложениях мониторинга уровня канала данных.
www.books-shop.com
сети в UNIX System V 499
Таблица 6.12 (продолжение)
Примитив DLPI Тип
сообщения
DL ATTACH REQ M_PROTO Запрос на подключение к РРА.
Этот примитив инициируется пользователем
услуг уровня канала данных и запрашивает у
поставщика потока с указан%
ной РРА. Этот запрос является необходимым
для поставщика второго типа (style 2) для ука%
зания физической среды, по которой будут
передаваться данные. Сообщение состоит из
одного блока в котором пользова%
тель передает значение идентификатора РРА.
Формат этого идентификатора определяется
поставщиком. Пользователь должен указать,
как минимум, физическую среду передачи.
Для сетей, где несколько независимых кана%
лов передачи мультиплексируются в одном
физическом носителе, идентификатор также
должен содержать информацию о конкретном
канале передачи данных. Примером техноло%
гий, обеспечивающих такое мультиплексиро%
вание являются ISDN (каналы В и D) и ATM
(коммутируемые и постоянные виртуальные
каналы — SVC и
Запрос на получение параметров потока.
Этот примитив служит для запроса пользова%
телем значений размеров различных пара%
метров потока, активизированного поставщи%
ком DLPI, а также информации о текущем
состоянии интерфейса. Сообщение состоит из
одного блока
Параметры транспортного протокола.
Этот примитив служит для передачи пользова%
телю ранее запрошенных с помощью
DL_INFO_REQ параметров. Сообщение состоит
из одного блока M_PCPROTO, содержащего ин%
формацию, часть из которой приведена ниже:
— определяет максимальное
число октетов данных пользователя, которое
может быть передано в одном кадре.
(Максимальный размер SDU поставщика услуг.)
— определяет минимальный
размер SDU.
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
500 Глава 6. Поддержка сети в операционной UNIX
Таблица 6.12 (продолжение)
Примитив DLPI Тип со[
общения
INFO ACK — определяет максимальную
длину адреса DLSAP поставщика. Этот адрес,
помимо адреса SAP может также включать физи%
ческий адрес интерфейса и ряд других полей
(иерархический адрес).
f set — указывает смещение адреса
DLSAP в блоке
— указывает тип среды передачи,
поддерживаемой потоком DLPI. См. значение
поля структуры ранее в этой
главе.
— указывает текущее со!
стояние потока.
— определяет тип услуги,
обеспечиваемой потоком DLPI.
— определяет тип постав!
щика услуг (style 1 или style 2).
— определяет размер
физического широковещательного адреса.
— указывает смеще!
ние значения адреса DLSAP в блоке
DL REQ M PROTO Запрос на передачу данных.
Этот примитив применим только для услуг уровня
канала данных без предварительного установле%
ния связи и отправляется пользователем услуг в
качестве запроса на передачу кадра. Сообщение
состоит из одного блока за которым
может следовать один или несколько блоков типа
содержащих данные пользователя. Блок
содержит значения размера адресов и
сам адрес получателя кадра, а также приоритет
из диапазона, определенного поставщиком.
DL UNITDATA M PROTO Индикация получения данных.
Этот примитив применим только для услуг уровня
канала данных без предварительного установле%
ния связи и указывает пользователю, что постав%
щиком услуг получен кадр от удаленного узла.
Сообщение состоит из одного блока M_PROTO, за
которым может следовать один или несколько
блоков типа содержащих данные поль%
зователя. Блок M PROTO содержит значения ад%
ресов отправителя и получателя кадра.
www.books-shop.com
Заключение 501
Таблица 6.12 (окончание)
Примитив DLPI Тип
сообщения
Значение
Положительное подтверждение.
Этот примитив сообщает пользователю услуг
уровня канала данных, что предшествующий
примитив, инициированный им, был успешно
принят поставщиком услуг. Примитив
DL_OK_ACK передается только для примити%
вов, нуждающихся в подтверждении.
Сообщение об ошибке.
Этот примитив сообщает пользователю услуг,
что последний примитив, инициированный им,
вызвал ошибку. Получение этого примитива
может рассматриваться как отрицательное
подтверждение, свидетельствующее, что ни%
каких действий, связанных с ошибочным при%
митивом, не было предпринято. Сообщение
состоит из одного блока содер%
жащего тип примитива, вызвавшего ошибку,
код DLPI и, если возможно, код системной
ошибки UNIX.
DL UDERROR IND Сообщение об ошибке кадра.
Этот примитив применим только для услуг
уровня канала данных без предварительного
установления связи и указывает пользовате%
лю, что его запрос на передачу
вызвал ошибку и не может
быть выполнен. Сообщение состоит из одного
блока содержащего размер адреса
и сам адрес получателя, а также код ошибки.
Заключение
В этой главе описана организация сетевой поддержки UNIX. Рассмотре!
ние не выходило за рамки обсуждения семейства протоколов TCP/IP, хотя
архитектура сетевого доступа операционной системы позволяет обеспечить
поддержку практически любых протоколов. В этом отношении большей
гибкостью обладает сетевая подсистема UNIX System V, основанная на
архитектуре STREAMS.
Хотя стандартная спецификация протоколов гарантирует совместимость
между системами различных разработчиков и производителей, на эффек!
тивность и производительность сетевой подсистемы оказывает существен!
ное влияние конкретная реализация алгоритмов. Этот аспект особенно
www.books-shop.com
502 Глава 6. сети в операционной системе UNIX
актуален для протокола транспортного уровня — TCP. Безусловно, работа
сетевой подсистемы также существенным образом зависит от оптимальной
настройки, но этот вопрос, к сожалению, находится за пределами этой
книги. Однако сегодня уже недостаточно просто связи с удаленным хос!
том, и материал этой главы может помочь обеспечить требуемое качество
этой связи.
В главе также описан программный интерфейс сетевого доступа. В частно!
сти, был рассмотрен пример использования сокетов для межпроцессного
взаимодействия не только в рамках одного компьютера, но и в распреде!
ленной сетевой инфраструктуре.
Во второй части главы была описана внутренняя архитектура сетевых под!
систем в BSD UNIX и UNIX System V. Хотя эти вопросы наиболее инте!
ресны разработчикам драйверов и других подсистем ядра, более присталь!
ный взгляд на взаимодействие компонентов операционной системы может
помочь и администраторам в решении их проблем, и пользователям в
оценке качества работы их систем для уверенного обсуждения этой темы с
системным администратором.
www.books-shop.com
Приложение А
Электронный справочник
Многообразие команд и утилит UNIX, обилие ключей или опций к ним,
особенности применения и формат тех или иных системных вызовов и
функций могут озадачить неискушенного пользователя. К счастью, в
UNIX имеется электронный справочник, позволяющий быстро получить
исчерпывающую информацию по интересующей команде или функции,
формату файла или типам данных. Воспользоваться этим справочником
так же просто, как и любой другой утилитой UNIX. Для этого в команд!
ной строке нужно ввести man с названием команды или функции, о кото!
рой вы хотели бы получить информацию. Например, введя $ man man, вы
узнаете как пользоваться справочником.
Весь справочный материал разбит на разделы, порядок и названия кото!
рых различны для разных версий операционной системы. В таблице, при!
веденной ниже, перечислены традиционные разделы и их названия (чаще
всего, это просто номер) для двух основных ветвей UNIX: BSD и System V.
Содержимое раздела BSD UNIX V
Прикладные утилиты 1 1
Системные вызовы 2 2
Библиотечные функции 3 3
Специальные файлы, драйверы устройств и аппа% 4 7
ратное обеспечение
Форматы различных конфигурационных и систем% 5 4
файлов
Всякая всячина, например, типы файловых систем, 7 5
определение типов данных и т.д.
Административные утилиты 8
Некоторые разделы справочника могут иметь подсекции, содержимое ко!
торых можно уточнить, прочитав введение к соответствующему разделу.
Например, в операционной системе Solaris 2.x для вывода содержания раз!
дела "Библиотечные функции" необходимо задать следующую команду:
$ man !зЗ intro
Явное указание раздела понадобится и в том случае, когда по заданному
ключевому слову имеются статьи в различных разделах. Например, для
слова passwd имеются статьи в разделе 1 (команда для изменения
пароля пользователя) и в разделе 4 (формат файла паролей
Просматривая статью, обязательно прочитайте абзац с названием "SEE
ALSO" в котором приведены названия статей справочника, имеющие от!
ношение к интересующей вас тематике.
www.books-shop.com
Приложение Б
Дополнительная информация
об операционной системе UNIX
Книги
Б. Керниган, Р. UNIXуниверсальная среда программирования.
с англ. М.: Финансы и статистика, 1992. Прекрасная книга, напи!
санная людьми, принимавшими непосредственное участие в создании этой
операционной системы. Книга окажется интересной как для пользовате!
лей, так и для программистов и администраторов системы. Несмотря на
относительно небольшой объем, книга позволяет достаточно основательно
изучить эту операционную систему.
Bach M. The Design of the UNIX Operating System. Englewood Cliffs, NJ:
Prentice!Hall, 1986. Долгое время эта книга являлась практически единст!
венным полным описанием внутренней архитектуры UNIX. Хотя матери!
ал, представленный в книге, основан на системе UNIX System V Release 2,
большинство положений остаются справедливыми и сегодня.
М. Банахан, Э. Введение в операционную систему с
англ. Радио и связь, 1986. Одна из немногих книг по UNIX на русском
языке. Изданная на английском языке в 1982 году, книга в значительной
степени устарела. В основном предназначена тем, кто приступает к ис!
пользованию UNIX.
Р. Готье. Руководство по операционной системе с англ.
Финансы и статистика, 1985. Книга во многом копирует электронный
справочник man, хотя и содержит ряд любопытных примеров по исполь!
зованию тех или иных утилит. В книге также содержится ряд практиче!
ских рекомендаций для системного администратора. Несомненным досто!
инством является то, что книга написана на русском языке.
S., McKusick M.K., Karels M.J., J.S. The Design and
Implementation of the UNIX Operating System. Reading, MA:
1989. Книга написана группой разработчиков этой версии
операционной системы. В книге детально обсуждается внутренняя архи!
тектура ядра и принцип работы системы UNIX. Прекрасная воз!
можность получить информацию о UNIX "из первых уст".
www.books-shop.com
Информация в 505
Vahalia, U. UNIX Internals: the New Frontiers. River, NJ:
Prentice Hall, 1996. В книге сравниваются принципы организации и функ!
ционирования нескольких современных версий UNIX (SVR4.X, Solaris,
Digital UNIX, 4.4BSD, Mach и В книге нашли свое отражение по!
следние достижения в разработке операционных систем семейства UNIX.
Pate S.D. UNIX Internals. A Practical Approach. Addison Wesley Longman
Ltd., 1996. Книга написана сотрудником компании Santa Cruz Operation,
Inc. и посвящена архитектуре ядра операционной системы UNIX. Хотя
весь материал основан на версии UNIX SCO большая часть
положений справедлива и для других современных систем. Большое коли!
чество иллюстраций и практических примеров позволяет проникнуть в
тайны ядра UNIX.
Stevens, W.R. Advanced Programming in the UNIX Environment. Reading,
MA:Addison!Wesley, 1992. Наиболее полное описание программного ин!
терфейса операционной системы UNIX. Книга содержит много примеров
и служит прекрасным пособием разработчикам программного обеспечения
для этой операционной системы.
Stevens, W.R. UNIX Network Programming. Englewood Cliffs, NJ: Prentice
Hall, 1990. Прекрасное руководство для программистов в области сетевых
технологий. Многочисленные примеры позволяют проверить положения
книги на практике.
Информация в Internet
Официальный сервер UNIX В этом
разделе сервера группы The Open Group, собственностью которой является
зарегистрированный знак UNIX, вы можете ознакомиться с различными
спецификациями, имеющими отношение к этому семейству операцион!
ных систем. В частности, здесь вам предложат программное обеспечение
Report, позволяющее проверить насколько тексты написанной вами
программы удовлетворяют стандартам и требованиям переносимости.
Компания Santa Cruz Operation, Inc. На сервере
этой фирмы!производителя коммерческих версий операционной системы
UNIX — SCO OpenServer SCO и UnixWare, вы можете ознакомиться с ка!
талогом предлагаемого программного обеспечения, новинками и предло!
жениями от SCO. Здесь же вы узнаете, как получить бесплатную версию
систем OpenServer и UnixWare для некоммерческого использования. Об!
ширный раздел сервера посвящен разработчикам программного обеспече!
ния.
Сервер компании Silicon Graphics, Inc. Если вы сча!
стливый обладатель рабочей станции, сервера или суперкомпьютера фир!
www.books-shop.com
506 информация операционной системе UNIX
мы Silicon Graphics, вы наверняка частый гость на этом сервере. Здесь
представлен материал о собственной версии операционной системы
UNIX, получившей название IRIX. Сегодня эта операционная система ра!
ботает на компьютерах Silicon Graphics и считается одной из самых мощ!
ных.
Информационный центр DIGITAL UNIX Этот
сервер компании Digital Equipment Corporation посвящен операционной
системе DIGITAL UNIX, предназначенной для рабочих станций и серве!
ров на базе процессоров Alpha. Здесь вы ознакомитесь с новейшими дос!
тижениями компании, найдете полезный материал по операционной сис!
теме DIGITAL UNIX, а также сможете скопировать ряд программных
продуктов.
Программное обеспечение для серверов RS/6000 (http://www.rs6000.ibm.
Крупнейший производитель компьютеров и программного
обеспечения к ним, фирма IBM на этом сервере представляет собственную
версию операционной системы UNIX — AIX 4.x и разнообразные прило!
жения, разработанные для нее.
Сервер компании Berkeley Software Design, Inc. Эта
компания является поставщиком операционной системы BSDI, изначаль!
но разработанной в Калифорнийском университете Беркли. На этом сер!
вере вам предложат новинки программного обеспечения, часть из которых
можно скопировать на собственный сервер. Здесь вы имеете возможность
лучше ознакомиться с этой версией UNIX, по праву являющейся одним из
лидеров в области сетевых операционных систем.
FreeBSD На этом сервере вы найдете ответы на
все вопросы, связанные с операционной системой FreeBSD. Эта система
разработана и поддерживается большой группой энтузиастов, познако!
миться с которыми вы также сможете на этом сервере. Система включает
все возможности BSD UNIX и к тому же является совершенно бесплатной.
Если у вас дома имеется персональный компьютер, подключенный к
Internet, вы сможете установить систему по сети. После этого возвращай!
тесь на сервер и расширяйте возможности вашей рабочей станции, уста!
навливая дополнительное программное обеспечение.
OpenBSD Здесь вы познакомитесь с проектом
OpenBSD, направленным на разработку свободно распространяемой сис!
темы OpenBSD, в основе которой лежит версия UNIX Последняя
версия системы OpenBSD 2.1 была выпущена участниками проекта 2 июня
1997 года. Посетите этот сервер и вы узнаете, как получить и установить
эту систему.
NetBSD Еще один проект, посвященный разра!
ботке свободно распространяемой системы ветви BSD UNIX. Здесь вы уз!
наете о целях проекта, его истории и участниках, а также получите прак!
www.books-shop.com
Информация в Internet 507
тические советы, как получить дистрибутив операционной системы, уста!
новить ее и использовать в своей работе.
for Users Полезный справоч!
ный материал по UNIX, созданный в Университете Эдинбурга, Велико!
британия. Здесь вы можете найти советы по работе в операционной сис!
теме, например по настройке пользовательского окружения или управле!
нию задачами. Вы также ознакомитесь с основными концепциями UNIX,
а также с правилами применения основных команд и утилит. Если online!
доступ к этой информации кажется вам слишком медленным, вы сможете
переписать и установить электронную версию справочника на собствен!
ном компьютере.
World Online В этом разделе сер!
вера компании Sun Microsystems вы найдете электронные версии журнала
Краткие обзоры и аналитические статьи, посвященные различ!
ным аспектам, связанным с операционной системой Solaris и UNIX вооб!
ще, рекомендации экспертов и советы для начинающих, все это вы встре!
тите на страницах журнала. Вы можете оформить подписку и получать по
электронной почте уведомления о новых номерах журнала (на англ. яз.).
Журнал UnixWorld Здесь вы сможете
ознакомиться с электронным журналом UnixWorld, материалы которого
содержат практические рекомендации для начинающих пользователей,
экспертов и системных администраторов различных версий операционной
системы UNIX.
Вопросы и ответы по операционной системе Solaris (http://zaphod.cs.uni
sb.de/Corner/soIaris2.html). Если у вас возникла проблема, загляните в раз!
дел "Вопросы и ответы" сервера.
Сервер FreeBird (http://www.freebird.org). Сервер в основном посвящен
операционной системе SCO UnixWare, и конечно содержит информацию
полезную для пользователей других версий UNIX. На этом сервере вы мо!
жете заглянуть в онлайн страницы электронного справочника man, скопи!
ровать разнообразное программное обеспечение, познакомиться с теле!
конференциями, посвященными UNIX и многое другое.
Unix Guru Universe Этот сервер по праву называется
официальным сервером системных администраторов UNIX. По количеству
справочного материала, практических рекомендаций, программного обес!
печения, ссылок на другие ресурсы, имеющие отношение к UNIX, этот
сервер не имеет себе равных.
Ресурсы UNIX (http://wwwhost.cc.utexas.edu/cc/services/unix/index.html).
Прекрасный сервер Университета штата Техас, созданный в рамках проек!
та (Academic Computing and Instructional Technology Services). Ha
этом сервере вы сможете воспользоваться электронными версиями доку!
www.books-shop.com
Дополнительная об операционной системе UNIX
и руководств, найти различные ресурсы, связанные с вопросами
безопасности, сетевой поддержки, программного обеспечения.
Защита данных (http://voyager.crrel.usace.army.mil/~pete/security.html). На
сервере вы найдете информацию по различным аспектам защиты данных в
операционной системе UNIX, начиная с советов по выбору паролей и за!
канчивая практическими рекомендациями по защите вашей системы от
несанкционированного доступа.
Координационный центр CERT Это официальный
сервер Координационного центра группы быстрого реагирования по ком!
пьютерной безопасности CERT (Computer Emergency Team).
Здесь вы получите исчерпывающие ответы на вопросы об истории CERT,
целях и задачах этой организации, а также узнаете, как улучшить защи!
щенность вашей системы от несанкционированного доступа.
Электронная библиотека документации по SCO UNIX (http://www2.sco.
На этом сервере расположены электронные ги!
пертекстовые версии документации по операционным системам SCO
UNIX. Прекрасный источник информации для пользователей SCO UNIX.
UNIX Vault Прекрасная кол!
лекция ссылок на ресурсы Internet, связанные с операционной системой
UNIX.
Домашняя страница Ричарда
Если вы хотите познакомиться с автором замечательных книг по програм!
мированию в UNIX Ричардом Стевенсом, посетите его домашнюю стра!
ницу. Здесь вы найдете полную библиографию его книг с аннотациями и
содержанием, а также большое количество ссылок на другие источники
информации по операционной системе UNIX.
Зеркальный сервер компании SCO На сервере Санкт!
Петербургской фирмы OLLY представлен большой объем справочной ин!
формации, драйверов, условно бесплатного программного обеспечения для
операционных систем компании Santa Cruz Operation, Inc., включая зер!
кальные копии многих разделов сервера ftp.sco.com.
Книги и документация по UNIX на русском языке (http://pluto.xTech.
RU/Russian/UnixDoc/). На сервере Новосибирского института систем
информатики представлены переводы книг М. Баха "Архитектура опера!
ционной системы UNIX", M. Уэлша "Инсталляция Linux и первые шаги",
а также некоторые разделы электронного справочника man.
www.books-shop.com
указатель
Абсолютное имя файла, 143
Адрес
сокета, 269
Класс, 398
IP, 389; 398
MAC, 389
Адресное пространство
процесса, 204
ядра, 204
219
Атрибуты пользователя, 51
Блоки хранения данных, 290
Брейк!адрес, 151
Буферный кэш, 312
Диспетчер, 316
В
Ввод/вывод
Подсистема, 18
Потоки, 66
Буферизация, 132
128
Версии системы UNIX
BSD UNIX, 7
System III, 6
System V, 6
System V Release 4, 7
8
Виртуальная память, 18; 197
Виртуальная файловая система, 293
Владение файлами, 28; 140
Внутренняя структура, 313
Временной квант, 216
Вторичная память, 199
Уровни выполнения системы, 187
Г
Группа
цилиндров, 288
процессов, 173; 237
пользователей, 51
д
394
Демон (пример), 180
Дескриптор сегмента, 199
Диспетчер буферного кэша, 316
Диспозиция сигнала, 161
Дочерний процесс, 42; 154
Драйверы, 323; 369
Встраивание в ядро, 338
335
3
Задание, 80
Запуск новой программы, 230
И
Идентификатор
пользователя, 53
первичной группы, 53
процесса, 147
Индексный дескриптор, 20; 282
Виртуальный, 293
Массив 281
Интерфейс
DLPI, 487
Точка физического подключе!
ния, 488
Точка доступа к услугам, 488
TLI, 426
TPI, 472
Транспортные примитивы, 473
доступа низкого уровня, 47
системных вызовов, 16
К
Каналы, 128; 242
Каталог,
Корневой, 20; 26; 142
Текущий, 142
файловой системы s5fs, 285
Код возврата,
Командный интерпретатор, 56
Запуск команд
условный, 73
в фоновом режиме, 73
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
??????????????????????????????????????????????????????????????????????????????????????????piracy@books-shop.com
указатель
Команды, 82
Переменные, 60
экспортируемые, 64
внутренние, 64
Подстановки, 71
Приглашение
первичное, 63
вторичное, 63
Пример, 184
Система управления заданиями, 80
Скрипт, 57
Код возврата, 65
Условные выражения, 74
Функции
определенные пользователем, 69
встроенные, 69
Циклы, 77
Коммуникационный домен, 264
Коммутатор
протокола, 454
устройств, 325
файловых систем, 298
Контекст процесса, 221
м
Маршрут
по умолчанию, 459
прямой и косвенный, 460
Маршрутизация, 386; 394; 458
Таблица, 458
Маска сети, 399
Метаданные файла, 20; 144; 282
Микроядро, 8
Модель OSI, 391
Уровень
приложений, 387
сетевой, 387
транспортный, 387
управления доступом к среде
передачи, 490
управления логическим каналом,
490
н
Наследование атрибутов, 154; 156; 227
Область памяти, 207
Обработка ошибок, 95
Обработчик выхода,
Ограничение ресурсов, 177; 287
изменяемое, 177
жесткое, 177
Окно,
переполнения, 416; 418
Операции, 295; 297
вызов, 218
п
Память
Брейк!адрес, 151
виртуальная, 197
вторичная, 199
Выделение, 150
Область, 207
разделяемая, 258
Сегмент, 198; 404
Страница, 202; 198
Пароль пользователя, 52
Требования, 54
Переменные окружения, 115
Подсистема
STREAMS, 350
Головной модуль, 370
Модули, 356
IP, 466
TCP, 469
485
UDP, 468
Мультиплексирование, 378
Создание потока, 373
Сообщения, 357
типы, 361
ввода/вывода, 18
18
управления процессами, 18
Пользователи системы
стандартные, 55
Пссвдопользователи, 51
Суперпользоватсль, 51
Порт, 389; 401
Права доступа, 140
для каталогов, 32
к файлу, 30
Приоритет процесса, 222
Протокол
IP, 389; 393
Инкапсуляция, 493
LLC, 492
TCP, 404
Состояния, 406
Синдром "глупого окна", 414
Медленный старт, 416
Устранение затора,
Быстрая повторная передача, 420
www.books-shop.com
указатель 511
UDP, 402
Семейство 383; 464
архитектура, 386
скользящего окна, 405
Управляющий блок, 464
Процесс, 38
Адресное пространство, 197; 204
Атрибуты, 41
EUID, 41
Nice Number, 41
41
41
41
41
Выполнение, 189
в режиме ядра, 189; 233
в режиме задачи, 189
Планирование, 18; 216
Группа процессов, 173; 237
дочерний, 154
зомби, 193; 236
Идентификаторы, 147
Контекст, 221
переключение, 194; 221
Межпроцессное взаимодействие, 241
Ограничения ресурсов, 177
Переменные 115
Приоритет, 222
относительный, 86; 223
сна, 223
текущий, 223
42; 154
Создание, 154; 226
Состояния, 191
Структуры данных,
Управление, 86
Псевдотерминалы, 348
Основной драйвер, 348
Подчиненное устройство, 348
Путь, 20
Раздел диска, 280
Разделяемая память, 258
Родительский процесс, 42; 154
Свопинг, 199; 211
Область, 199
Связь
символическая, 22; 134
жесткая, 22
Сеанс, 173
Сегмент, 198
селектор сегмента, 199
Семафор, 253
Пример использования, 260
Сетевой интерфейс, 456
Сигналы
SIGBUS, 138
SIGALRM, 220
SIGCHLD, 158
SIGHUP, 175
SIGINT, 160; 175
46; 161
160; 175
SIGSTOP, 161; 195
SIGSTP, 175
SIGTERM, 46
175; 195
175; 195
217
Диспозиция, 161
Доставка и обработка, 238
Маска, 167
Набор, 166
надежные, 160; 166
Отправление, 237
Система межпроцессного
взаимодействия
FIFO, 22; 243
Идентификаторы, 245
Каналы, 128; 242
Пространство имен, 265
Разделяемая память, 258
Семафоры, 253
Сообщения, 248; 357
Сравнение различных средств, 277
Системный 183
Системный вызов, 16; 94
421
220
269; 421
143
141
140
143
271
124
125
125
exec(2), 42, 230
exit(2), 235
143
www.books-shop.com
512 указатель
141
140
143
129
42, 226
363; 371
173
getpgrp(2),
380; 463; 485
140
134
421
126
243
250
249
msgrcv(2), 250
250
122
128; 242
363; 370
126; 314; 363
273; 421
recvfrom(2), 273
255
semop(2), 255
273; 421
273
149
149
149
149
shmat(2), 259
260
259
166
socket(2), 266
144
316
134
134
229
158
127; 314; 363
127
для работы с файлами, 121
ошибки, 97
Скрипт, 57
Сокет, 25; 264; 453
Пример использования, 274
Программный интерфейс, 420
Типы, 265
Сон процесса, 234
Сообщения, 248
Пример использования, 251
Стандарты
11
IEEE 802.3, 491
10
11
XPG3, 11
Страница памяти, 202
Страничное замещение,
Структура данных
345
281
427
149
207; 229
proc, 190
queue, 356
region, 207; 229
167
168
334
общий, 335
stat, 144
user, 190
vfs, 297
294
Суперблок, 281
Суперпользователь, 51
Т
Таблица
дескрипторов, 200
маршрутизации, 458
Таймер, 469
Тик, 217
Текущий рабочий каталог, 142
Терминальная линия, 346
Неканонический режим, 347
Канонический режим, 347
Типы процессов, 39
Точка
входа, 325
доступа к услугам, 488
www.books-shop.com
указатель 513
монтирования, 298
физического подключения, 488
Удаленный вызов процедур (RPC), 440
Заглушка, 441
Обработка особых ситуаций, 444
Передача данных, 410
Передача параметров, 442
Представление данных, 445
Семантика вызова, 444
Управление
заданиями, 80
передачей данных, 364
процессами, 86
Управляющий терминал, 174; 237
Устройства, 342
блочные, 22; 340
Номер, 48; 325
символьные, 22
Утилиты
87
84
86
29
86
29; 86
cmp, 82
cp, 83
cut, 85
83
83
file, 86
find, 85
321
57; 349
83
head, 84
kill,
ld(l), 106
In, 83
57; 149; 349
83
83
84
83
nice, 86
84
ps, 87
re 86
83
83
84
to//, 84
85
Ф
Файловая система, 20
BSD 288
System V, 280
specfs, 333
Виртуальная, 293
Монтирование, 296
Структура, 26
Целостность,
Файловая таблица, 307
Файловый дескриптор, 123; 306
Файловый указатель, 130
Файлы, 20
Атрибуты
Дополнительные, 35; 141
Sticky bit, 36
36
36
Блокирование доступа, 309
311
310
Блокирование записи, 130
28; 140
Имена, 285
абсолютное, 143, 303
относительное, 143; 303
трансляция, 303
Класс доступа, 30
Метаданные, 20; 144; 282
Отображаемые в памяти,
специальные блочных устройств, 47
специальные символьных устройств,
22; 47
Форматы
COFF, 112; 205
ELF, 108; 205
исполняемых файлов, 107
кадров, 491
Фрагментация, 394
Функции стандартных библиотек
atexi1(3C), 120
152
153
152
275
www.books-shop.com
514 указатель
152
164
syslog(3), 183
t_accept(3N), 432
431
1_close(3N), 433
431
432
t_look(3N), 439
429
t_rcv(3N), 433
t_rcvrel(3N), 438
433
433
438
433
Функция 114
Ш
Шлюзы, 387
A
ANSI, 11
С
COFF, 112; 205
Computer Research Group, 5
EE
LF, 108; 205
Ethernet, 491
F
FIFO, 22; 243
Пример использования, 244
I
IEEE 802.3, 491
IP, 389
M
3
О
8
P
PDU, 389
10
Programmer's 5
R
440
s Sticky bit, 36
426; 471
11
Т
TCP, 404
TCP/IP, 383; 464
UDP, 402
UNIX System Group, 4
X
XPG3, 11
www.books-shop.com